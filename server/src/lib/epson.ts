// const ThermalPrinter = require("node-thermal-printer").printer;
// const this.printerTypes = require("node-thermal-printer").types;

// import tprint from '../../deps/node-thermal-printer/lib/core.js';

import { ThermalPrinter, PrinterTypes } from '../deps/node-thermal-printer';
// import tprint from 'node-thermal-printer';


/**
 * run with:
 * rm epson.js ; tsc -t ES2016 epson.ts ; node .\epson.js
 */


import { uint8 } from '../schema/type_uint8';

import * as config from '../config';

import * as snmp from 'net-snmp';
import e = require( 'cors' );



export function buf2hex ( buffer ) { // buffer is an ArrayBuffer
    return Array.prototype.map.call( new Uint8Array( buffer ), x => ( '00' + x.toString( 16 ) ).slice( -2 ) ).join( '' );
}
export function buf2bin ( buffer ) { // buffer is an ArrayBuffer
    return Array.prototype.map.call( new Uint8Array( buffer ), x => ( '00000000' + x.toString( 2 ) ).slice( -8 ) ).join( '' );
}

export class PrinterStatus {
    labelType: string = null;
    uptime: number = null;
    model: string = null;
    modelCode: MODEL_CODE;
    batteryLevel: BATTERY_LEVEL;
    extendedError: EXTENDED_ERROR;
    errorInformation1: ERROR_INFORMATION_1;
    errorInformation2: ERROR_INFORMATION_2;
    statusType: STATUS_TYPE;
    phaseType: PHASE_TYPE;
    phaseTypeHigh: PHASE_TYPE_HIGH;
    phaseTypeLow: PHASE_TYPE_LOW;
    notificationNumber: NOTIFICATION_NUMER;
    /** Float */
    firmwareVersion: number = null;
    // /** Float */
    // heightInch: number = null;
    // /** Int */
    // heightMillimeter: number = null;
    labelStatus: {
        mediaType: MEDIA_TYPE;
        mediaWidth: MEDIA_WIDTH;
        labelCharacteristic: LabelCharacteristic;
        tapeColor: TAPE_COLOR;
        textColor: TEXT_COLOR;
        /** NodeJS buffer */
        bytes: Buffer;
    };
}

/**
 * SEE PAGE 24 in Epson manual for status enums
 */

/**
 * Model Code is Byte 4 in the status returned
 */
export enum MODEL_CODE {
    PT_P900 = 0x71,
    PT_P900W = 0x69,
    PT_P950NW = 0x70
}

/**
 * Model Code is Byte 6 in the status returned
 */
export enum BATTERY_LEVEL {
    FULL = 0x00,
    HALF = 0x01,
    LOW = 0x02,
    NEEDS_CHARGING = 0x03,
    USING_AC = 0x04,
    UNKNOWN = 0xFF,
}

/**
 * Extended Error is Byte 7 in the status returned
 */
export enum EXTENDED_ERROR {
    FLE_TAPE_END = 0x10,
    DRAFT_PRINT_ERROR = 0x1d,
    INSERT_ERROR = 0x1e,
    BATTERY_ERROR = 0x1f,
    INCOMPATIBLE_MEDIA_ERROR = 0x21,
    SYSTEM_ERROR = 0xff
}


/**
 * Error Information 1 is Byte 8 in the status returned
 * This is provided as a bitmask, and therefor multiple options can be set
 */
export enum ERROR_INFORMATION_1 {
    NO_MEDIA = 0x01,
    END_OF_MEDIA = 0x02,
    CUTTER_JAM = 0x04,
    WEAK_BATTERIES = 0x08,
    PRINTER_IN_USE = 0x10,
    HIGH_VOLTAGE_ADAPTER = 0x40
}


/**
 * Error Information 2 is Byte 9 in the status returned
 * This is provided as a bitmask, and therefor multiple options can be set
 */
export enum ERROR_INFORMATION_2 {
    REPLACE_MEDIA_WRONG_MEDIA = 0x01,
    EXPANSION_BUFFER_FULL = 0x02,
    COMMUNICATION_ERROR = 0x04,
    COMMUNICATION_BUFFER_FULL = 0x08,
    COVER_OPEN = 0x10,
    OVERHEATING = 0x20,
    BLACK_MARKING_NOT_DETECTED = 0x40,
    SYSTEM_ERROR = 0x80
}


/**
 * Status Type is Byte 18 in the status returned
 */
export enum STATUS_TYPE {
    REPLY_TO_STATUS_REQUEST = 0x00,
    PRINTING_COMPLETED      = 0x01,
    ERROR_OCCURRED          = 0x02,
    EXIT_IF_MODE            = 0x03, // not used ?
    TURNED_OFF              = 0x04,
    NOTIFICATION            = 0x05,
    PHASE_CHANGE            = 0x06
}

/**
 * Phase Type is Byte 19 in the status returned
 */
export enum PHASE_TYPE {
    EDITING_STATE_RECEPTION_POSSIBLE = 0x00,
    PRINTING_STATE = 0x01
}
/**
 * Phase Type High is Byte 20 in the status returned
 */
export enum PHASE_TYPE_HIGH {
    EDITING_STATE_RECEPTION_POSSIBLE = 0x00,
    FEED = 0x01
}
/**
 * Phase Type Low is Byte 21 in the status returned
 */
export enum PHASE_TYPE_LOW {
    PRINTING                    = 0x00,
    COVER_OPEN_WHILE_RECEIVING  = 0x14
}

/**
 * NOTIFICATION_NUMER is Byte 22 in the status returned
 */
export enum NOTIFICATION_NUMER {
    NOT_AVAILABLE    = 0x00,
    COVER_OPEN       = 0x01,
    COVER_CLOSED     = 0x02,
    COOLING_STARTED  = 0x03,
    COOLING_FINISHED = 0x04
}


/**
 * Tape Color is Byte 24 in the status returned
 */
export enum TAPE_COLOR {
    WHITE               = 0x01,
    OTHER               = 0x02,
    CLEAR               = 0x03,
    RED                 = 0x04,
    BLUE                = 0x05,
    YELLOW              = 0x06,
    GREEN               = 0x07,
    BLACK               = 0x08,
    CLEAR_WHITE_TEXT    = 0x09,
    MATTE_WHITE         = 0x20,
    MATTE_CLEAR         = 0x21,
    MATTE_SILVER        = 0x22,
    SATIN_GOLD          = 0x23,
    SATIN_SILVER        = 0x24,
    BLUE_D              = 0x30,
    RED_D               = 0x31,
    FLOURESCENT_ORANGE  = 0x40,
    FLOURESCENT_YELLOW  = 0x41,
    BERRY_PINK      = 0x50,
    LIGHT_GRAY      = 0x51,
    LIME_GREEN      = 0x52,
    YELLOW_F        = 0x60,
    PINK_F          = 0x61,
    BLUE_F          = 0x62,
    WHITE_HSE       = 0x70,
    WHITE_FLEX      = 0x90,
    YELLOW_FLEX     = 0x91,
    CLEANING        = 0xf0,
    STENCIL         = 0xf1,
    INCOMPATIBLE    = 0xff
}



/**
 * Model Code is Byte 25 in the status returned
 */
export enum TEXT_COLOR {
    WHITE = 0x01,
    RED = 0x04,
    BLUE = 0x05,
    BLACK = 0x08,
    GOLD = 0x0a,
    BLUE_F = 0x62,
    CLEANING = 0xf0,
    STENCIL = 0xf1,
    OTHER = 0x02,
    INCOMPATIBLE = 0xff
}



/**
 * Possible options of returned media width. hse uses rounded sizes.  
 * `0x00` is an ERROR ( _NO TAPE_ )  
 * This is byte `10`
 */
type MEDIA_WIDTH = 0x00 | 0x04 | 0x06 | 0x09 | 0x0c | 0x12 | 0x18 | 0x24 | 0x15;


/**
 * Media type is Byte 11 in the status returned
 */
export enum MEDIA_TYPE {
    NO_MEDIA = 0x00,
    LAMINATED_TAPE = 0x01,
    NON_LAMINATED_TAPE = 0x03,
    FABRIC_TAPE = 0x04,
    HEAT_SHRINK_TUBE = 0x11,
    FLE_TAPE = 0x13,
    FLEXIBLE_ID_TAPE = 0x14,
    SATIN_TAPE = 0x15,
    INCOMPATIBLE_TAPE = 0xff
}

enum LengthType {
    millimenter = "mm",
    inch = "in",
    dots = "dots"
}

class Length {
    private _inches: number;
    private _dots: number;

    get inches (): number {
        return this._inches;
    }
    /**
     * dots are 1/180th of an inch.
     * Thus, 1 inch = 180 dots
     */
    get dots (): number {
        return this._dots;
    }
    constructor ( len: number, unit = LengthType.inch ) {
        if ( unit == LengthType.inch ) {

        }
        this._inches = len;
        this._dots = len * 180;
        if ( unit == LengthType.dots ) {
            this._inches = len / 180;
            this._dots = len;
        }
        if ( unit == LengthType.millimenter ) {
            throw Error( " mm are not yet supported " );
        }
    }
}


/**
 * Spec pars:
 * 1. Horizontal Dot Density
 * 2. Vertical Dot Density
 * 3. Horizontal Dot Resolution in 360th of an inch
 * 4. Vertical Dot Resolution
 */
class ImageBitMode {
    public static readonly mode0 = { mode: 0, bytesMultiple: 1 };
    // ... many more
    public static readonly mode32 = { mode: 32, bytesMultiple: 3 };
    // ... many more
    public static readonly mode73 = { mode: 73, bytesMultiple: 6 };

}

interface LabelCharacteristics {
    tze: {
        [ key: number ]: LabelCharacteristic;
    };
    hse: {
        [ key: number ]: LabelCharacteristic;
    };
}
interface LabelCharacteristic {
    widthMillimeters: number;
    pinsLeft: number;
    pinsPrint: number;
    pinsRight: number;
}


/**
 *
 * @param remarks
 * ```text
 Type | Width | Vert. area | Top/bot margin | Vert. range |  Max
 ...  |  (mm) | (mm/dots)  |      (mm)      |    (dots)   | Lines
 -----|-------|------------|----------------|-------------|------
 18   | 18    | 16.5 / 234 | 0.75           | 156-389     | 9
 12   | 12    | 10.6 / 150 | 0.71           | 198-247     | 6
 ```
 _See page 10 in ESC/P Guide_
 *
 */
export class BrotherLabeler {

    static LabelInfo: LabelCharacteristics = {
        tze: {
            3_5: {
                widthMillimeters: 3,
                pinsLeft: 248,
                pinsPrint: 48,
                pinsRight: 264
            },
            6: {
                widthMillimeters: 6,
                pinsLeft: 240,
                pinsPrint: 64,
                pinsRight: 256
            },
            9: {
                widthMillimeters: 9,
                pinsLeft: 219,
                pinsPrint: 106,
                pinsRight: 235
            },
            12: {
                widthMillimeters: 12,
                pinsLeft: 197,
                pinsPrint: 150,
                pinsRight: 213
            },
            18: {
                widthMillimeters: 18,
                pinsLeft: 155,
                pinsPrint: 234,
                pinsRight: 171
            },
            24: {
                widthMillimeters: 24,
                pinsLeft: 112,
                pinsPrint: 320,
                pinsRight: 128
            },
            36: {
                widthMillimeters: 36,
                pinsLeft: 45,
                pinsPrint: 454,
                pinsRight: 61
            }
        },
        hse: {
            6: {
                widthMillimeters: 6,
                pinsLeft: 244,
                pinsPrint: 56,
                pinsRight: 260
            },
            9: {
                widthMillimeters: 9,
                pinsLeft: 224,
                pinsPrint: 96,
                pinsRight: 240
            },
            12: {
                widthMillimeters: 12,
                pinsLeft: 206,
                pinsPrint: 132,
                pinsRight: 222
            },
            18: {
                widthMillimeters: 18,
                pinsLeft: 166,
                pinsPrint: 212,
                pinsRight: 182
            },
            24: {
                widthMillimeters: 24,
                pinsLeft: 144,
                pinsPrint: 256,
                pinsRight: 160
            },
        },
        // fle_21_45
    };

    /**
     * Command resets all parameters to their default settings  
     * `0x1b` `0x40`
     */
    public readonly init = Buffer.from( [ 0x1b, 0x40 ] );
    /** Newline, aka LF (Line Feed)  
     * `0x0a` */
    public readonly newline = Buffer.from( [ 0x0a ] );

    public printer: ThermalPrinter;

    printerHostname: string;
    constructor () {
        this.printerHostname = config.PRINTER_HOST;
        this.printer = new ThermalPrinter( {
            type: PrinterTypes.EPSON,  // 'star' or 'epson'
            interface: `tcp://${ config.PRINTER_HOST }:9100`,                       // this.printer interface
            options: {
                timeout: 1000
            },
            characterSet: 'PC437_USA',
        } );
    }

    /**
     * Returns byte array of command required for Brother Labeler in ESC/P
     *
     * @param len -
     *  Provide length in mm or inches as length object
     *
     * @remarks
     *  - Brother output Specifies length in 1/180th of an inch
     *  - Range can be from 0.2 to 40 inches
     *  - length of 0 specifies AUTO
     *
     * @returns byte array of command required
     *
     */
    setLength ( len: Length ): ArrayBuffer {
        let lengthBytes = Buffer.from( [
            0x1b, 0x69, 0x6c,
            ( len.dots % 256 ),
            ( Math.floor( len.dots / 256 ) )
        ] );
        return lengthBytes;
    }

    /**
     *
     * @param len - can not have a margin less than 0.04 inches ( 7 dots )
     *              nor greater than 4 inchess ( 720 dots )
     */
    setMarginWidth ( len: Length ): ArrayBuffer {
        let marginBytes = Buffer.from( [
            0x1b, 0x69, 0x6d,
            ( len.dots % 256 ),
            ( Math.floor( len.dots / 256 ) )
        ] );
        return marginBytes;
    }

    /**
     * _See page 40 in ESC/P guide for meanings of Modes, etc._
     *
     */
    selectBitImage ( mode = ImageBitMode.mode73 ): ArrayBuffer {
        throw Error( "not implemented yet" );
        /** Image Data Length in Bytes */
        let len = new Length( 0 );
        // let mode = 73;

        let imageBytes = Buffer.from( [
            0x1b, 0x2a,
            ( len.dots % 256 ),
            ( Math.floor( len.dots / 256 ) )
        ] );
        return imageBytes;
    }

    /** getPrinterStatus
     * 
     * Query printer via SNMP and return status values
     * 
     *  See for SNMP MIB:  
     *   - <http://www.mibdepot.com/cgi-bin/vendor_index.cgi?r=ietf_rfcs&id=64939>
     *   - <http://www.mibdepot.com/xsearch_index3.html?id=6955>
     *   - <http://www.mibdepot.com/cgi-bin/getmib3.cgi?win=mib_a&r=hp&f=jdMibCV5.mib&v=v2&t=tree>
     *   - <http://www.oidview.com/mibs/2435/BROTHER-MIB.html>
     */
    async getPrinterStatus (): Promise<PrinterStatus> {
        try {
            var session = snmp.createSession( this.printerHostname, "public" );

            /**
             * While I don't see any "Label ID" within the SNMP MIB, it is possible it is something non-obvious.
             * Try changing labels and seeing what values change.
             * 
             * Of interest is `1.3.6.1.2.1.43.8.2.1.8` and anything under `1.3.6.1.2.1.43.8.2.1`
             */
            var oids = {
                "1.3.6.1.2.1.43.8.2.1.12.1.1": "labelType",
                "1.3.6.1.2.1.1.3.0": "uptime",
                "1.3.6.1.4.1.2435.2.4.3.1240.1.1.0": "model",
                "1.3.6.1.4.1.2435.2.4.3.1240.1.4.0": "firmwareVersion",
                "1.3.6.1.4.1.2435.3.3.9.1.6.1.0": "labelStatusBytes"
                // "1.3.6.1.2.1.4.20.1": "ipAddresses"
                // "1.3.6.1.4.1.2435.2.4.3.1240.5.2.3.0": "ipAddress"
                // contact, name, location
                // "1.3.6.1.4.1.2435.2.4.3.100.1.11.11.1.2": "wifiNetworks"
            };
            let retObj: PrinterStatus = new PrinterStatus();

            return await new Promise( ( resolve, reject ) => {
                session.get( Object.keys( oids ), function ( error, varbinds ) {
                    if ( error ) {
                        console.error( error );
                    } else {
                        for ( var i = 0; i < varbinds.length; i++ ) {
                            if ( snmp.isVarbindError( varbinds[ i ] ) ) {
                                console.error( snmp.varbindError( varbinds[ i ] ) );
                            } else {
                                console.log( oids[ varbinds[ i ].oid ], varbinds[ i ].oid + " = " + varbinds[ i ].value );
                                let val = varbinds[ i ].value;
                                retObj[ oids[ varbinds[ i ].oid ] ] = val instanceof Buffer ? val.toString() : val;
                                if ( oids[ varbinds[ i ].oid ] === "labelStatusBytes" ) {
                                    retObj.labelStatus = {
                                        mediaType: MEDIA_TYPE[ MEDIA_TYPE[ val[ 11 ] ] ],
                                        mediaWidth: val[ 10 ],
                                        tapeColor: TAPE_COLOR[ TAPE_COLOR[ val[24] ] ],
                                        textColor: TEXT_COLOR[ TEXT_COLOR[ val[25] ] ],
                                        labelCharacteristic: BrotherLabeler.LabelInfo[ val[ 11 ] === MEDIA_TYPE.HEAT_SHRINK_TUBE ? 'hse' : 'tze' ][ val[ 10 ] ],
                                        bytes: val
                                    };
                                    retObj.batteryLevel = BATTERY_LEVEL[ BATTERY_LEVEL[ val[ 6 ] ] ];
                                    retObj.extendedError = EXTENDED_ERROR[ EXTENDED_ERROR[ val[7] ] ];
                                    retObj.errorInformation1 = ERROR_INFORMATION_1[ ERROR_INFORMATION_1[ val[8] ] ];
                                    retObj.errorInformation2 = ERROR_INFORMATION_2[ ERROR_INFORMATION_2[ val[9] ] ];
                                    retObj.statusType = STATUS_TYPE[ STATUS_TYPE[ val[ 18 ] ] ];
                                    retObj.phaseType = PHASE_TYPE[ PHASE_TYPE[ val[ 19 ] ] ];
                                    retObj.phaseTypeHigh = PHASE_TYPE_HIGH[ PHASE_TYPE_HIGH[ val[ 6 ] ] ];
                                    retObj.phaseTypeLow = PHASE_TYPE_LOW[ PHASE_TYPE_LOW[ val[ 6 ] ] ];
                                    retObj.notificationNumber = NOTIFICATION_NUMER[ NOTIFICATION_NUMER[ val[ 22 ] ] ];
                                }
                            }
                        }
                    }
                    if ( retObj ) {
                        retObj[ "heightInch" ] = parseFloat( /[0-9]\.[0-9]{1,2}(?=\")/.exec( retObj[ "labelType" ] )[ 0 ] );
                        retObj[ "heightMillimeter" ] = parseFloat( /[0-9]{1,2}mm/.exec( retObj[ "labelType" ] )[ 0 ] );
                        resolve( retObj );
                    }
                    // If done, close the session
                    session.close();

                } );
            } );
        } catch ( error ) {
            console.error( error );
        }
    }

    async printRaster ( inputBuffer: Array<Array<Array<uint8>>> ) {

        if ( ! inputBuffer ){
            console.error( "printRaster received an invalid inputBuffer" );
            throw "printRaster received an invalid inputBuffer" ;
        }

        let { labelStatus } = await this.getPrinterStatus();

        // let shiftBits = labelStatus.labelCharacteristic.pinsLeft % 8;
        // let shiftBytes = Math.ceil( labelStatus.labelCharacteristic.pinsLeft / 8 );
        let shiftBits = labelStatus.labelCharacteristic.pinsRight % 8;
        let shiftBytes = Math.ceil( labelStatus.labelCharacteristic.pinsRight / 8 );
        
        console.log( { labelStatus, shiftBits, shiftBytes } );

        let invalidateBuf = [];
        for ( let i = 0; i < 200; i++ ) {
            invalidateBuf.push( 0x00 );
        }

        /**********************************
         ** From the example in the docs **
         **********************************
         * 0x00 x 200
         *                         1b 40 1b 69 61 01 1b 69
         * 55 4a 00 0c c0 7c d1 fd c8 28 00 00 09 00 00 00
         * 1b 69 7a 84 00 24 00 6e 05 00 00 02 00 1b 69 4D
         * 40 1b 69 41 01 1b 69 4b 0c 1b 69 6b 63 01 00 1b
         * 69 64 0e 00 4d 02
         * 
         * 1b 40                                                            initialize
         * 1b 69 61 01                                                      select raster
         * 1b 69 55 4a 00 0c c0 7c d1 fd c8 28 00 00 09 00 00 00            JOB ID SETTINGS - **NOT NECCESSARY FOR USER TO SET**
         * 
         * 1b 69 7a 84 00 24 00 6e 05 00 00 02 00                           Print information command
         *                                                                      + 6e 05 00 00   raster number
         *                                                                        110 + ( 1280 ) = 1390
         * 1b 69 4D 40                                                      Various Mode settings
         *                                                                      + Automatic Cutting
         * 1b 69 41 01                                                      Specify the page number in "cut each * labels"
         *                                                                      + 
         * 1b 69 4b 0c                                                      Advanced mode settings
         *                                                                      + 
         * 1b 69 6b 63 01 00
         *                                                                      + 
         * 1b 69 64 0e 00 4d 02                                             Specify margin amount (feed amount)
         *                                                                      + 
         */

        let printBuffer = Buffer.concat( [

            Buffer.from( [
                ...invalidateBuf,                // invalidate
                0x1b, 0x40,                      // initialize
            ] ),
            // imageBuf,
            // labeler.newline,
            Buffer.from( inputBuffer.map( ( page, pageNumber ) => {

                let pageByteLength = page.flat(1).length;

                console.log( `processing inputBuffer page ${ pageNumber }\n`, {
                    _____pageLenth: page.length,
                    pageByteLength: pageByteLength,
                    mod256: page.length % 256
                } );

                /** 
                 * page number:  
                 * * 0 -> first page
                 * * 1 -> intermediate page
                 * * 2 -> last page (also always when single page)
                **/
                let print_info_n9: 0x00 | 0x01 | 0x02;
                if ( pageNumber === 0 ) {
                    print_info_n9 = 0x00;
                } else if ( pageNumber === inputBuffer.length - 1){
                    print_info_n9 = 0x02;
                } else {
                    print_info_n9 = 0x01;
                }

                return [

                    0x1b, 0x69, 0x61, 0x01,             // select Raster mode

                    /**
                     * print information
                     * see page 32
                     * 10 bytes sent to configure page
                     **/
                    0x1b, 0x69, 0x7a,                   // print information 'header'
                    0x04,                               // Media width ; other options: KIND, LENGTH, QUALITY, RECOVER
                    0x00,                               // laminated tape
                    0x0c, 0x00,                         // 12mm ;  ************ TODO: this should read the actual tape *******************
                    /**
                     * raster number ; this is the number of COLUMNS *not* bytes
                     * this is the next 4 bytes ( n5, n6, n7, n8)
                     **/
                    page.length % 256,                                  // n5
                    Math.floor( page.length / Math.pow( 256, 1 ) ),     // n6
                    Math.floor( page.length / Math.pow( 256, 2 ) ),     // n7
                    Math.floor( page.length / Math.pow( 256, 3 ) ),     // n8
                    print_info_n9,                      // n9
                    0x00,                               // N/A ; always 0



                    0x1b, 0x69, 0x41, 0x01,             // auto-cut, default which means "Cut all" is 0x01
                                                        // unsure what pages means, says 1-99 is valid -- `Specify the page number in "cut each * labels"`
                    0x1b, 0x69, 0x64, 0x00, 0x00,       // set the margin between each label and the cut line.
                    // 0x1b, 0x69, 0x64, 0x0e, 0x00,       // set margin to 15 , which should be ~ 1mm
                    0x4d, 0x00,                         // no compression

                    ...page.map( ( col, idx ) => {
                        // console.log( `processing inputBuffer page ${ pageNumber }, col ${ idx }` );
                        let o_col_len = col.length; // FOR DEBUG ONLY

                        let paddedCol: typeof col = [];
                        let transfer: number = null;
                        while ( paddedCol.length < 0x46 ) {

                            if ( paddedCol.length < shiftBytes ) {
                                // console.log( `padding inputBuffer (current length is ${ paddedCol.length }, col ${ idx }` )
                                paddedCol[ paddedCol.length ] = 0x00;
                                continue;
                            }
                            /**
                             * `transfer` is the bits being moved from one byte to the next
                             * note: length being shifted will be `8 - shiftbits`;
                             */
                            let originalByte = paddedCol.length - shiftBytes - 1 >= 0 ? col[ paddedCol.length - shiftBytes - 1 ] : 0x00;
                            transfer = originalByte & ( 0xff >> ( 8 - shiftBits ) );
                            // debug below
                            if ( col[ paddedCol.length - shiftBytes ] && idx === 1 ) {
                                let final_result = ( col[ paddedCol.length - shiftBytes ] >> shiftBits ) | ( transfer << ( 8 - shiftBits ) );
                                console.log(
                                    `${ paddedCol.length }: ` +
                                    `0x${ buf2hex( [ originalByte ] ) } ${ buf2bin( [ originalByte ] ) } ` +
                                    `& 0xff >> ${ 8 - shiftBits } ` +
                                    `(${ 0xff >> shiftBits }) = ` +
                                    `${ buf2bin( [ transfer ] ) } ` +
                                    `(${ transfer } 0x${ buf2hex( [ transfer ] ) }) \n` +

                                    `    ${ buf2bin( [ col[ paddedCol.length - shiftBytes ] ] ) } >> ${ shiftBits } | ` +
                                    `${ buf2bin( [ transfer ] ) } << ${ shiftBits } = ` +
                                    buf2bin( [ final_result ] ) +
                                    `(${ final_result & 0xff } 0x${ buf2hex( [ final_result ] ) }) \n`

                                );
                            }
                            paddedCol[ paddedCol.length ] = (
                                ( col[ paddedCol.length - shiftBytes ] >> shiftBits )
                                |
                                ( transfer << ( 8 - shiftBits ) ) ) as uint8;



                        }


                        // if ( col.length < 0x46 ){
                        //     while ( col.length < 0x46 ) {
                        //         col[ col.length ] = 0x00;
                        //     }
                        // } else if ( col.length > 0x46 ){
                        //     col = col.slice(0, 0x46);
                        // }
                        // console.log( `processed inputBuffer page ${ pageNumber }, cols ${ idx }` );
                        if ( pageNumber === 0 && idx === 1 ) {
                            console.log( {
                                pages: inputBuffer.length,
                                cols: inputBuffer[pageNumber].length,
                                shiftBits: shiftBits,
                                shiftBytes: shiftBytes,
                                labelCharacteristic: labelStatus.labelCharacteristic,
                                original_len: o_col_len,
                                original_len_hex: `0x${buf2hex( [ o_col_len ] )}`,
                                new_length: col.length,
                                new_length_hex: `0x${buf2hex( [ col.length ] )}`,
                                paddedCol_length: paddedCol.length,
                                paddedCol_length_hex: `0x${buf2hex( [ paddedCol.length ] )}`,
                                ______col: `0x${buf2hex( col )}`,
                                paddedCol: `0x${buf2hex( paddedCol )}`
                            } );
                        }
                        return [
                            0x47, 0x46, 0x00,
                            ...paddedCol
                        ];
                    } ), pageNumber === inputBuffer.length - 1 ? 0x1a : 0x0c ];

            } ).flat().flat() ),

            // Buffer.from( [0x1a] ) // last page print


            // labeler.newline,

            // imageBuf,

        ] );

        console.log( {
            printBuffer_length: inputBuffer.length,
            printBuffer_flat_2_length: inputBuffer.flat( 2 ).length,
            printBuffer: buf2hex( printBuffer )
        } );



        try {
            await this.printer.raw( printBuffer );
            // console.log()
        } catch ( error ) {
            console.error( "ERROR", error );
        }

    }







    /**
     *
     * @param imageHex - this should be an array of Buffers, where each array entry is one output "line".
     * @remarks
     * 1 dot = 1 "pixel"
     */
    // imageMode73Density ( imageLinesBuf: Buffer[] ): Buffer {
    imageMode73Density ( imageLinesBuf: uint8[][][] | Array<Buffer> ): Buffer {
        let outputLinesBuf: Buffer = Buffer.from( [] );
        imageLinesBuf.forEach( ( buf, index ) => {
            if ( !Buffer.isBuffer( buf ) ) {
                buf = Buffer.from( ( Array.isArray( buf ) ? ( buf as Array<any> ).flat() : buf ) );
            }
            if ( Buffer.isBuffer( buf ) ) {
                let dotPositions = buf.byteLength / ImageBitMode.mode73.bytesMultiple;
                let n1 = ( dotPositions % 256 );
                let n2 = ( Math.floor( dotPositions / 256 ) );
                console.log( `Line # ${ index }: creating imageMode73Density image line of size ${ buf.byteLength } bytes [ ${ n2 } * 256 + ${ n1 } ], ${ dotPositions } positions` );
                outputLinesBuf = Buffer.concat( [
                    outputLinesBuf,
                    Buffer.from( [
                        0x1b,
                        0x2a,
                        73,
                        n1,
                        n2,
                    ] ),
                    buf
                ] );
                console.log( `imageMode73Density line: ${ index }\n`, buf2hex( buf ) );

                /// DEBUG -- DELETE ME
                // add a newline if NOT the last line
                if ( index < ( imageLinesBuf.length - 2 ) ) {
                    console.log( `Line # ${ index }: adding newline as ${ index } is less than ${ imageLinesBuf.length - 1 }` );
                    outputLinesBuf = Buffer.concat( [
                        outputLinesBuf,
                        this.newline
                    ] );
                }
            } else {
                throw `Invalid buffer ${ buf }`;
            }
        } );
        console.log( "imageMode73Density is returning:\n", buf2hex( outputLinesBuf ) );
        return outputLinesBuf;
    }


    /**
     *
     * @param inputBuffer Array of Buffers or Array of uint8[][][] ; 4th (outer / wrapping) array is for multiple labels.
     */
    async print ( inputBuffer: Array<Array<Array<Array<uint8>>>> ) {
        // async print( inputBuffer: Array<Array<Array<Array<uint8>>>> | Array<Buffer> ) {

        let labeler = new BrotherLabeler();

        let labelLen = new Length( 0.75 );

        try {
            await this.printer.raw(
                Buffer.concat( [

                    Buffer.from( [
                        0x1b, 0x69, 0x61, 0x00,          // select ESC/P mode
                        0x1b, 0x40,                      // initialize ESC/P mode

                        0x1b, 0x33, 0,                   // line feed = 24 / 180th of an inch


                        // , 0x1b, 0x52, 0x0 // char set = USA

                        /**
                         * Set label length
                         * set to 0 for AUTO
                        **/
                        0x1b, 0x69, 0x6c,
                        // ( labelLen.dots % 256 ),
                        // ( Math.floor( labelLen.dots / 256 ) ),
                        0, 0, // trying auto

                        /**
                         * Set margin **width**
                         * default is 2mm (see page 38)
                         * this is measured in 1/180th of an inch, with the smallest being 0.04" (~1mm)
                         * 7/180 = .0355, so I'm thinking this is the end.
                        **/
                        0x1b, 0x69, 0x6d, 7, 0,          // set margin to smallest possible (7)

                        /** 
                         * Specify cut
                         *  see page 82
                         * 
                         * 0 = full cut
                         * 1 = half cut
                         * 2 = chain print
                         * 3 = special tape
                         * 4+  unused
                         */
                        0x1b, 0x69, 0x43, 0b00000100,    // specify cut setting = chain print

                        0x1b, 0x24, 0, 0,                // specify horizontal position
                    ] ),
                    // imageBuf,
                    // labeler.newline,
                    ...inputBuffer.map( ( page, idx ) => {
                        let imageBuf73 = labeler.imageMode73Density( page );
                        // let imageBuf73 = labeler.imageMode73Density(labeler.imageMode73DensityTestData());
                        console.log( `Page # ${ idx } of ${ inputBuffer.length }: \n\timageBuf73 is ${ imageBuf73.byteLength } bytes in length\n\tTerminating with ${ idx === inputBuffer.length - 1 ? 'lastpage, cut: 0x0c' : 'intermediary page, new page: 0xff' }` );

                        return Buffer.concat( [
                            imageBuf73,
                            Buffer.from( [
                                // 0xFF if a new page is desired. This can auto-cut.
                                0x0c,
                                // also try with 0x0c only last
                                // idx === inputBuffer.length -1 ? 0x0c : 0xff
                            ] )
                        ] );
                    } )

                    // labeler.newline,

                    // imageBuf,

                ] ) );
            // console.log()
        } catch ( error ) {
            console.error( "ERROR", error );
        }
    }


    static testImageData = () => {
        const buf = Buffer.from( [
            0b01111110,
            0b00111100,
            0b00011000,
            0b01010101,
            0b10101010,
            0b01010101,
            0b10101010,
            0x01,
            0b10000000,
            0xFF,
            0xFF,
            0x00,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0xFF,
            0x0F,
            0xFF,
            0x0F,
            0xFF,
            0x0F,
            0xFF,
            0x0F,
            0xFF,
            // 0b01010101,
            // 0b10101010,
            0b01010101,
            0b10101010,
            0b01010101,
            0b10101010,
            0b01010101,
            0b10101010 ] );
        let lenDots = Buffer.byteLength( buf );
        console.log( `sending test image of size ${ lenDots } bytes` );
        return {
            buffer: buf,
            bytes: lenDots
        };
    };



    static imageMode73DensityTestData (): Buffer[] {
        return [ Buffer.from( [
            0xF8, 0x3E, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x3E, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xF8, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0x01, 0x80, 0x01, 0x80, 0xC0, 0x18, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x18, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0xFF, 0x00, 0x01, 0x80, 0x00, 0x03, 0x99, 0xC0, 0x01, 0x00, 0x00, 0x06, 0x18, 0x60, 0x02, 0x00, 0x00, 0x06, 0x18, 0x60, 0x06, 0x00, 0x00, 0x04, 0x18, 0x20, 0x06, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x04, 0x18, 0x20, 0x00, 0x00, 0x00, 0x06, 0x18, 0x61, 0xC7, 0xFF, 0xF8, 0x03, 0x18, 0xC0, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x01, 0xC0, 0xE0, 0xFF, 0xFF, 0xF0, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x18, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x30, 0xFF, 0xFF, 0xF0, 0x03, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x80, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x03, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x06, 0x00, 0x61, 0xFF, 0xFF, 0xF8, 0x03, 0x00, 0xC1, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0x80, 0x00, 0xC0, 0x00, 0x00, 0x7E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xF8, 0x80, 0x00, 0x01, 0xFF, 0xFF, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0xC7, 0xFF, 0xF8, 0x00, 0x01, 0xE1, 0xC7, 0xFF, 0xF8, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x01, 0xFF, 0xFF, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x01, 0xE1, 0xFF, 0xFF, 0xF8, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x00, 0x00, 0x01, 0xCC, 0xE0, 0x00, 0x7E, 0x00, 0x03, 0x0C, 0x30, 0x01, 0xFF, 0x80, 0x03, 0x0C, 0x30, 0x03, 0x00, 0xC0, 0x02, 0x0C, 0x10, 0x06, 0x00, 0x60, 0x06, 0x0C, 0x18, 0x04, 0x00, 0x20, 0x06, 0x0C, 0x18, 0x0C, 0x00, 0x30, 0x06, 0x0C, 0x18, 0x0C, 0x00, 0x30, 0x02, 0x0C, 0x10, 0x0C, 0x00, 0x30, 0x03, 0x0C, 0x30, 0x04, 0x00, 0x20, 0x01, 0x8C, 0x60, 0x06, 0x00, 0x60, 0x00, 0xFC, 0x40, 0x06, 0x00, 0x60, 0x00, 0x1C, 0x00, 0x03, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0x02, 0x00, 0x00, 0x03, 0x80, 0x00, 0x06, 0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x04, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x03, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x06, 0x00, 0x60, 0x00, 0x00, 0x00, 0x04, 0x00, 0x60, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x00, 0x00, 0x00, 0x03, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0xE7, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

        ] ),
        Buffer.from( [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x70, 0x00, 0x00, 0x00, 0x01, 0x86, 0x18, 0x00, 0x00, 0x00, 0x01, 0x86, 0x18, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00, 0x01, 0x86, 0x18, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x30, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xE3, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x70, 0x00, 0x00, 0x00, 0x02, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xC1, 0xF8, 0x00, 0x00, 0x00, 0x01, 0x83, 0x18, 0x00, 0x00, 0x00, 0x01, 0x82, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x06, 0x08, 0x00, 0x00, 0x00, 0x03, 0x06, 0x08, 0x00, 0x00, 0x00, 0x03, 0x04, 0x18, 0x00, 0x00, 0x00, 0x01, 0x84, 0x10, 0x00, 0x00, 0x00, 0x01, 0xCC, 0x70, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x76, 0x70, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x18, 0x00, 0x00, 0x00, 0x01, 0x86, 0x18, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x06, 0x08, 0x00, 0x00, 0x00, 0x01, 0x86, 0x18, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x38, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x70, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ] ) ];
    }



}