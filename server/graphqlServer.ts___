import { ApolloServer, gql } from "apollo-server-express";
import { GraphQLSchema, GraphQLObjectType, GraphQLBoolean , GraphQLScalarType } from 'graphql'
import express from "express";
import { GraphQLUpload ,} from 'graphql-upload'
import { Stream } from "stream";


const typeDefs = gql`
  type File {
    filename: String!
    mimetype: String!
    encoding: String!
  }
  type Query {
    uploads: [File]
  }
  type Mutation {
    singleUpload(file: Upload!): File!
  }
`;


// Upload --------------------------------------------------------------------

export interface IUpload {
  stream: string
  filename: string
  mimetype: string
  encoding: string
}

interface IUploadArgument {
  argumentName: string
  upload: Promise<IUpload> | Promise<IUpload>[]
}

interface IProcessedUploadArgument<T> {
  argumentName: string
  upload: T | T[]
}

declare type IUploadHandler<T> = (upload: IUpload) => Promise<T>

interface IConfig<T> {
  uploadHandler: IUploadHandler<T>
}

/**
 *
 * @param def
 * @param value
 *
 * Funciton used to identify GraphQLUpload arguments.
 *
 */
export function uploadTypeIdentifier(
  def: GraphQLArgument,
  value: any,
): IUploadArgument {
  if (isGraphQLArgumentType(GraphQLUpload, def)) {
    return {
      argumentName: def.name,
      upload: value,
    }
  } else {
    return null
  }
}

/**
 *
 * @param args
 * @param info
 *
 * Function used to extract GraphQLUpload argumetns from a field.
 *
 */
function extractUploadArguments(
  args: { [key: string]: any },
  info: GraphQLResolveInfo,
): IUploadArgument[] {
  return filterMapFieldArguments(uploadTypeIdentifier, info, args)
}

/**
 *
 * @param arr
 *
 * Converts an array of processed uploads to one object which can
 * be later used as arguments definition.
 *
 */
export function normaliseArguments<T>(
  args: IProcessedUploadArgument<T>[],
): { [key: string]: T } {
  return args.reduce((acc, val) => {
    return {
      ...acc,
      [val.argumentName]: val.upload,
    }
  }, {})
}

/**
 *
 * @param uploadHandler
 *
 * Function used to process file uploads.
 *
 */
export function processor<T>(uploadHandler: IUploadHandler<T>) {
  return function({
    argumentName,
    upload,
  }: IUploadArgument): Maybe<Promise<IProcessedUploadArgument<T>>> {
    if (Array.isArray(upload)) {
      const uploads = upload.reduce((acc, file) => {
        if (file !== undefined && file !== null && file.then) {
          return [...acc, file.then(uploadHandler)]
        } else {
          return acc
        }
      }, [])

      return Promise.all(uploads).then(res => ({
        argumentName: argumentName,
        upload: res,
      }))
    } else if (upload !== undefined && upload !== null && upload.then) {
      return upload.then(uploadHandler).then(res => ({
        argumentName: argumentName,
        upload: res,
      }))
    } else {
      return null
    }
  }
}

/**
 *
 * @param config
 *
 * Exposed upload function which handles file upload in resolvers.
 * Internally, it returns a middleware function which is later processed
 * by GraphQL Middleware.
 * The first step is to extract upload arguments using identifier
 * which can be found above.
 * Once we found all the GraphQLUpload arguments we check whether they
 * carry a value or not and return a Promise to resolve them.
 * Once Promises get processed we normalise outputs and merge them
 * with old arguments to replace the old values with the new ones.
 *
 */
export function upload<T>({ uploadHandler }: IConfig<T>): IMiddlewareFunction {
  return async (resolve, parent, args, ctx, info) => {
    const uploadArguments = extractUploadArguments(args, info)
    const uploads = filterMap(processor(uploadHandler), uploadArguments)

    const uploaded = await Promise.all(uploads)
    const argsUploaded = normaliseArguments(uploaded)

    const argsWithUploads = { ...args, ...argsUploaded }

    return resolve(parent, argsWithUploads, ctx, info)
  }
}
// interface File {
//     filename: string,
//     mimetype: string,
//     encoding: string,
// }
// interface Query {
//     uploads: () => File[]
// }
// interface Mutation {
//     singleUpload: processFileUploads
// }

// interface ResolversT {
//     Query: Query;
//     Mutation: Mutation;
// }

interface GraphQLUpload {
    stream: Stream;
    filename: string;
    mimetype: string,
    encoding: string,
}

const resolvers = {
    Query: {
        uploads: (parent, args) => {
            console.log("query();")
            // Return the record of files uploaded from your DB or API or filesystem.
        }
    },
    Mutation: {
        async singleUpload(parent, args): Promise<File> {
            return args.file.then(file => {
                return file;
            })
            // const { stream, filename, mimetype, encoding } = await file;

            // // 1. Validate file metadata.

            // // 2. Stream file contents into cloud storage:
            // // https://nodejs.org/api/stream.html

            // // 3. Record the file upload in your DB.
            // // const id = await recordFile( â€¦ )

            // console.log("singleUpload();")

            // return { filename, mimetype, encoding };
        }
    },
    // Upload: GraphQLUpload
};

const server = new ApolloServer({ typeDefs, resolvers });

const app = express();
server.applyMiddleware({ app });

app.listen({ port: 4000 }, () =>
    console.log(`ðŸš€ Server ready at http://localhost:4000${server.graphqlPath}`)
);