schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type File {
  base64: String!
  name: String!
  path: String!
  type: String!
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# Label characteristics and properties
type LabelCharacteristic {
  pinsLeft: Int!
  pinsPrint: Int!
  pinsRight: Int!
  widthMillimeters: Int!
}

enum MEDIA_TYPE {
  FABRIC_TAPE
  FLEXIBLE_ID_TAPE
  FLE_TAPE
  HEAT_SHRINK_TUBE
  INCOMPATIBLE_TAPE
  LAMINATED_TAPE
  NON_LAMINATED_TAPE
  NO_MEDIA
  SATIN_TAPE
}

type Mutation {
  # Send a label to be printed
  # Image Buffer / Raster data arranged as [page][column][pixels] of uint8 to the printer
  putLabelMonochromeBuffer(imageBuffer: [[[uint8]]]!): OperationResult
  uploadFiles(files: [Upload]!): [File]!
}

type OperationResult {
  result: Boolean!
}

# Printer and label status and properies
type PrinterLabelStatus {
  labelCharacteristic: LabelCharacteristic
  mediaType: MEDIA_TYPE
  mediaWidth: Int!
  tapeColor: TAPE_COLOR
  textColor: TEXT_COLOR
}

# Label characteristics and properties
type PrinterStatus {
  firmwareVersion: Float!
  heightInch: Float
  heightMillimeter: Float
  labelStatus: PrinterLabelStatus!
  labelType: String!
  model: String!
  uptime: Int!
}

type Query {
  # Retrieve Printer and Label status and properties
  PrinterStatus: PrinterStatus
  files: [File]
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

enum TAPE_COLOR {
  BERRY_PINK
  BLACK
  BLUE
  BLUE_D
  BLUE_F
  CLEANING
  CLEAR
  CLEAR_WHITE_TEXT
  FLOURESCENT_ORANGE
  FLOURESCENT_YELLOW
  GREEN
  INCOMPATIBLE
  LIGHT_GRAY
  LIME_GREEN
  MATTE_CLEAR
  MATTE_SILVER
  MATTE_WHITE
  OTHER
  PINK_F
  RED
  RED_D
  SATIN_GOLD
  SATIN_SILVER
  STENCIL
  WHITE
  WHITE_FLEX
  WHITE_HSE
  YELLOW
  YELLOW_F
  YELLOW_FLEX
}

enum TEXT_COLOR {
  BLACK
  BLUE
  BLUE_F
  CLEANING
  GOLD
  INCOMPATIBLE
  OTHER
  RED
  STENCIL
  WHITE
}

scalar Upload

scalar bigint

# expression to compare columns of type bigint. All fields are combined with logical 'AND'.
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

scalar date

# expression to compare columns of type date. All fields are combined with logical 'AND'.
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

# columns and relationships of "enum_item_cable.connector"
type enum_item_cable_connector {
  description: String
  id: String!
}

# aggregated selection of "enum_item_cable.connector"
type enum_item_cable_connector_aggregate {
  aggregate: enum_item_cable_connector_aggregate_fields
  nodes: [enum_item_cable_connector!]!
}

# aggregate fields of "enum_item_cable.connector"
type enum_item_cable_connector_aggregate_fields {
  count(columns: [enum_item_cable_connector_select_column!], distinct: Boolean): Int
  max: enum_item_cable_connector_max_fields
  min: enum_item_cable_connector_min_fields
}

# order by aggregate values of table "enum_item_cable.connector"
input enum_item_cable_connector_aggregate_order_by {
  count: order_by
  max: enum_item_cable_connector_max_order_by
  min: enum_item_cable_connector_min_order_by
}

# input type for inserting array relation for remote table "enum_item_cable.connector"
input enum_item_cable_connector_arr_rel_insert_input {
  data: [enum_item_cable_connector_insert_input!]!
  on_conflict: enum_item_cable_connector_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_cable.connector". All fields are combined with a logical 'AND'.
input enum_item_cable_connector_bool_exp {
  _and: [enum_item_cable_connector_bool_exp]
  _not: enum_item_cable_connector_bool_exp
  _or: [enum_item_cable_connector_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_cable.connector"
enum enum_item_cable_connector_constraint {
  # unique or primary key constraint
  connector_pkey
}

# input type for inserting data into table "enum_item_cable.connector"
input enum_item_cable_connector_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_cable_connector_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_cable.connector"
input enum_item_cable_connector_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_cable_connector_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_cable.connector"
input enum_item_cable_connector_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_cable.connector"
type enum_item_cable_connector_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_cable_connector!]!
}

# input type for inserting object relation for remote table "enum_item_cable.connector"
input enum_item_cable_connector_obj_rel_insert_input {
  data: enum_item_cable_connector_insert_input!
  on_conflict: enum_item_cable_connector_on_conflict
}

# on conflict condition type for table "enum_item_cable.connector"
input enum_item_cable_connector_on_conflict {
  constraint: enum_item_cable_connector_constraint!
  update_columns: [enum_item_cable_connector_update_column!]!
  where: enum_item_cable_connector_bool_exp
}

# ordering options when selecting data from "enum_item_cable.connector"
input enum_item_cable_connector_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_cable.connector"
input enum_item_cable_connector_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_cable.connector"
enum enum_item_cable_connector_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_cable.connector"
input enum_item_cable_connector_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_cable.connector"
enum enum_item_cable_connector_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum.item_class"
type enum_item_class {
  description: String
  id: String!
}

# aggregated selection of "enum.item_class"
type enum_item_class_aggregate {
  aggregate: enum_item_class_aggregate_fields
  nodes: [enum_item_class!]!
}

# aggregate fields of "enum.item_class"
type enum_item_class_aggregate_fields {
  count(columns: [enum_item_class_select_column!], distinct: Boolean): Int
  max: enum_item_class_max_fields
  min: enum_item_class_min_fields
}

# order by aggregate values of table "enum.item_class"
input enum_item_class_aggregate_order_by {
  count: order_by
  max: enum_item_class_max_order_by
  min: enum_item_class_min_order_by
}

# input type for inserting array relation for remote table "enum.item_class"
input enum_item_class_arr_rel_insert_input {
  data: [enum_item_class_insert_input!]!
  on_conflict: enum_item_class_on_conflict
}

# Boolean expression to filter rows from the table "enum.item_class". All fields are combined with a logical 'AND'.
input enum_item_class_bool_exp {
  _and: [enum_item_class_bool_exp]
  _not: enum_item_class_bool_exp
  _or: [enum_item_class_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum.item_class"
enum enum_item_class_constraint {
  # unique or primary key constraint
  icon_category_id_key

  # unique or primary key constraint
  icon_category_pkey
}

enum enum_item_class_enum {
  #
  item_bundle
  item_hardware_fastener_nut
  item_hardware_fastener_screw
  item_hardware_fastener_screw_machine
  item_hardware_fastener_standoff

  # Washers
  item_hardware_fastener_washer
}

# expression to compare columns of type enum_item_class_enum. All fields are combined with logical 'AND'.
input enum_item_class_enum_comparison_exp {
  _eq: enum_item_class_enum
  _in: [enum_item_class_enum!]
  _is_null: Boolean
  _neq: enum_item_class_enum
  _nin: [enum_item_class_enum!]
}

# input type for inserting data into table "enum.item_class"
input enum_item_class_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_class_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum.item_class"
input enum_item_class_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_class_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum.item_class"
input enum_item_class_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum.item_class"
type enum_item_class_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_class!]!
}

# input type for inserting object relation for remote table "enum.item_class"
input enum_item_class_obj_rel_insert_input {
  data: enum_item_class_insert_input!
  on_conflict: enum_item_class_on_conflict
}

# on conflict condition type for table "enum.item_class"
input enum_item_class_on_conflict {
  constraint: enum_item_class_constraint!
  update_columns: [enum_item_class_update_column!]!
  where: enum_item_class_bool_exp
}

# ordering options when selecting data from "enum.item_class"
input enum_item_class_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum.item_class"
input enum_item_class_pk_columns_input {
  id: String!
}

# select columns of table "enum.item_class"
enum enum_item_class_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum.item_class"
input enum_item_class_set_input {
  description: String
  id: String
}

# update columns of table "enum.item_class"
enum enum_item_class_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item.handedness"
type enum_item_handedness {
  description: String
  id: String!
}

# aggregated selection of "enum_item.handedness"
type enum_item_handedness_aggregate {
  aggregate: enum_item_handedness_aggregate_fields
  nodes: [enum_item_handedness!]!
}

# aggregate fields of "enum_item.handedness"
type enum_item_handedness_aggregate_fields {
  count(columns: [enum_item_handedness_select_column!], distinct: Boolean): Int
  max: enum_item_handedness_max_fields
  min: enum_item_handedness_min_fields
}

# order by aggregate values of table "enum_item.handedness"
input enum_item_handedness_aggregate_order_by {
  count: order_by
  max: enum_item_handedness_max_order_by
  min: enum_item_handedness_min_order_by
}

# input type for inserting array relation for remote table "enum_item.handedness"
input enum_item_handedness_arr_rel_insert_input {
  data: [enum_item_handedness_insert_input!]!
  on_conflict: enum_item_handedness_on_conflict
}

# Boolean expression to filter rows from the table "enum_item.handedness". All fields are combined with a logical 'AND'.
input enum_item_handedness_bool_exp {
  _and: [enum_item_handedness_bool_exp]
  _not: enum_item_handedness_bool_exp
  _or: [enum_item_handedness_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item.handedness"
enum enum_item_handedness_constraint {
  # unique or primary key constraint
  hardware_fastener_thread_direction_pkey
}

enum enum_item_handedness_enum {
  # Specialty direction of threading
  left

  # Typical direction of threading
  right
}

# expression to compare columns of type enum_item_handedness_enum. All fields are combined with logical 'AND'.
input enum_item_handedness_enum_comparison_exp {
  _eq: enum_item_handedness_enum
  _in: [enum_item_handedness_enum!]
  _is_null: Boolean
  _neq: enum_item_handedness_enum
  _nin: [enum_item_handedness_enum!]
}

# input type for inserting data into table "enum_item.handedness"
input enum_item_handedness_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_handedness_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item.handedness"
input enum_item_handedness_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_handedness_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item.handedness"
input enum_item_handedness_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item.handedness"
type enum_item_handedness_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_handedness!]!
}

# input type for inserting object relation for remote table "enum_item.handedness"
input enum_item_handedness_obj_rel_insert_input {
  data: enum_item_handedness_insert_input!
  on_conflict: enum_item_handedness_on_conflict
}

# on conflict condition type for table "enum_item.handedness"
input enum_item_handedness_on_conflict {
  constraint: enum_item_handedness_constraint!
  update_columns: [enum_item_handedness_update_column!]!
  where: enum_item_handedness_bool_exp
}

# ordering options when selecting data from "enum_item.handedness"
input enum_item_handedness_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item.handedness"
input enum_item_handedness_pk_columns_input {
  id: String!
}

# select columns of table "enum_item.handedness"
enum enum_item_handedness_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item.handedness"
input enum_item_handedness_set_input {
  description: String
  id: String
}

# update columns of table "enum_item.handedness"
enum enum_item_handedness_update_column {
  # column name
  description

  # column name
  id
}

# Drive type for fastener, such as Hex, Torx, Phillips, etc
#
#
# columns and relationships of "enum_item_hardware_fastener.drive"
type enum_item_hardware_fastener_drive {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener.drive"
type enum_item_hardware_fastener_drive_aggregate {
  aggregate: enum_item_hardware_fastener_drive_aggregate_fields
  nodes: [enum_item_hardware_fastener_drive!]!
}

# aggregate fields of "enum_item_hardware_fastener.drive"
type enum_item_hardware_fastener_drive_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_drive_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_drive_max_fields
  min: enum_item_hardware_fastener_drive_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_drive_max_order_by
  min: enum_item_hardware_fastener_drive_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_drive_insert_input!]!
  on_conflict: enum_item_hardware_fastener_drive_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener.drive". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_drive_bool_exp {
  _and: [enum_item_hardware_fastener_drive_bool_exp]
  _not: enum_item_hardware_fastener_drive_bool_exp
  _or: [enum_item_hardware_fastener_drive_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener.drive"
enum enum_item_hardware_fastener_drive_constraint {
  # unique or primary key constraint
  hardware_fastener_drive_pkey
}

enum enum_item_hardware_fastener_drive_enum {
  # Turn screws that have the tamper-resistant asymmetrical drive exclusive to McMaster-Carr. Also known as insert bits, use these in hand drivers or with a bit adapter in power tools.
  asymmetrical

  # There are two types of clutch screw drives: Type A and Type G. Type A, also known as a "standard clutch", resembles a bow tie, with a small circular "knot" at the center. These were common in GM automobiles, trucks and buses of the 1940s and 1950s. Type G resembles a butterfly, and lacks the center "knot". This type of screw head is commonly used in the manufacture of mobile homes and recreational vehicles.[53] The clutch head was designed to be driven with a flat-blade screwdriver as well as a clutch driver.
  clutch

  # two dots equidistant and opposite each other from center
  drilled_spanner

  # Similar to Phillips, but less prove to cam-out. Has the notable advantage of working even without the correct drive size.
  frearson

  # external hex (use of crescent wrench)
  hex

  # An external hex head with a slot.
  hex_slot

  # internal hex ( allen wrench )
  hex_socket

  # hex with center point preventing normal allen wrench tools from operating
  hex_tamper_resistant

  # No drive present
  none

  # Installs with a normal slotted driver but can not be removed without special tools
  one_way

  # For tamper resistance it is designed to be intrinsically incompatible with many tools. Since five is an odd number, it cannot be turned by open-end or adjustable wrenches, which have parallel faces (and thus require a fastener with an even number of sides). 
  pentagon

  # X shaped drive. Abbreviated PH
  phillips

  # combination drive that has both Phillips and Slot drives
  phillips_slot

  # Similar to Phillips, but less prove to cam-out
  pozidriv

  # Aka: Regular, Flathead. Abbreviated SL
  slot

  # aka Robertson Square Drive. Abbreviated SQ or SD
  square

  # Torq-set is a cruciform screw drive used in torque-sensitive applications. The Torq-set head is similar in appearance to a Phillips drive in that it has a cross with 4 arms. In Torq-set however, the lines are offset from each other, so they do not align to form intersecting slots across the top of the head. Because of this, a regular Phillips or flat-blade screwdriver will not fit the head. It is used in military and aerospace applications.  https://en.wikipedia.org/wiki/List_of_screw_drives#Torq-set
  torq_set

  # aka star, 6-pointed star
  torx

  # Torx Plus is an improved version of Torx that extends tool life even further and permits greater torque transfer compared to Torx
  torx_plus

  # torx with center point preventing normal torx wrench tools from operating
  torx_tamper_resistant

  # Security Socket with three teeth
  tri_groove

  # Sometimes called a triangular slotted screw. It is used as a tamper-resistant screw on various products, typically electronics.
  tri_wing

  # The additional points make these sockets easier to connect with the heads of fasteners. This is ideal if you are trying to work on a fastener that is hard to see or you cannot see at all. 12 point sockets are also great for use in tight spaces as they allow you to connect to a fastener at more angles.
  twelve_point
}

# expression to compare columns of type enum_item_hardware_fastener_drive_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_drive_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_drive_enum
  _in: [enum_item_hardware_fastener_drive_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_drive_enum
  _nin: [enum_item_hardware_fastener_drive_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_drive_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_drive_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener.drive"
type enum_item_hardware_fastener_drive_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_drive!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_obj_rel_insert_input {
  data: enum_item_hardware_fastener_drive_insert_input!
  on_conflict: enum_item_hardware_fastener_drive_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_on_conflict {
  constraint: enum_item_hardware_fastener_drive_constraint!
  update_columns: [enum_item_hardware_fastener_drive_update_column!]!
  where: enum_item_hardware_fastener_drive_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener.drive"
enum enum_item_hardware_fastener_drive_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener.drive"
input enum_item_hardware_fastener_drive_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener.drive"
enum enum_item_hardware_fastener_drive_update_column {
  # column name
  description

  # column name
  id
}

# Relevant Information:
# - https://www.sppusa.com/stainlesssteel_overview.php
# - https://www.boltdepot.com/fastener-information/Materials-and-Grades/Materials.aspx
#
#
# columns and relationships of "enum_item_hardware_fastener.material"
type enum_item_hardware_fastener_material {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener.material"
type enum_item_hardware_fastener_material_aggregate {
  aggregate: enum_item_hardware_fastener_material_aggregate_fields
  nodes: [enum_item_hardware_fastener_material!]!
}

# aggregate fields of "enum_item_hardware_fastener.material"
type enum_item_hardware_fastener_material_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_material_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_material_max_fields
  min: enum_item_hardware_fastener_material_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_material_max_order_by
  min: enum_item_hardware_fastener_material_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_material_insert_input!]!
  on_conflict: enum_item_hardware_fastener_material_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener.material". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_material_bool_exp {
  _and: [enum_item_hardware_fastener_material_bool_exp]
  _not: enum_item_hardware_fastener_material_bool_exp
  _or: [enum_item_hardware_fastener_material_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener.material"
enum enum_item_hardware_fastener_material_constraint {
  # unique or primary key constraint
  hardware_fastener_material_pkey
}

enum enum_item_hardware_fastener_material_enum {
  # Highly hardened and usually coated with Black Oxide and/or Oil which offer little corrosion resistance.
  alloy_steel

  # Aluminum is a light, soft, corrosion resistant metal. Like stainless steel, aluminum's corrosion resistance is inherent to the material. Therefore, scratches and nicks will not effect the corrosion resistance.
  aluminum

  # Brass is an alloy of primarily copper and zinc. Brass is highly corrosion resistant and electrically conductive. However, its use as a fastener is somewhat limited due to its relative softness. It is used primarily for its appearance.
  brass
  plastic

  # Often referred to as simply 'bronze'
  silicon_bronze

  # Stainless Steel of Unknown Property
  stainless_steel

  # 18-8 refers to any stainless steel containing approximately 18% chromium and 8% nickel. This is the most common stainless designation for hardware. 
  stainless_steel_18_8

  # Type 304 Stainless Steel
  stainless_steel_304

  # A highly corrosion resistant grade of stainless steel. Ideal in salt water and chlorine environments. More expensive than 18-8.
  stainless_steel_316

  # A stainless alloy that is harder than 18-8 stainless steel, but not as resistant to corrosion.
  stainless_steel_410

  # Steel is the most common fastener material. Steel fasteners are available plain as well as with various surface treatments such as zinc plating, galvanization, and chrome plating. See Strengths. (Grades and Classes)
  steel
  titanium
}

# expression to compare columns of type enum_item_hardware_fastener_material_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_material_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_material_enum
  _in: [enum_item_hardware_fastener_material_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_material_enum
  _nin: [enum_item_hardware_fastener_material_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_material_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_material_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener.material"
type enum_item_hardware_fastener_material_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_material!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_obj_rel_insert_input {
  data: enum_item_hardware_fastener_material_insert_input!
  on_conflict: enum_item_hardware_fastener_material_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_on_conflict {
  constraint: enum_item_hardware_fastener_material_constraint!
  update_columns: [enum_item_hardware_fastener_material_update_column!]!
  where: enum_item_hardware_fastener_material_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener.material"
enum enum_item_hardware_fastener_material_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener.material"
input enum_item_hardware_fastener_material_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener.material"
enum enum_item_hardware_fastener_material_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener_nut.form"
type enum_item_hardware_fastener_nut_form {
  description: String!
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_nut.form"
type enum_item_hardware_fastener_nut_form_aggregate {
  aggregate: enum_item_hardware_fastener_nut_form_aggregate_fields
  nodes: [enum_item_hardware_fastener_nut_form!]!
}

# aggregate fields of "enum_item_hardware_fastener_nut.form"
type enum_item_hardware_fastener_nut_form_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_nut_form_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_nut_form_max_fields
  min: enum_item_hardware_fastener_nut_form_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_nut_form_max_order_by
  min: enum_item_hardware_fastener_nut_form_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_nut_form_insert_input!]!
  on_conflict: enum_item_hardware_fastener_nut_form_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_nut.form". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_nut_form_bool_exp {
  _and: [enum_item_hardware_fastener_nut_form_bool_exp]
  _not: enum_item_hardware_fastener_nut_form_bool_exp
  _or: [enum_item_hardware_fastener_nut_form_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_nut.form"
enum enum_item_hardware_fastener_nut_form_constraint {
  # unique or primary key constraint
  hardware_fastener_nut_form_pkey
}

enum enum_item_hardware_fastener_nut_form_enum {
  # Acorn nuts are a high crown type of cap nut, used for appearance.
  acorn

  # A nut with a domed top over the end of the fastener.
  cap

  # Castle nuts are similar to slotted nuts but with the slots in a rounded section above the main nut.
  castle

  # A six sided nut. Also referred to as a finished hex nut.
  hex

  # A hex nut with a built in washer like flange.
  hex_flange

  # A hex nut with a nylon insert to prevent backing off. Also referred to as a Nylock
  hex_nylon_lock

  # A hex nut with a reduced height.
  jam

  # A nylock nut with a reduced height.
  jam_nylon_lock

  # A nut with an attached free-spinning external tooth lockwasher. aka Kep
  k_lock

  # A nut that does not require a high installation torque and can be installed and removed without thread damage.
  pin_lock

  # A non-reversible lock nut used for high temperature applications
  prevailing_torque_lock

  # Slotted nuts are used in conjunction with a cotter pin on drilled shank fasteners to prevent loosening.
  slotted

  # A four sided nut.
  square

  # A nut designed to be driven into wood to create a threaded hole.
  tee

  # A nut with 'wings' for hand tightening.
  wing
}

# expression to compare columns of type enum_item_hardware_fastener_nut_form_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_nut_form_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_nut_form_enum
  _in: [enum_item_hardware_fastener_nut_form_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_nut_form_enum
  _nin: [enum_item_hardware_fastener_nut_form_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_nut_form_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_nut_form_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_nut.form"
type enum_item_hardware_fastener_nut_form_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_nut_form!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_obj_rel_insert_input {
  data: enum_item_hardware_fastener_nut_form_insert_input!
  on_conflict: enum_item_hardware_fastener_nut_form_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_on_conflict {
  constraint: enum_item_hardware_fastener_nut_form_constraint!
  update_columns: [enum_item_hardware_fastener_nut_form_update_column!]!
  where: enum_item_hardware_fastener_nut_form_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_nut.form"
enum enum_item_hardware_fastener_nut_form_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_nut.form"
input enum_item_hardware_fastener_nut_form_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_nut.form"
enum enum_item_hardware_fastener_nut_form_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener_nut.strength"
type enum_item_hardware_fastener_nut_strength {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_nut.strength"
type enum_item_hardware_fastener_nut_strength_aggregate {
  aggregate: enum_item_hardware_fastener_nut_strength_aggregate_fields
  nodes: [enum_item_hardware_fastener_nut_strength!]!
}

# aggregate fields of "enum_item_hardware_fastener_nut.strength"
type enum_item_hardware_fastener_nut_strength_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_nut_strength_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_nut_strength_max_fields
  min: enum_item_hardware_fastener_nut_strength_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_nut_strength_max_order_by
  min: enum_item_hardware_fastener_nut_strength_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_nut_strength_insert_input!]!
  on_conflict: enum_item_hardware_fastener_nut_strength_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_nut.strength". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_nut_strength_bool_exp {
  _and: [enum_item_hardware_fastener_nut_strength_bool_exp]
  _not: enum_item_hardware_fastener_nut_strength_bool_exp
  _or: [enum_item_hardware_fastener_nut_strength_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_nut.strength"
enum enum_item_hardware_fastener_nut_strength_constraint {
  # unique or primary key constraint
  hardware_fastener_nut_strength_pkey
}

enum enum_item_hardware_fastener_nut_strength_enum {
  # usc. Grade F is roughly equivalent to Grade 5. Grade F nuts are used with Grade 5 bolts.
  grade_f

  # usc. Grade G is roughly equivalent to Grade 8. Grade G nuts are used with Grade 8 bolts.
  grade_g
}

# expression to compare columns of type enum_item_hardware_fastener_nut_strength_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_nut_strength_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_nut_strength_enum
  _in: [enum_item_hardware_fastener_nut_strength_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_nut_strength_enum
  _nin: [enum_item_hardware_fastener_nut_strength_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_nut_strength_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_nut_strength_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_nut.strength"
type enum_item_hardware_fastener_nut_strength_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_nut_strength!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_obj_rel_insert_input {
  data: enum_item_hardware_fastener_nut_strength_insert_input!
  on_conflict: enum_item_hardware_fastener_nut_strength_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_on_conflict {
  constraint: enum_item_hardware_fastener_nut_strength_constraint!
  update_columns: [enum_item_hardware_fastener_nut_strength_update_column!]!
  where: enum_item_hardware_fastener_nut_strength_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_nut.strength"
enum enum_item_hardware_fastener_nut_strength_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_nut.strength"
input enum_item_hardware_fastener_nut_strength_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_nut.strength"
enum enum_item_hardware_fastener_nut_strength_update_column {
  # column name
  description

  # column name
  id
}

# metric internal (nut) thread fits are defined by capital G or H ; UTS internal (nut) threads are specified by a appended B
#
#
# columns and relationships of "enum_item_hardware_fastener_nut.thread_fit"
type enum_item_hardware_fastener_nut_thread_fit {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_nut.thread_fit"
type enum_item_hardware_fastener_nut_thread_fit_aggregate {
  aggregate: enum_item_hardware_fastener_nut_thread_fit_aggregate_fields
  nodes: [enum_item_hardware_fastener_nut_thread_fit!]!
}

# aggregate fields of "enum_item_hardware_fastener_nut.thread_fit"
type enum_item_hardware_fastener_nut_thread_fit_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_nut_thread_fit_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_nut_thread_fit_max_fields
  min: enum_item_hardware_fastener_nut_thread_fit_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_nut_thread_fit_max_order_by
  min: enum_item_hardware_fastener_nut_thread_fit_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_nut_thread_fit_insert_input!]!
  on_conflict: enum_item_hardware_fastener_nut_thread_fit_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_nut.thread_fit". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_nut_thread_fit_bool_exp {
  _and: [enum_item_hardware_fastener_nut_thread_fit_bool_exp]
  _not: enum_item_hardware_fastener_nut_thread_fit_bool_exp
  _or: [enum_item_hardware_fastener_nut_thread_fit_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_nut.thread_fit"
enum enum_item_hardware_fastener_nut_thread_fit_constraint {
  # unique or primary key constraint
  hardware_fastener_nut_thread_fit_pkey
}

enum enum_item_hardware_fastener_nut_thread_fit_enum {
  class_1B
  class_2B
  class_3B
  class_4G6G

  # `4h6h/4H5H` is approximately equivalent to `3A/3B`
  # although `4g6g/6H` is usually used, which provides a little clearance over `3A/3B`.
  class_4H5H

  # `4h6h/4H5H` is approximately equivalent to `3A/3B`
  # although `4g6g/6H` is usually used, which provides a little clearance over `3A/3B`.
  class_6H
}

# expression to compare columns of type enum_item_hardware_fastener_nut_thread_fit_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_nut_thread_fit_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_nut_thread_fit_enum
  _in: [enum_item_hardware_fastener_nut_thread_fit_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_nut_thread_fit_enum
  _nin: [enum_item_hardware_fastener_nut_thread_fit_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_nut_thread_fit_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_nut_thread_fit_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_nut.thread_fit"
type enum_item_hardware_fastener_nut_thread_fit_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_nut_thread_fit!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_obj_rel_insert_input {
  data: enum_item_hardware_fastener_nut_thread_fit_insert_input!
  on_conflict: enum_item_hardware_fastener_nut_thread_fit_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_on_conflict {
  constraint: enum_item_hardware_fastener_nut_thread_fit_constraint!
  update_columns: [enum_item_hardware_fastener_nut_thread_fit_update_column!]!
  where: enum_item_hardware_fastener_nut_thread_fit_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_nut.thread_fit"
enum enum_item_hardware_fastener_nut_thread_fit_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_nut.thread_fit"
input enum_item_hardware_fastener_nut_thread_fit_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_nut.thread_fit"
enum enum_item_hardware_fastener_nut_thread_fit_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener_screw.hardness"
type enum_item_hardware_fastener_screw_hardness {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_screw.hardness"
type enum_item_hardware_fastener_screw_hardness_aggregate {
  aggregate: enum_item_hardware_fastener_screw_hardness_aggregate_fields
  nodes: [enum_item_hardware_fastener_screw_hardness!]!
}

# aggregate fields of "enum_item_hardware_fastener_screw.hardness"
type enum_item_hardware_fastener_screw_hardness_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_screw_hardness_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_screw_hardness_max_fields
  min: enum_item_hardware_fastener_screw_hardness_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_screw_hardness_max_order_by
  min: enum_item_hardware_fastener_screw_hardness_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_screw_hardness_insert_input!]!
  on_conflict: enum_item_hardware_fastener_screw_hardness_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_screw.hardness". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_screw_hardness_bool_exp {
  _and: [enum_item_hardware_fastener_screw_hardness_bool_exp]
  _not: enum_item_hardware_fastener_screw_hardness_bool_exp
  _or: [enum_item_hardware_fastener_screw_hardness_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_screw.hardness"
enum enum_item_hardware_fastener_screw_hardness_constraint {
  # unique or primary key constraint
  hardware_fastener_hardness_pkey
}

enum enum_item_hardware_fastener_screw_hardness_enum {
  rockwell_b50
  rockwell_b55
  rockwell_b70
  rockwell_b71
  rockwell_b80
  rockwell_b85
  rockwell_b96
  rockwell_c22
  rockwell_c24
  rockwell_c32
  rockwell_c38
  rockwell_c39
}

# expression to compare columns of type enum_item_hardware_fastener_screw_hardness_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_screw_hardness_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_screw_hardness_enum
  _in: [enum_item_hardware_fastener_screw_hardness_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_screw_hardness_enum
  _nin: [enum_item_hardware_fastener_screw_hardness_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_screw_hardness_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_screw_hardness_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_screw.hardness"
type enum_item_hardware_fastener_screw_hardness_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_screw_hardness!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_obj_rel_insert_input {
  data: enum_item_hardware_fastener_screw_hardness_insert_input!
  on_conflict: enum_item_hardware_fastener_screw_hardness_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_on_conflict {
  constraint: enum_item_hardware_fastener_screw_hardness_constraint!
  update_columns: [enum_item_hardware_fastener_screw_hardness_update_column!]!
  where: enum_item_hardware_fastener_screw_hardness_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_screw.hardness"
enum enum_item_hardware_fastener_screw_hardness_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_screw.hardness"
input enum_item_hardware_fastener_screw_hardness_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_screw.hardness"
enum enum_item_hardware_fastener_screw_hardness_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener_screw.head"
type enum_item_hardware_fastener_screw_head {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_screw.head"
type enum_item_hardware_fastener_screw_head_aggregate {
  aggregate: enum_item_hardware_fastener_screw_head_aggregate_fields
  nodes: [enum_item_hardware_fastener_screw_head!]!
}

# aggregate fields of "enum_item_hardware_fastener_screw.head"
type enum_item_hardware_fastener_screw_head_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_screw_head_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_screw_head_max_fields
  min: enum_item_hardware_fastener_screw_head_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_screw_head_max_order_by
  min: enum_item_hardware_fastener_screw_head_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_screw_head_insert_input!]!
  on_conflict: enum_item_hardware_fastener_screw_head_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_screw.head". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_screw_head_bool_exp {
  _and: [enum_item_hardware_fastener_screw_head_bool_exp]
  _not: enum_item_hardware_fastener_screw_head_bool_exp
  _or: [enum_item_hardware_fastener_screw_head_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_screw.head"
enum enum_item_hardware_fastener_screw_head_constraint {
  # unique or primary key constraint
  hardware_fastener_head_pkey
}

enum enum_item_hardware_fastener_screw_head_enum {
  # A low-profile rounded head using a socket (Allen) drive
  button

  # A small cylindrical head using a socket (Allen) drive
  cap
  carriage

  # A countersunk head with a flat top. 
  # Abbreviated FH.
  flat
  flat_undercut

  # hexagonal, same as external hex drive. 
  # Abbreviated HH or HX
  hex

  # A hex head with a built in flange.
  hex_flanged

  # A countersunk head with a rounded top. Abbreviated OH or OV
  oval

  # A slightly rounded head with short vertical sides. Abbreviated PN.
  pan

  # A domed head. Abbreviated RH
  round

  # aka grub screw. Machine screws with no head, only a socket (Allen) in the center of the shaft. Made for screwing all the way into holes.
  set
  timber

  # An extremely wide head with a rounded top
  truss
}

# expression to compare columns of type enum_item_hardware_fastener_screw_head_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_screw_head_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_screw_head_enum
  _in: [enum_item_hardware_fastener_screw_head_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_screw_head_enum
  _nin: [enum_item_hardware_fastener_screw_head_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_screw_head_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_screw_head_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_screw.head"
type enum_item_hardware_fastener_screw_head_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_screw_head!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_obj_rel_insert_input {
  data: enum_item_hardware_fastener_screw_head_insert_input!
  on_conflict: enum_item_hardware_fastener_screw_head_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_on_conflict {
  constraint: enum_item_hardware_fastener_screw_head_constraint!
  update_columns: [enum_item_hardware_fastener_screw_head_update_column!]!
  where: enum_item_hardware_fastener_screw_head_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_screw.head"
enum enum_item_hardware_fastener_screw_head_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_screw.head"
input enum_item_hardware_fastener_screw_head_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_screw.head"
enum enum_item_hardware_fastener_screw_head_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener_screw_machine.point"
type enum_item_hardware_fastener_screw_machine_point {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_screw_machine.point"
type enum_item_hardware_fastener_screw_machine_point_aggregate {
  aggregate: enum_item_hardware_fastener_screw_machine_point_aggregate_fields
  nodes: [enum_item_hardware_fastener_screw_machine_point!]!
}

# aggregate fields of "enum_item_hardware_fastener_screw_machine.point"
type enum_item_hardware_fastener_screw_machine_point_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_screw_machine_point_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_screw_machine_point_max_fields
  min: enum_item_hardware_fastener_screw_machine_point_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_screw_machine_point_max_order_by
  min: enum_item_hardware_fastener_screw_machine_point_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_screw_machine_point_insert_input!]!
  on_conflict: enum_item_hardware_fastener_screw_machine_point_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_screw_machine.point". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_screw_machine_point_bool_exp {
  _and: [enum_item_hardware_fastener_screw_machine_point_bool_exp]
  _not: enum_item_hardware_fastener_screw_machine_point_bool_exp
  _or: [enum_item_hardware_fastener_screw_machine_point_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_screw_machine.point"
enum enum_item_hardware_fastener_screw_machine_point_constraint {
  # unique or primary key constraint
  hardware_fastener_screw_point_pkey
}

enum enum_item_hardware_fastener_screw_machine_point_enum {
  extended
  flat
  nonmarring
  swivel
}

# expression to compare columns of type enum_item_hardware_fastener_screw_machine_point_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_screw_machine_point_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_screw_machine_point_enum
  _in: [enum_item_hardware_fastener_screw_machine_point_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_screw_machine_point_enum
  _nin: [enum_item_hardware_fastener_screw_machine_point_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_screw_machine_point_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_screw_machine_point_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_screw_machine.point"
type enum_item_hardware_fastener_screw_machine_point_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_screw_machine_point!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_obj_rel_insert_input {
  data: enum_item_hardware_fastener_screw_machine_point_insert_input!
  on_conflict: enum_item_hardware_fastener_screw_machine_point_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_on_conflict {
  constraint: enum_item_hardware_fastener_screw_machine_point_constraint!
  update_columns: [enum_item_hardware_fastener_screw_machine_point_update_column!]!
  where: enum_item_hardware_fastener_screw_machine_point_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_screw_machine.point"
enum enum_item_hardware_fastener_screw_machine_point_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_screw_machine.point"
input enum_item_hardware_fastener_screw_machine_point_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_screw_machine.point"
enum enum_item_hardware_fastener_screw_machine_point_update_column {
  # column name
  description

  # column name
  id
}

# Generally a higher number means a stronger, more hardened part, but also more brittle. US units use Grade and Metric uses Class
#
#
# columns and relationships of "enum_item_hardware_fastener_screw_machine.strength"
type enum_item_hardware_fastener_screw_machine_strength {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_screw_machine.strength"
type enum_item_hardware_fastener_screw_machine_strength_aggregate {
  aggregate: enum_item_hardware_fastener_screw_machine_strength_aggregate_fields
  nodes: [enum_item_hardware_fastener_screw_machine_strength!]!
}

# aggregate fields of "enum_item_hardware_fastener_screw_machine.strength"
type enum_item_hardware_fastener_screw_machine_strength_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_screw_machine_strength_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_screw_machine_strength_max_fields
  min: enum_item_hardware_fastener_screw_machine_strength_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_screw_machine_strength_max_order_by
  min: enum_item_hardware_fastener_screw_machine_strength_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_screw_machine_strength_insert_input!]!
  on_conflict: enum_item_hardware_fastener_screw_machine_strength_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_screw_machine.strength". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_screw_machine_strength_bool_exp {
  _and: [enum_item_hardware_fastener_screw_machine_strength_bool_exp]
  _not: enum_item_hardware_fastener_screw_machine_strength_bool_exp
  _or: [enum_item_hardware_fastener_screw_machine_strength_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_screw_machine.strength"
enum enum_item_hardware_fastener_screw_machine_strength_constraint {
  # unique or primary key constraint
  hardware_fastener_strength_class_pkey
}

enum enum_item_hardware_fastener_screw_machine_strength_enum {
  # metric. Stainless markings vary. Most stainless is non-magnetic. Usually stamped A-2.
  A_2_stainless

  # metric. Alloy steel, quenched and tempered.
  class_10_9

  # metric. Alloy steel, quenched and tempered
  class_12_9

  # metric. Medium carbon steel, quenched and tempered.
  class_8_8

  # usc. Low or medium carbon steel. No markings present.
  grade_2

  # usc. Medium carbon steel, quenched and tempered. Marked with 3 radial lines.
  grade_5

  # usc. Medium carbon alloy steel, quenched and tempered. Marked with 6 radial lines.
  grade_8

  # usc. Carbon or Alloy Steel with or without Boron	
  grade_A325

  # usc. Stainless markings vary. Most stainless is non-magnetic.
  stainless_18_8
}

# expression to compare columns of type enum_item_hardware_fastener_screw_machine_strength_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_screw_machine_strength_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_screw_machine_strength_enum
  _in: [enum_item_hardware_fastener_screw_machine_strength_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_screw_machine_strength_enum
  _nin: [enum_item_hardware_fastener_screw_machine_strength_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_screw_machine_strength_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_screw_machine_strength_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_screw_machine.strength"
type enum_item_hardware_fastener_screw_machine_strength_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_screw_machine_strength!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_obj_rel_insert_input {
  data: enum_item_hardware_fastener_screw_machine_strength_insert_input!
  on_conflict: enum_item_hardware_fastener_screw_machine_strength_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_on_conflict {
  constraint: enum_item_hardware_fastener_screw_machine_strength_constraint!
  update_columns: [enum_item_hardware_fastener_screw_machine_strength_update_column!]!
  where: enum_item_hardware_fastener_screw_machine_strength_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_screw_machine.strength"
enum enum_item_hardware_fastener_screw_machine_strength_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_screw_machine.strength"
input enum_item_hardware_fastener_screw_machine_strength_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_screw_machine.strength"
enum enum_item_hardware_fastener_screw_machine_strength_update_column {
  # column name
  description

  # column name
  id
}

# Thread fit is a combination of allowances and tolerances and a measure of tightness or looseness between them.
#
#
# columns and relationships of "enum_item_hardware_fastener_screw_machine.thread_fit"
type enum_item_hardware_fastener_screw_machine_thread_fit {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_screw_machine.thread_fit"
type enum_item_hardware_fastener_screw_machine_thread_fit_aggregate {
  aggregate: enum_item_hardware_fastener_screw_machine_thread_fit_aggregate_fields
  nodes: [enum_item_hardware_fastener_screw_machine_thread_fit!]!
}

# aggregate fields of "enum_item_hardware_fastener_screw_machine.thread_fit"
type enum_item_hardware_fastener_screw_machine_thread_fit_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_screw_machine_thread_fit_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_screw_machine_thread_fit_max_fields
  min: enum_item_hardware_fastener_screw_machine_thread_fit_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_screw_machine_thread_fit_max_order_by
  min: enum_item_hardware_fastener_screw_machine_thread_fit_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_screw_machine_thread_fit_insert_input!]!
  on_conflict: enum_item_hardware_fastener_screw_machine_thread_fit_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_screw_machine.thread_fit". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp {
  _and: [enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp]
  _not: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp
  _or: [enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_screw_machine.thread_fit"
enum enum_item_hardware_fastener_screw_machine_thread_fit_constraint {
  # unique or primary key constraint
  hardware_fastener_thread_fit_pkey
}

enum enum_item_hardware_fastener_screw_machine_thread_fit_enum {
  _1A
  _2A
  _3A

  # `4h6h/4H5H` is approximately equivalent to `3A/3B`
  # although `4g6g/6H` is usually used, which provides a little clearance over `3A/3B`.
  _4g6g
  _4h

  # `4h6h/4H5H` is approximately equivalent to `3A/3B`
  # although `4g6g/6H` is usually used, which provides a little clearance over `3A/3B`.
  _4h6h

  # `6g/6H` is approximately equivalent to `2A/2B`
  _6g

  # `6g/6H` is approximately equivalent to `2A/2B`
  _6h
}

# expression to compare columns of type enum_item_hardware_fastener_screw_machine_thread_fit_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_screw_machine_thread_fit_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  _in: [enum_item_hardware_fastener_screw_machine_thread_fit_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  _nin: [enum_item_hardware_fastener_screw_machine_thread_fit_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_screw_machine_thread_fit_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_screw_machine_thread_fit_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_screw_machine.thread_fit"
type enum_item_hardware_fastener_screw_machine_thread_fit_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_screw_machine_thread_fit!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_obj_rel_insert_input {
  data: enum_item_hardware_fastener_screw_machine_thread_fit_insert_input!
  on_conflict: enum_item_hardware_fastener_screw_machine_thread_fit_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_on_conflict {
  constraint: enum_item_hardware_fastener_screw_machine_thread_fit_constraint!
  update_columns: [enum_item_hardware_fastener_screw_machine_thread_fit_update_column!]!
  where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_screw_machine.thread_fit"
enum enum_item_hardware_fastener_screw_machine_thread_fit_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_screw_machine.thread_fit"
input enum_item_hardware_fastener_screw_machine_thread_fit_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_screw_machine.thread_fit"
enum enum_item_hardware_fastener_screw_machine_thread_fit_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener.standoff_shape"
type enum_item_hardware_fastener_standoff_shape {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener.standoff_shape"
type enum_item_hardware_fastener_standoff_shape_aggregate {
  aggregate: enum_item_hardware_fastener_standoff_shape_aggregate_fields
  nodes: [enum_item_hardware_fastener_standoff_shape!]!
}

# aggregate fields of "enum_item_hardware_fastener.standoff_shape"
type enum_item_hardware_fastener_standoff_shape_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_standoff_shape_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_standoff_shape_max_fields
  min: enum_item_hardware_fastener_standoff_shape_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_standoff_shape_max_order_by
  min: enum_item_hardware_fastener_standoff_shape_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_standoff_shape_insert_input!]!
  on_conflict: enum_item_hardware_fastener_standoff_shape_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener.standoff_shape". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_standoff_shape_bool_exp {
  _and: [enum_item_hardware_fastener_standoff_shape_bool_exp]
  _not: enum_item_hardware_fastener_standoff_shape_bool_exp
  _or: [enum_item_hardware_fastener_standoff_shape_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener.standoff_shape"
enum enum_item_hardware_fastener_standoff_shape_constraint {
  # unique or primary key constraint
  hardware_fastener_standoff_shape_pkey
}

enum enum_item_hardware_fastener_standoff_shape_enum {
  hex
  round
  square
  triangle
}

# expression to compare columns of type enum_item_hardware_fastener_standoff_shape_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_standoff_shape_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_standoff_shape_enum
  _in: [enum_item_hardware_fastener_standoff_shape_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_standoff_shape_enum
  _nin: [enum_item_hardware_fastener_standoff_shape_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_standoff_shape_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_standoff_shape_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener.standoff_shape"
type enum_item_hardware_fastener_standoff_shape_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_standoff_shape!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_obj_rel_insert_input {
  data: enum_item_hardware_fastener_standoff_shape_insert_input!
  on_conflict: enum_item_hardware_fastener_standoff_shape_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_on_conflict {
  constraint: enum_item_hardware_fastener_standoff_shape_constraint!
  update_columns: [enum_item_hardware_fastener_standoff_shape_update_column!]!
  where: enum_item_hardware_fastener_standoff_shape_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener.standoff_shape"
enum enum_item_hardware_fastener_standoff_shape_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener.standoff_shape"
input enum_item_hardware_fastener_standoff_shape_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener.standoff_shape"
enum enum_item_hardware_fastener_standoff_shape_update_column {
  # column name
  description

  # column name
  id
}

# descriptor of thread
#
#
# columns and relationships of "enum_item_hardware_fastener.thread_label"
type enum_item_hardware_fastener_thread_label {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener.thread_label"
type enum_item_hardware_fastener_thread_label_aggregate {
  aggregate: enum_item_hardware_fastener_thread_label_aggregate_fields
  nodes: [enum_item_hardware_fastener_thread_label!]!
}

# aggregate fields of "enum_item_hardware_fastener.thread_label"
type enum_item_hardware_fastener_thread_label_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_thread_label_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_thread_label_max_fields
  min: enum_item_hardware_fastener_thread_label_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_thread_label_max_order_by
  min: enum_item_hardware_fastener_thread_label_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_thread_label_insert_input!]!
  on_conflict: enum_item_hardware_fastener_thread_label_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener.thread_label". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_thread_label_bool_exp {
  _and: [enum_item_hardware_fastener_thread_label_bool_exp]
  _not: enum_item_hardware_fastener_thread_label_bool_exp
  _or: [enum_item_hardware_fastener_thread_label_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener.thread_label"
enum enum_item_hardware_fastener_thread_label_constraint {
  # unique or primary key constraint
  hardware_fastener_thread_type_pkey
}

enum enum_item_hardware_fastener_thread_label_enum {
  # coarse is the default
  coarse
  extra_fine
  fine
}

# expression to compare columns of type enum_item_hardware_fastener_thread_label_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_thread_label_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_thread_label_enum
  _in: [enum_item_hardware_fastener_thread_label_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_thread_label_enum
  _nin: [enum_item_hardware_fastener_thread_label_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_thread_label_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_thread_label_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener.thread_label"
type enum_item_hardware_fastener_thread_label_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_thread_label!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_obj_rel_insert_input {
  data: enum_item_hardware_fastener_thread_label_insert_input!
  on_conflict: enum_item_hardware_fastener_thread_label_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_on_conflict {
  constraint: enum_item_hardware_fastener_thread_label_constraint!
  update_columns: [enum_item_hardware_fastener_thread_label_update_column!]!
  where: enum_item_hardware_fastener_thread_label_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener.thread_label"
enum enum_item_hardware_fastener_thread_label_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener.thread_label"
input enum_item_hardware_fastener_thread_label_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener.thread_label"
enum enum_item_hardware_fastener_thread_label_update_column {
  # column name
  description

  # column name
  id
}

# For more information on thread standards see https://en.wikipedia.org/wiki/Screw_thread#Standardization
#
#
# columns and relationships of "enum_item_hardware_fastener.thread_standard"
type enum_item_hardware_fastener_thread_standard {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener.thread_standard"
type enum_item_hardware_fastener_thread_standard_aggregate {
  aggregate: enum_item_hardware_fastener_thread_standard_aggregate_fields
  nodes: [enum_item_hardware_fastener_thread_standard!]!
}

# aggregate fields of "enum_item_hardware_fastener.thread_standard"
type enum_item_hardware_fastener_thread_standard_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_thread_standard_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_thread_standard_max_fields
  min: enum_item_hardware_fastener_thread_standard_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_thread_standard_max_order_by
  min: enum_item_hardware_fastener_thread_standard_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_thread_standard_insert_input!]!
  on_conflict: enum_item_hardware_fastener_thread_standard_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener.thread_standard". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_thread_standard_bool_exp {
  _and: [enum_item_hardware_fastener_thread_standard_bool_exp]
  _not: enum_item_hardware_fastener_thread_standard_bool_exp
  _or: [enum_item_hardware_fastener_thread_standard_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener.thread_standard"
enum enum_item_hardware_fastener_thread_standard_constraint {
  # unique or primary key constraint
  hardware_fastener_thread_standard_pkey
}

enum enum_item_hardware_fastener_thread_standard_enum {
  # German ISO member, Deutsches Institut für Normung
  DIN

  # International Standards Organization. Default metric unit.
  ISO

  # Unified National Coarse, part of Unified Thread Standard (UTS)
  UNC

  # Unified National Extra Fine, part of Unified Thread Standard (UTS)
  UNEF

  # Unified National Fine, part of Unified Thread Standard (UTS)
  UNF

  # Unified National Special, part of Unified Thread Standard (UTS)
  UNS
}

# expression to compare columns of type enum_item_hardware_fastener_thread_standard_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_thread_standard_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_thread_standard_enum
  _in: [enum_item_hardware_fastener_thread_standard_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_thread_standard_enum
  _nin: [enum_item_hardware_fastener_thread_standard_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_thread_standard_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_thread_standard_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener.thread_standard"
type enum_item_hardware_fastener_thread_standard_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_thread_standard!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_obj_rel_insert_input {
  data: enum_item_hardware_fastener_thread_standard_insert_input!
  on_conflict: enum_item_hardware_fastener_thread_standard_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_on_conflict {
  constraint: enum_item_hardware_fastener_thread_standard_constraint!
  update_columns: [enum_item_hardware_fastener_thread_standard_update_column!]!
  where: enum_item_hardware_fastener_thread_standard_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener.thread_standard"
enum enum_item_hardware_fastener_thread_standard_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener.thread_standard"
input enum_item_hardware_fastener_thread_standard_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener.thread_standard"
enum enum_item_hardware_fastener_thread_standard_update_column {
  # column name
  description

  # column name
  id
}

# Shape of the washer
#
#
# columns and relationships of "enum_item_hardware_fastener_washer.form"
type enum_item_hardware_fastener_washer_form {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_washer.form"
type enum_item_hardware_fastener_washer_form_aggregate {
  aggregate: enum_item_hardware_fastener_washer_form_aggregate_fields
  nodes: [enum_item_hardware_fastener_washer_form!]!
}

# aggregate fields of "enum_item_hardware_fastener_washer.form"
type enum_item_hardware_fastener_washer_form_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_washer_form_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_washer_form_max_fields
  min: enum_item_hardware_fastener_washer_form_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_washer_form_max_order_by
  min: enum_item_hardware_fastener_washer_form_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_washer_form_insert_input!]!
  on_conflict: enum_item_hardware_fastener_washer_form_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_washer.form". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_washer_form_bool_exp {
  _and: [enum_item_hardware_fastener_washer_form_bool_exp]
  _not: enum_item_hardware_fastener_washer_form_bool_exp
  _or: [enum_item_hardware_fastener_washer_form_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_washer.form"
enum enum_item_hardware_fastener_washer_form_constraint {
  # unique or primary key constraint
  hardware_fastener_washer_form_pkey
}

enum enum_item_hardware_fastener_washer_form_enum {
  # A washer used to obtain a finished look. Usually used with rounded head fasteners.
  finishing

  # Used to distribute load. see also: pattern
  flat

  # Used to prevent nuts and bolts from backing out. see also: lock_mechanism.
  lock

  # Thick, large diameter, cast iron washers with a curved or sculpted appearance. Typically used in dock and wood construction.
  ogee

  # A neoprene washer bonded to a metal backing. Used to seal out air/water or dampen noise and vibration.
  sealing
  square
}

# expression to compare columns of type enum_item_hardware_fastener_washer_form_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_washer_form_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_washer_form_enum
  _in: [enum_item_hardware_fastener_washer_form_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_washer_form_enum
  _nin: [enum_item_hardware_fastener_washer_form_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_washer_form_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_washer_form_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_washer.form"
type enum_item_hardware_fastener_washer_form_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_washer_form!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_obj_rel_insert_input {
  data: enum_item_hardware_fastener_washer_form_insert_input!
  on_conflict: enum_item_hardware_fastener_washer_form_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_on_conflict {
  constraint: enum_item_hardware_fastener_washer_form_constraint!
  update_columns: [enum_item_hardware_fastener_washer_form_update_column!]!
  where: enum_item_hardware_fastener_washer_form_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_washer.form"
enum enum_item_hardware_fastener_washer_form_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_washer.form"
input enum_item_hardware_fastener_washer_form_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_washer.form"
enum enum_item_hardware_fastener_washer_form_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_hardware_fastener_washer.mechanism"
type enum_item_hardware_fastener_washer_mechanism {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_washer.mechanism"
type enum_item_hardware_fastener_washer_mechanism_aggregate {
  aggregate: enum_item_hardware_fastener_washer_mechanism_aggregate_fields
  nodes: [enum_item_hardware_fastener_washer_mechanism!]!
}

# aggregate fields of "enum_item_hardware_fastener_washer.mechanism"
type enum_item_hardware_fastener_washer_mechanism_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_washer_mechanism_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_washer_mechanism_max_fields
  min: enum_item_hardware_fastener_washer_mechanism_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_washer_mechanism_max_order_by
  min: enum_item_hardware_fastener_washer_mechanism_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_washer_mechanism_insert_input!]!
  on_conflict: enum_item_hardware_fastener_washer_mechanism_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_washer.mechanism". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_washer_mechanism_bool_exp {
  _and: [enum_item_hardware_fastener_washer_mechanism_bool_exp]
  _not: enum_item_hardware_fastener_washer_mechanism_bool_exp
  _or: [enum_item_hardware_fastener_washer_mechanism_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_washer.mechanism"
enum enum_item_hardware_fastener_washer_mechanism_constraint {
  # unique or primary key constraint
  hardware_fastener_washer_lock_mechanism_pkey
}

enum enum_item_hardware_fastener_washer_mechanism_enum {
  # washer with external teeth
  external_tooth

  # washer with internal teeth
  internal_tooth

  # the most common lock method
  split
}

# expression to compare columns of type enum_item_hardware_fastener_washer_mechanism_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_washer_mechanism_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_washer_mechanism_enum
  _in: [enum_item_hardware_fastener_washer_mechanism_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_washer_mechanism_enum
  _nin: [enum_item_hardware_fastener_washer_mechanism_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_washer_mechanism_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_washer_mechanism_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_washer.mechanism"
type enum_item_hardware_fastener_washer_mechanism_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_washer_mechanism!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_obj_rel_insert_input {
  data: enum_item_hardware_fastener_washer_mechanism_insert_input!
  on_conflict: enum_item_hardware_fastener_washer_mechanism_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_on_conflict {
  constraint: enum_item_hardware_fastener_washer_mechanism_constraint!
  update_columns: [enum_item_hardware_fastener_washer_mechanism_update_column!]!
  where: enum_item_hardware_fastener_washer_mechanism_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_washer.mechanism"
enum enum_item_hardware_fastener_washer_mechanism_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_washer.mechanism"
input enum_item_hardware_fastener_washer_mechanism_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_washer.mechanism"
enum enum_item_hardware_fastener_washer_mechanism_update_column {
  # column name
  description

  # column name
  id
}

# For Flat washers: Washer patterns define the outer diameter of the washer.
#
#
# columns and relationships of "enum_item_hardware_fastener_washer.pattern"
type enum_item_hardware_fastener_washer_pattern {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware_fastener_washer.pattern"
type enum_item_hardware_fastener_washer_pattern_aggregate {
  aggregate: enum_item_hardware_fastener_washer_pattern_aggregate_fields
  nodes: [enum_item_hardware_fastener_washer_pattern!]!
}

# aggregate fields of "enum_item_hardware_fastener_washer.pattern"
type enum_item_hardware_fastener_washer_pattern_aggregate_fields {
  count(columns: [enum_item_hardware_fastener_washer_pattern_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_fastener_washer_pattern_max_fields
  min: enum_item_hardware_fastener_washer_pattern_min_fields
}

# order by aggregate values of table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_fastener_washer_pattern_max_order_by
  min: enum_item_hardware_fastener_washer_pattern_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_arr_rel_insert_input {
  data: [enum_item_hardware_fastener_washer_pattern_insert_input!]!
  on_conflict: enum_item_hardware_fastener_washer_pattern_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware_fastener_washer.pattern". All fields are combined with a logical 'AND'.
input enum_item_hardware_fastener_washer_pattern_bool_exp {
  _and: [enum_item_hardware_fastener_washer_pattern_bool_exp]
  _not: enum_item_hardware_fastener_washer_pattern_bool_exp
  _or: [enum_item_hardware_fastener_washer_pattern_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware_fastener_washer.pattern"
enum enum_item_hardware_fastener_washer_pattern_constraint {
  # unique or primary key constraint
  hardware_fastener_washer_pattern_pkey
}

enum enum_item_hardware_fastener_washer_pattern_enum {
  # very large outer diameter
  Fender

  # narrow outer diameter
  SAE

  # wide outer diameter
  USS

  # Large outer diameter and thicker
  dock
}

# expression to compare columns of type enum_item_hardware_fastener_washer_pattern_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_fastener_washer_pattern_enum_comparison_exp {
  _eq: enum_item_hardware_fastener_washer_pattern_enum
  _in: [enum_item_hardware_fastener_washer_pattern_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_fastener_washer_pattern_enum
  _nin: [enum_item_hardware_fastener_washer_pattern_enum!]
}

# input type for inserting data into table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_fastener_washer_pattern_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_fastener_washer_pattern_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware_fastener_washer.pattern"
type enum_item_hardware_fastener_washer_pattern_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_fastener_washer_pattern!]!
}

# input type for inserting object relation for remote table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_obj_rel_insert_input {
  data: enum_item_hardware_fastener_washer_pattern_insert_input!
  on_conflict: enum_item_hardware_fastener_washer_pattern_on_conflict
}

# on conflict condition type for table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_on_conflict {
  constraint: enum_item_hardware_fastener_washer_pattern_constraint!
  update_columns: [enum_item_hardware_fastener_washer_pattern_update_column!]!
  where: enum_item_hardware_fastener_washer_pattern_bool_exp
}

# ordering options when selecting data from "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware_fastener_washer.pattern"
enum enum_item_hardware_fastener_washer_pattern_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware_fastener_washer.pattern"
input enum_item_hardware_fastener_washer_pattern_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware_fastener_washer.pattern"
enum enum_item_hardware_fastener_washer_pattern_update_column {
  # column name
  description

  # column name
  id
}

# aka coatings
#
#
# columns and relationships of "enum_item_hardware.finish"
type enum_item_hardware_finish {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware.finish"
type enum_item_hardware_finish_aggregate {
  aggregate: enum_item_hardware_finish_aggregate_fields
  nodes: [enum_item_hardware_finish!]!
}

# aggregate fields of "enum_item_hardware.finish"
type enum_item_hardware_finish_aggregate_fields {
  count(columns: [enum_item_hardware_finish_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_finish_max_fields
  min: enum_item_hardware_finish_min_fields
}

# order by aggregate values of table "enum_item_hardware.finish"
input enum_item_hardware_finish_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_finish_max_order_by
  min: enum_item_hardware_finish_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware.finish"
input enum_item_hardware_finish_arr_rel_insert_input {
  data: [enum_item_hardware_finish_insert_input!]!
  on_conflict: enum_item_hardware_finish_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware.finish". All fields are combined with a logical 'AND'.
input enum_item_hardware_finish_bool_exp {
  _and: [enum_item_hardware_finish_bool_exp]
  _not: enum_item_hardware_finish_bool_exp
  _or: [enum_item_hardware_finish_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware.finish"
enum enum_item_hardware_finish_constraint {
  # unique or primary key constraint
  hardware_finish_pkey
}

enum enum_item_hardware_finish_enum {
  # Black Oxide
  black_oxide
  blue_dyed
  cadmium_plated

  # Fasteners are chrome plated and polished for appearance. Chrome plating provides similar corrosion resistance to zinc plating.
  chrome_plated

  # Galvanizing is another coating involving the application of a layer of zinc. Hot dip galvanizing puts the thickest possible coating on the metal, resulting in superior corrosion resistance.
  # Because of the thick coating, only galvanized nuts and washers will fit. Typically a rough, dull gray.
  hot_dip_galvanized

  # Moderate corrosion resistance similar to Zinc-plated
  nickel_plated
  painted
  passivated
  ptfe_coated

  # electroplated with zinc for moderate corrosion resistance suitable for (dry) indoor use. 
  # Can be either blue or yellow tinted depending on the process.
  zinc_plated
}

# expression to compare columns of type enum_item_hardware_finish_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_finish_enum_comparison_exp {
  _eq: enum_item_hardware_finish_enum
  _in: [enum_item_hardware_finish_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_finish_enum
  _nin: [enum_item_hardware_finish_enum!]
}

# input type for inserting data into table "enum_item_hardware.finish"
input enum_item_hardware_finish_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_finish_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware.finish"
input enum_item_hardware_finish_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_finish_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware.finish"
input enum_item_hardware_finish_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware.finish"
type enum_item_hardware_finish_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_finish!]!
}

# input type for inserting object relation for remote table "enum_item_hardware.finish"
input enum_item_hardware_finish_obj_rel_insert_input {
  data: enum_item_hardware_finish_insert_input!
  on_conflict: enum_item_hardware_finish_on_conflict
}

# on conflict condition type for table "enum_item_hardware.finish"
input enum_item_hardware_finish_on_conflict {
  constraint: enum_item_hardware_finish_constraint!
  update_columns: [enum_item_hardware_finish_update_column!]!
  where: enum_item_hardware_finish_bool_exp
}

# ordering options when selecting data from "enum_item_hardware.finish"
input enum_item_hardware_finish_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware.finish"
input enum_item_hardware_finish_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware.finish"
enum enum_item_hardware_finish_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware.finish"
input enum_item_hardware_finish_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware.finish"
enum enum_item_hardware_finish_update_column {
  # column name
  description

  # column name
  id
}

# Material which the fastener is to be used in, ie. _Wood_ for _Wood Screws_
#
#
# columns and relationships of "enum_item_hardware.use_material"
type enum_item_hardware_use_material {
  description: String
  id: String!
}

# aggregated selection of "enum_item_hardware.use_material"
type enum_item_hardware_use_material_aggregate {
  aggregate: enum_item_hardware_use_material_aggregate_fields
  nodes: [enum_item_hardware_use_material!]!
}

# aggregate fields of "enum_item_hardware.use_material"
type enum_item_hardware_use_material_aggregate_fields {
  count(columns: [enum_item_hardware_use_material_select_column!], distinct: Boolean): Int
  max: enum_item_hardware_use_material_max_fields
  min: enum_item_hardware_use_material_min_fields
}

# order by aggregate values of table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_aggregate_order_by {
  count: order_by
  max: enum_item_hardware_use_material_max_order_by
  min: enum_item_hardware_use_material_min_order_by
}

# input type for inserting array relation for remote table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_arr_rel_insert_input {
  data: [enum_item_hardware_use_material_insert_input!]!
  on_conflict: enum_item_hardware_use_material_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_hardware.use_material". All fields are combined with a logical 'AND'.
input enum_item_hardware_use_material_bool_exp {
  _and: [enum_item_hardware_use_material_bool_exp]
  _not: enum_item_hardware_use_material_bool_exp
  _or: [enum_item_hardware_use_material_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_hardware.use_material"
enum enum_item_hardware_use_material_constraint {
  # unique or primary key constraint
  hardware_fastener_use_material_pkey
}

enum enum_item_hardware_use_material_enum {
  drywall

  # Pre-threaded holes, typically in metal
  machine
  plastic
  wood
}

# expression to compare columns of type enum_item_hardware_use_material_enum. All fields are combined with logical 'AND'.
input enum_item_hardware_use_material_enum_comparison_exp {
  _eq: enum_item_hardware_use_material_enum
  _in: [enum_item_hardware_use_material_enum!]
  _is_null: Boolean
  _neq: enum_item_hardware_use_material_enum
  _nin: [enum_item_hardware_use_material_enum!]
}

# input type for inserting data into table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_hardware_use_material_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_hardware_use_material_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_hardware.use_material"
type enum_item_hardware_use_material_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_hardware_use_material!]!
}

# input type for inserting object relation for remote table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_obj_rel_insert_input {
  data: enum_item_hardware_use_material_insert_input!
  on_conflict: enum_item_hardware_use_material_on_conflict
}

# on conflict condition type for table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_on_conflict {
  constraint: enum_item_hardware_use_material_constraint!
  update_columns: [enum_item_hardware_use_material_update_column!]!
  where: enum_item_hardware_use_material_bool_exp
}

# ordering options when selecting data from "enum_item_hardware.use_material"
input enum_item_hardware_use_material_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_hardware.use_material"
input enum_item_hardware_use_material_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_hardware.use_material"
enum enum_item_hardware_use_material_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_hardware.use_material"
input enum_item_hardware_use_material_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_hardware.use_material"
enum enum_item_hardware_use_material_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_tool.drill_bit_finish"
type enum_item_tool_drill_bit_finish {
  description: String
  id: String!
}

# aggregated selection of "enum_item_tool.drill_bit_finish"
type enum_item_tool_drill_bit_finish_aggregate {
  aggregate: enum_item_tool_drill_bit_finish_aggregate_fields
  nodes: [enum_item_tool_drill_bit_finish!]!
}

# aggregate fields of "enum_item_tool.drill_bit_finish"
type enum_item_tool_drill_bit_finish_aggregate_fields {
  count(columns: [enum_item_tool_drill_bit_finish_select_column!], distinct: Boolean): Int
  max: enum_item_tool_drill_bit_finish_max_fields
  min: enum_item_tool_drill_bit_finish_min_fields
}

# order by aggregate values of table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_aggregate_order_by {
  count: order_by
  max: enum_item_tool_drill_bit_finish_max_order_by
  min: enum_item_tool_drill_bit_finish_min_order_by
}

# input type for inserting array relation for remote table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_arr_rel_insert_input {
  data: [enum_item_tool_drill_bit_finish_insert_input!]!
  on_conflict: enum_item_tool_drill_bit_finish_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_tool.drill_bit_finish". All fields are combined with a logical 'AND'.
input enum_item_tool_drill_bit_finish_bool_exp {
  _and: [enum_item_tool_drill_bit_finish_bool_exp]
  _not: enum_item_tool_drill_bit_finish_bool_exp
  _or: [enum_item_tool_drill_bit_finish_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_tool.drill_bit_finish"
enum enum_item_tool_drill_bit_finish_constraint {
  # unique or primary key constraint
  drill_bit_finish_pkey
}

# input type for inserting data into table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_tool_drill_bit_finish_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_tool_drill_bit_finish_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_tool.drill_bit_finish"
type enum_item_tool_drill_bit_finish_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_tool_drill_bit_finish!]!
}

# input type for inserting object relation for remote table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_obj_rel_insert_input {
  data: enum_item_tool_drill_bit_finish_insert_input!
  on_conflict: enum_item_tool_drill_bit_finish_on_conflict
}

# on conflict condition type for table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_on_conflict {
  constraint: enum_item_tool_drill_bit_finish_constraint!
  update_columns: [enum_item_tool_drill_bit_finish_update_column!]!
  where: enum_item_tool_drill_bit_finish_bool_exp
}

# ordering options when selecting data from "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_tool.drill_bit_finish"
enum enum_item_tool_drill_bit_finish_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_tool.drill_bit_finish"
input enum_item_tool_drill_bit_finish_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_tool.drill_bit_finish"
enum enum_item_tool_drill_bit_finish_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_tool.drill_bit_length_class"
type enum_item_tool_drill_bit_length_class {
  description: String
  id: String!
}

# aggregated selection of "enum_item_tool.drill_bit_length_class"
type enum_item_tool_drill_bit_length_class_aggregate {
  aggregate: enum_item_tool_drill_bit_length_class_aggregate_fields
  nodes: [enum_item_tool_drill_bit_length_class!]!
}

# aggregate fields of "enum_item_tool.drill_bit_length_class"
type enum_item_tool_drill_bit_length_class_aggregate_fields {
  count(columns: [enum_item_tool_drill_bit_length_class_select_column!], distinct: Boolean): Int
  max: enum_item_tool_drill_bit_length_class_max_fields
  min: enum_item_tool_drill_bit_length_class_min_fields
}

# order by aggregate values of table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_aggregate_order_by {
  count: order_by
  max: enum_item_tool_drill_bit_length_class_max_order_by
  min: enum_item_tool_drill_bit_length_class_min_order_by
}

# input type for inserting array relation for remote table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_arr_rel_insert_input {
  data: [enum_item_tool_drill_bit_length_class_insert_input!]!
  on_conflict: enum_item_tool_drill_bit_length_class_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_tool.drill_bit_length_class". All fields are combined with a logical 'AND'.
input enum_item_tool_drill_bit_length_class_bool_exp {
  _and: [enum_item_tool_drill_bit_length_class_bool_exp]
  _not: enum_item_tool_drill_bit_length_class_bool_exp
  _or: [enum_item_tool_drill_bit_length_class_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_tool.drill_bit_length_class"
enum enum_item_tool_drill_bit_length_class_constraint {
  # unique or primary key constraint
  drill_bit_length_class_pkey
}

# input type for inserting data into table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_tool_drill_bit_length_class_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_tool_drill_bit_length_class_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_tool.drill_bit_length_class"
type enum_item_tool_drill_bit_length_class_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_tool_drill_bit_length_class!]!
}

# input type for inserting object relation for remote table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_obj_rel_insert_input {
  data: enum_item_tool_drill_bit_length_class_insert_input!
  on_conflict: enum_item_tool_drill_bit_length_class_on_conflict
}

# on conflict condition type for table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_on_conflict {
  constraint: enum_item_tool_drill_bit_length_class_constraint!
  update_columns: [enum_item_tool_drill_bit_length_class_update_column!]!
  where: enum_item_tool_drill_bit_length_class_bool_exp
}

# ordering options when selecting data from "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_tool.drill_bit_length_class"
enum enum_item_tool_drill_bit_length_class_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_tool.drill_bit_length_class"
input enum_item_tool_drill_bit_length_class_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_tool.drill_bit_length_class"
enum enum_item_tool_drill_bit_length_class_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_tool.drill_bit_material"
type enum_item_tool_drill_bit_material {
  description: String
  id: String!
}

# aggregated selection of "enum_item_tool.drill_bit_material"
type enum_item_tool_drill_bit_material_aggregate {
  aggregate: enum_item_tool_drill_bit_material_aggregate_fields
  nodes: [enum_item_tool_drill_bit_material!]!
}

# aggregate fields of "enum_item_tool.drill_bit_material"
type enum_item_tool_drill_bit_material_aggregate_fields {
  count(columns: [enum_item_tool_drill_bit_material_select_column!], distinct: Boolean): Int
  max: enum_item_tool_drill_bit_material_max_fields
  min: enum_item_tool_drill_bit_material_min_fields
}

# order by aggregate values of table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_aggregate_order_by {
  count: order_by
  max: enum_item_tool_drill_bit_material_max_order_by
  min: enum_item_tool_drill_bit_material_min_order_by
}

# input type for inserting array relation for remote table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_arr_rel_insert_input {
  data: [enum_item_tool_drill_bit_material_insert_input!]!
  on_conflict: enum_item_tool_drill_bit_material_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_tool.drill_bit_material". All fields are combined with a logical 'AND'.
input enum_item_tool_drill_bit_material_bool_exp {
  _and: [enum_item_tool_drill_bit_material_bool_exp]
  _not: enum_item_tool_drill_bit_material_bool_exp
  _or: [enum_item_tool_drill_bit_material_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_tool.drill_bit_material"
enum enum_item_tool_drill_bit_material_constraint {
  # unique or primary key constraint
  drill_bit_material_pkey
}

# input type for inserting data into table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_tool_drill_bit_material_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_tool_drill_bit_material_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_tool.drill_bit_material"
type enum_item_tool_drill_bit_material_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_tool_drill_bit_material!]!
}

# input type for inserting object relation for remote table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_obj_rel_insert_input {
  data: enum_item_tool_drill_bit_material_insert_input!
  on_conflict: enum_item_tool_drill_bit_material_on_conflict
}

# on conflict condition type for table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_on_conflict {
  constraint: enum_item_tool_drill_bit_material_constraint!
  update_columns: [enum_item_tool_drill_bit_material_update_column!]!
  where: enum_item_tool_drill_bit_material_bool_exp
}

# ordering options when selecting data from "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_tool.drill_bit_material"
enum enum_item_tool_drill_bit_material_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_tool.drill_bit_material"
input enum_item_tool_drill_bit_material_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_tool.drill_bit_material"
enum enum_item_tool_drill_bit_material_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_tool.drill_bit_point"
type enum_item_tool_drill_bit_point {
  description: String
  id: String!
}

# aggregated selection of "enum_item_tool.drill_bit_point"
type enum_item_tool_drill_bit_point_aggregate {
  aggregate: enum_item_tool_drill_bit_point_aggregate_fields
  nodes: [enum_item_tool_drill_bit_point!]!
}

# aggregate fields of "enum_item_tool.drill_bit_point"
type enum_item_tool_drill_bit_point_aggregate_fields {
  count(columns: [enum_item_tool_drill_bit_point_select_column!], distinct: Boolean): Int
  max: enum_item_tool_drill_bit_point_max_fields
  min: enum_item_tool_drill_bit_point_min_fields
}

# order by aggregate values of table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_aggregate_order_by {
  count: order_by
  max: enum_item_tool_drill_bit_point_max_order_by
  min: enum_item_tool_drill_bit_point_min_order_by
}

# input type for inserting array relation for remote table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_arr_rel_insert_input {
  data: [enum_item_tool_drill_bit_point_insert_input!]!
  on_conflict: enum_item_tool_drill_bit_point_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_tool.drill_bit_point". All fields are combined with a logical 'AND'.
input enum_item_tool_drill_bit_point_bool_exp {
  _and: [enum_item_tool_drill_bit_point_bool_exp]
  _not: enum_item_tool_drill_bit_point_bool_exp
  _or: [enum_item_tool_drill_bit_point_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_tool.drill_bit_point"
enum enum_item_tool_drill_bit_point_constraint {
  # unique or primary key constraint
  drill_point_pkey
}

# input type for inserting data into table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_tool_drill_bit_point_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_tool_drill_bit_point_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_tool.drill_bit_point"
type enum_item_tool_drill_bit_point_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_tool_drill_bit_point!]!
}

# input type for inserting object relation for remote table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_obj_rel_insert_input {
  data: enum_item_tool_drill_bit_point_insert_input!
  on_conflict: enum_item_tool_drill_bit_point_on_conflict
}

# on conflict condition type for table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_on_conflict {
  constraint: enum_item_tool_drill_bit_point_constraint!
  update_columns: [enum_item_tool_drill_bit_point_update_column!]!
  where: enum_item_tool_drill_bit_point_bool_exp
}

# ordering options when selecting data from "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_tool.drill_bit_point"
enum enum_item_tool_drill_bit_point_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_tool.drill_bit_point"
input enum_item_tool_drill_bit_point_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_tool.drill_bit_point"
enum enum_item_tool_drill_bit_point_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_tool.drill_bit_shank"
type enum_item_tool_drill_bit_shank {
  description: String
  id: String!
}

# aggregated selection of "enum_item_tool.drill_bit_shank"
type enum_item_tool_drill_bit_shank_aggregate {
  aggregate: enum_item_tool_drill_bit_shank_aggregate_fields
  nodes: [enum_item_tool_drill_bit_shank!]!
}

# aggregate fields of "enum_item_tool.drill_bit_shank"
type enum_item_tool_drill_bit_shank_aggregate_fields {
  count(columns: [enum_item_tool_drill_bit_shank_select_column!], distinct: Boolean): Int
  max: enum_item_tool_drill_bit_shank_max_fields
  min: enum_item_tool_drill_bit_shank_min_fields
}

# order by aggregate values of table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_aggregate_order_by {
  count: order_by
  max: enum_item_tool_drill_bit_shank_max_order_by
  min: enum_item_tool_drill_bit_shank_min_order_by
}

# input type for inserting array relation for remote table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_arr_rel_insert_input {
  data: [enum_item_tool_drill_bit_shank_insert_input!]!
  on_conflict: enum_item_tool_drill_bit_shank_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_tool.drill_bit_shank". All fields are combined with a logical 'AND'.
input enum_item_tool_drill_bit_shank_bool_exp {
  _and: [enum_item_tool_drill_bit_shank_bool_exp]
  _not: enum_item_tool_drill_bit_shank_bool_exp
  _or: [enum_item_tool_drill_bit_shank_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_tool.drill_bit_shank"
enum enum_item_tool_drill_bit_shank_constraint {
  # unique or primary key constraint
  drill_shaft_pkey
}

# input type for inserting data into table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_tool_drill_bit_shank_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_tool_drill_bit_shank_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_tool.drill_bit_shank"
type enum_item_tool_drill_bit_shank_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_tool_drill_bit_shank!]!
}

# input type for inserting object relation for remote table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_obj_rel_insert_input {
  data: enum_item_tool_drill_bit_shank_insert_input!
  on_conflict: enum_item_tool_drill_bit_shank_on_conflict
}

# on conflict condition type for table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_on_conflict {
  constraint: enum_item_tool_drill_bit_shank_constraint!
  update_columns: [enum_item_tool_drill_bit_shank_update_column!]!
  where: enum_item_tool_drill_bit_shank_bool_exp
}

# ordering options when selecting data from "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_tool.drill_bit_shank"
enum enum_item_tool_drill_bit_shank_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_tool.drill_bit_shank"
input enum_item_tool_drill_bit_shank_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_tool.drill_bit_shank"
enum enum_item_tool_drill_bit_shank_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum_item_tool.drill_bit_style"
type enum_item_tool_drill_bit_style {
  description: String
  id: String!
}

# aggregated selection of "enum_item_tool.drill_bit_style"
type enum_item_tool_drill_bit_style_aggregate {
  aggregate: enum_item_tool_drill_bit_style_aggregate_fields
  nodes: [enum_item_tool_drill_bit_style!]!
}

# aggregate fields of "enum_item_tool.drill_bit_style"
type enum_item_tool_drill_bit_style_aggregate_fields {
  count(columns: [enum_item_tool_drill_bit_style_select_column!], distinct: Boolean): Int
  max: enum_item_tool_drill_bit_style_max_fields
  min: enum_item_tool_drill_bit_style_min_fields
}

# order by aggregate values of table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_aggregate_order_by {
  count: order_by
  max: enum_item_tool_drill_bit_style_max_order_by
  min: enum_item_tool_drill_bit_style_min_order_by
}

# input type for inserting array relation for remote table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_arr_rel_insert_input {
  data: [enum_item_tool_drill_bit_style_insert_input!]!
  on_conflict: enum_item_tool_drill_bit_style_on_conflict
}

# Boolean expression to filter rows from the table "enum_item_tool.drill_bit_style". All fields are combined with a logical 'AND'.
input enum_item_tool_drill_bit_style_bool_exp {
  _and: [enum_item_tool_drill_bit_style_bool_exp]
  _not: enum_item_tool_drill_bit_style_bool_exp
  _or: [enum_item_tool_drill_bit_style_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum_item_tool.drill_bit_style"
enum enum_item_tool_drill_bit_style_constraint {
  # unique or primary key constraint
  drill_bit_style_pkey
}

# input type for inserting data into table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_item_tool_drill_bit_style_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_item_tool_drill_bit_style_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum_item_tool.drill_bit_style"
type enum_item_tool_drill_bit_style_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_item_tool_drill_bit_style!]!
}

# input type for inserting object relation for remote table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_obj_rel_insert_input {
  data: enum_item_tool_drill_bit_style_insert_input!
  on_conflict: enum_item_tool_drill_bit_style_on_conflict
}

# on conflict condition type for table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_on_conflict {
  constraint: enum_item_tool_drill_bit_style_constraint!
  update_columns: [enum_item_tool_drill_bit_style_update_column!]!
  where: enum_item_tool_drill_bit_style_bool_exp
}

# ordering options when selecting data from "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_pk_columns_input {
  id: String!
}

# select columns of table "enum_item_tool.drill_bit_style"
enum enum_item_tool_drill_bit_style_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum_item_tool.drill_bit_style"
input enum_item_tool_drill_bit_style_set_input {
  description: String
  id: String
}

# update columns of table "enum_item_tool.drill_bit_style"
enum enum_item_tool_drill_bit_style_update_column {
  # column name
  description

  # column name
  id
}

# possible <schema>_<table> classes that can be used in object_maps
#
#
# columns and relationships of "enum.mapped_class"
type enum_mapped_class {
  description: String
  id: String!
}

# aggregated selection of "enum.mapped_class"
type enum_mapped_class_aggregate {
  aggregate: enum_mapped_class_aggregate_fields
  nodes: [enum_mapped_class!]!
}

# aggregate fields of "enum.mapped_class"
type enum_mapped_class_aggregate_fields {
  count(columns: [enum_mapped_class_select_column!], distinct: Boolean): Int
  max: enum_mapped_class_max_fields
  min: enum_mapped_class_min_fields
}

# order by aggregate values of table "enum.mapped_class"
input enum_mapped_class_aggregate_order_by {
  count: order_by
  max: enum_mapped_class_max_order_by
  min: enum_mapped_class_min_order_by
}

# input type for inserting array relation for remote table "enum.mapped_class"
input enum_mapped_class_arr_rel_insert_input {
  data: [enum_mapped_class_insert_input!]!
  on_conflict: enum_mapped_class_on_conflict
}

# Boolean expression to filter rows from the table "enum.mapped_class". All fields are combined with a logical 'AND'.
input enum_mapped_class_bool_exp {
  _and: [enum_mapped_class_bool_exp]
  _not: enum_mapped_class_bool_exp
  _or: [enum_mapped_class_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum.mapped_class"
enum enum_mapped_class_constraint {
  # unique or primary key constraint
  mapped_class_pkey
}

enum enum_mapped_class_enum {
  #
  item_bundle
  item_hardware_fastener_bolt
  item_hardware_fastener_nut
  item_hardware_fastener_screw
  item_hardware_fastener_screw_machine
  item_hardware_fastener_standoff

  # Washers
  item_hardware_fastener_washer
}

# expression to compare columns of type enum_mapped_class_enum. All fields are combined with logical 'AND'.
input enum_mapped_class_enum_comparison_exp {
  _eq: enum_mapped_class_enum
  _in: [enum_mapped_class_enum!]
  _is_null: Boolean
  _neq: enum_mapped_class_enum
  _nin: [enum_mapped_class_enum!]
}

# input type for inserting data into table "enum.mapped_class"
input enum_mapped_class_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_mapped_class_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum.mapped_class"
input enum_mapped_class_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_mapped_class_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum.mapped_class"
input enum_mapped_class_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum.mapped_class"
type enum_mapped_class_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_mapped_class!]!
}

# input type for inserting object relation for remote table "enum.mapped_class"
input enum_mapped_class_obj_rel_insert_input {
  data: enum_mapped_class_insert_input!
  on_conflict: enum_mapped_class_on_conflict
}

# on conflict condition type for table "enum.mapped_class"
input enum_mapped_class_on_conflict {
  constraint: enum_mapped_class_constraint!
  update_columns: [enum_mapped_class_update_column!]!
  where: enum_mapped_class_bool_exp
}

# ordering options when selecting data from "enum.mapped_class"
input enum_mapped_class_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum.mapped_class"
input enum_mapped_class_pk_columns_input {
  id: String!
}

# select columns of table "enum.mapped_class"
enum enum_mapped_class_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum.mapped_class"
input enum_mapped_class_set_input {
  description: String
  id: String
}

# update columns of table "enum.mapped_class"
enum enum_mapped_class_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum.payment_method_type"
type enum_payment_method_type {
  description: String!
  id: String!
}

# aggregated selection of "enum.payment_method_type"
type enum_payment_method_type_aggregate {
  aggregate: enum_payment_method_type_aggregate_fields
  nodes: [enum_payment_method_type!]!
}

# aggregate fields of "enum.payment_method_type"
type enum_payment_method_type_aggregate_fields {
  count(columns: [enum_payment_method_type_select_column!], distinct: Boolean): Int
  max: enum_payment_method_type_max_fields
  min: enum_payment_method_type_min_fields
}

# order by aggregate values of table "enum.payment_method_type"
input enum_payment_method_type_aggregate_order_by {
  count: order_by
  max: enum_payment_method_type_max_order_by
  min: enum_payment_method_type_min_order_by
}

# input type for inserting array relation for remote table "enum.payment_method_type"
input enum_payment_method_type_arr_rel_insert_input {
  data: [enum_payment_method_type_insert_input!]!
  on_conflict: enum_payment_method_type_on_conflict
}

# Boolean expression to filter rows from the table "enum.payment_method_type". All fields are combined with a logical 'AND'.
input enum_payment_method_type_bool_exp {
  _and: [enum_payment_method_type_bool_exp]
  _not: enum_payment_method_type_bool_exp
  _or: [enum_payment_method_type_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum.payment_method_type"
enum enum_payment_method_type_constraint {
  # unique or primary key constraint
  payment_method_typ_pkey
}

enum enum_payment_method_type_enum {
  # Bank Automated Clearing House
  ACH

  # Cash
  CASH

  # Credit Card
  CC

  # Check
  CHECK
}

# expression to compare columns of type enum_payment_method_type_enum. All fields are combined with logical 'AND'.
input enum_payment_method_type_enum_comparison_exp {
  _eq: enum_payment_method_type_enum
  _in: [enum_payment_method_type_enum!]
  _is_null: Boolean
  _neq: enum_payment_method_type_enum
  _nin: [enum_payment_method_type_enum!]
}

# input type for inserting data into table "enum.payment_method_type"
input enum_payment_method_type_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_payment_method_type_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum.payment_method_type"
input enum_payment_method_type_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_payment_method_type_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum.payment_method_type"
input enum_payment_method_type_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum.payment_method_type"
type enum_payment_method_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_payment_method_type!]!
}

# input type for inserting object relation for remote table "enum.payment_method_type"
input enum_payment_method_type_obj_rel_insert_input {
  data: enum_payment_method_type_insert_input!
  on_conflict: enum_payment_method_type_on_conflict
}

# on conflict condition type for table "enum.payment_method_type"
input enum_payment_method_type_on_conflict {
  constraint: enum_payment_method_type_constraint!
  update_columns: [enum_payment_method_type_update_column!]!
  where: enum_payment_method_type_bool_exp
}

# ordering options when selecting data from "enum.payment_method_type"
input enum_payment_method_type_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum.payment_method_type"
input enum_payment_method_type_pk_columns_input {
  id: String!
}

# select columns of table "enum.payment_method_type"
enum enum_payment_method_type_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum.payment_method_type"
input enum_payment_method_type_set_input {
  description: String
  id: String
}

# update columns of table "enum.payment_method_type"
enum enum_payment_method_type_update_column {
  # column name
  description

  # column name
  id
}

# Storage space type
#
#
# columns and relationships of "enum.space_type"
type enum_space_type {
  description: String
  id: String!
}

# aggregated selection of "enum.space_type"
type enum_space_type_aggregate {
  aggregate: enum_space_type_aggregate_fields
  nodes: [enum_space_type!]!
}

# aggregate fields of "enum.space_type"
type enum_space_type_aggregate_fields {
  count(columns: [enum_space_type_select_column!], distinct: Boolean): Int
  max: enum_space_type_max_fields
  min: enum_space_type_min_fields
}

# order by aggregate values of table "enum.space_type"
input enum_space_type_aggregate_order_by {
  count: order_by
  max: enum_space_type_max_order_by
  min: enum_space_type_min_order_by
}

# input type for inserting array relation for remote table "enum.space_type"
input enum_space_type_arr_rel_insert_input {
  data: [enum_space_type_insert_input!]!
  on_conflict: enum_space_type_on_conflict
}

# Boolean expression to filter rows from the table "enum.space_type". All fields are combined with a logical 'AND'.
input enum_space_type_bool_exp {
  _and: [enum_space_type_bool_exp]
  _not: enum_space_type_bool_exp
  _or: [enum_space_type_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum.space_type"
enum enum_space_type_constraint {
  # unique or primary key constraint
  space_type_pkey
}

enum enum_space_type_enum {
  bin
  building
  drawer
  floor
  political_region
  room
  wall
}

# expression to compare columns of type enum_space_type_enum. All fields are combined with logical 'AND'.
input enum_space_type_enum_comparison_exp {
  _eq: enum_space_type_enum
  _in: [enum_space_type_enum!]
  _is_null: Boolean
  _neq: enum_space_type_enum
  _nin: [enum_space_type_enum!]
}

# input type for inserting data into table "enum.space_type"
input enum_space_type_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_space_type_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum.space_type"
input enum_space_type_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_space_type_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum.space_type"
input enum_space_type_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum.space_type"
type enum_space_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_space_type!]!
}

# input type for inserting object relation for remote table "enum.space_type"
input enum_space_type_obj_rel_insert_input {
  data: enum_space_type_insert_input!
  on_conflict: enum_space_type_on_conflict
}

# on conflict condition type for table "enum.space_type"
input enum_space_type_on_conflict {
  constraint: enum_space_type_constraint!
  update_columns: [enum_space_type_update_column!]!
  where: enum_space_type_bool_exp
}

# ordering options when selecting data from "enum.space_type"
input enum_space_type_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum.space_type"
input enum_space_type_pk_columns_input {
  id: String!
}

# select columns of table "enum.space_type"
enum enum_space_type_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum.space_type"
input enum_space_type_set_input {
  description: String
  id: String
}

# update columns of table "enum.space_type"
enum enum_space_type_update_column {
  # column name
  description

  # column name
  id
}

# Event types that can add or subtract items from stock.
#
#
# columns and relationships of "enum.stock_event_type"
type enum_stock_event_type {
  description: String
  id: String!
}

# aggregated selection of "enum.stock_event_type"
type enum_stock_event_type_aggregate {
  aggregate: enum_stock_event_type_aggregate_fields
  nodes: [enum_stock_event_type!]!
}

# aggregate fields of "enum.stock_event_type"
type enum_stock_event_type_aggregate_fields {
  count(columns: [enum_stock_event_type_select_column!], distinct: Boolean): Int
  max: enum_stock_event_type_max_fields
  min: enum_stock_event_type_min_fields
}

# order by aggregate values of table "enum.stock_event_type"
input enum_stock_event_type_aggregate_order_by {
  count: order_by
  max: enum_stock_event_type_max_order_by
  min: enum_stock_event_type_min_order_by
}

# input type for inserting array relation for remote table "enum.stock_event_type"
input enum_stock_event_type_arr_rel_insert_input {
  data: [enum_stock_event_type_insert_input!]!
  on_conflict: enum_stock_event_type_on_conflict
}

# Boolean expression to filter rows from the table "enum.stock_event_type". All fields are combined with a logical 'AND'.
input enum_stock_event_type_bool_exp {
  _and: [enum_stock_event_type_bool_exp]
  _not: enum_stock_event_type_bool_exp
  _or: [enum_stock_event_type_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum.stock_event_type"
enum enum_stock_event_type_constraint {
  # unique or primary key constraint
  stock_event_type_pkey
}

enum enum_stock_event_type_enum {
  # item(s) added in an undefined method. Typically when the order simply was never input to inventory.
  generic_aquisition

  # item(s) consumed in an undefined manner. Typically for untracked projects.
  generic_consumption

  # item(s) purchased in an order
  order

  # item(s) consumed in a given project.
  project
}

# expression to compare columns of type enum_stock_event_type_enum. All fields are combined with logical 'AND'.
input enum_stock_event_type_enum_comparison_exp {
  _eq: enum_stock_event_type_enum
  _in: [enum_stock_event_type_enum!]
  _is_null: Boolean
  _neq: enum_stock_event_type_enum
  _nin: [enum_stock_event_type_enum!]
}

# input type for inserting data into table "enum.stock_event_type"
input enum_stock_event_type_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_stock_event_type_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum.stock_event_type"
input enum_stock_event_type_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_stock_event_type_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum.stock_event_type"
input enum_stock_event_type_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum.stock_event_type"
type enum_stock_event_type_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_stock_event_type!]!
}

# input type for inserting object relation for remote table "enum.stock_event_type"
input enum_stock_event_type_obj_rel_insert_input {
  data: enum_stock_event_type_insert_input!
  on_conflict: enum_stock_event_type_on_conflict
}

# on conflict condition type for table "enum.stock_event_type"
input enum_stock_event_type_on_conflict {
  constraint: enum_stock_event_type_constraint!
  update_columns: [enum_stock_event_type_update_column!]!
  where: enum_stock_event_type_bool_exp
}

# ordering options when selecting data from "enum.stock_event_type"
input enum_stock_event_type_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum.stock_event_type"
input enum_stock_event_type_pk_columns_input {
  id: String!
}

# select columns of table "enum.stock_event_type"
enum enum_stock_event_type_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum.stock_event_type"
input enum_stock_event_type_set_input {
  description: String
  id: String
}

# update columns of table "enum.stock_event_type"
enum enum_stock_event_type_update_column {
  # column name
  description

  # column name
  id
}

# columns and relationships of "enum.unit"
type enum_unit {
  description: String
  id: String!
}

# aggregated selection of "enum.unit"
type enum_unit_aggregate {
  aggregate: enum_unit_aggregate_fields
  nodes: [enum_unit!]!
}

# aggregate fields of "enum.unit"
type enum_unit_aggregate_fields {
  count(columns: [enum_unit_select_column!], distinct: Boolean): Int
  max: enum_unit_max_fields
  min: enum_unit_min_fields
}

# order by aggregate values of table "enum.unit"
input enum_unit_aggregate_order_by {
  count: order_by
  max: enum_unit_max_order_by
  min: enum_unit_min_order_by
}

# input type for inserting array relation for remote table "enum.unit"
input enum_unit_arr_rel_insert_input {
  data: [enum_unit_insert_input!]!
  on_conflict: enum_unit_on_conflict
}

# Boolean expression to filter rows from the table "enum.unit". All fields are combined with a logical 'AND'.
input enum_unit_bool_exp {
  _and: [enum_unit_bool_exp]
  _not: enum_unit_bool_exp
  _or: [enum_unit_bool_exp]
  description: String_comparison_exp
  id: String_comparison_exp
}

# unique or primary key constraints on table "enum.unit"
enum enum_unit_constraint {
  # unique or primary key constraint
  unit_pkey
}

enum enum_unit_enum {
  metric

  # United States Customary Measurement System
  usc
}

# expression to compare columns of type enum_unit_enum. All fields are combined with logical 'AND'.
input enum_unit_enum_comparison_exp {
  _eq: enum_unit_enum
  _in: [enum_unit_enum!]
  _is_null: Boolean
  _neq: enum_unit_enum
  _nin: [enum_unit_enum!]
}

# input type for inserting data into table "enum.unit"
input enum_unit_insert_input {
  description: String
  id: String
}

# aggregate max on columns
type enum_unit_max_fields {
  description: String
  id: String
}

# order by max() on columns of table "enum.unit"
input enum_unit_max_order_by {
  description: order_by
  id: order_by
}

# aggregate min on columns
type enum_unit_min_fields {
  description: String
  id: String
}

# order by min() on columns of table "enum.unit"
input enum_unit_min_order_by {
  description: order_by
  id: order_by
}

# response of any mutation on the table "enum.unit"
type enum_unit_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [enum_unit!]!
}

# input type for inserting object relation for remote table "enum.unit"
input enum_unit_obj_rel_insert_input {
  data: enum_unit_insert_input!
  on_conflict: enum_unit_on_conflict
}

# on conflict condition type for table "enum.unit"
input enum_unit_on_conflict {
  constraint: enum_unit_constraint!
  update_columns: [enum_unit_update_column!]!
  where: enum_unit_bool_exp
}

# ordering options when selecting data from "enum.unit"
input enum_unit_order_by {
  description: order_by
  id: order_by
}

# primary key columns input for table: "enum.unit"
input enum_unit_pk_columns_input {
  id: String!
}

# select columns of table "enum.unit"
enum enum_unit_select_column {
  # column name
  description

  # column name
  id
}

# input type for updating data in table "enum.unit"
input enum_unit_set_input {
  description: String
  id: String
}

# update columns of table "enum.unit"
enum enum_unit_update_column {
  # column name
  description

  # column name
  id
}

# Image / icon data for labels
#
#
# columns and relationships of "icon"
type icon {
  # An array relationship
  categories(
    # distinct select on columns
    distinct_on: [icon_item_category_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_category_map_order_by!]

    # filter the rows returned
    where: icon_item_category_map_bool_exp
  ): [icon_item_category_map!]!

  # An aggregated array relationship
  categories_aggregate(
    # distinct select on columns
    distinct_on: [icon_item_category_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_category_map_order_by!]

    # filter the rows returned
    where: icon_item_category_map_bool_exp
  ): icon_item_category_map_aggregate!
  created_at: timestamptz!

  # Store image data in Base64
  data: String!
  description: String
  id: uuid!

  # An array relationship
  items(
    # distinct select on columns
    distinct_on: [icon_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_map_order_by!]

    # filter the rows returned
    where: icon_item_map_bool_exp
  ): [icon_item_map!]!

  # An aggregated array relationship
  items_aggregate(
    # distinct select on columns
    distinct_on: [icon_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_map_order_by!]

    # filter the rows returned
    where: icon_item_map_bool_exp
  ): icon_item_map_aggregate!

  # An array relationship
  labels(
    # distinct select on columns
    distinct_on: [icon_label_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_label_map_order_by!]

    # filter the rows returned
    where: icon_label_map_bool_exp
  ): [icon_label_map!]!

  # An aggregated array relationship
  labels_aggregate(
    # distinct select on columns
    distinct_on: [icon_label_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_label_map_order_by!]

    # filter the rows returned
    where: icon_label_map_bool_exp
  ): icon_label_map_aggregate!
  title: String
}

# aggregated selection of "icon"
type icon_aggregate {
  aggregate: icon_aggregate_fields
  nodes: [icon!]!
}

# aggregate fields of "icon"
type icon_aggregate_fields {
  count(columns: [icon_select_column!], distinct: Boolean): Int
  max: icon_max_fields
  min: icon_min_fields
}

# order by aggregate values of table "icon"
input icon_aggregate_order_by {
  count: order_by
  max: icon_max_order_by
  min: icon_min_order_by
}

# input type for inserting array relation for remote table "icon"
input icon_arr_rel_insert_input {
  data: [icon_insert_input!]!
  on_conflict: icon_on_conflict
}

# Boolean expression to filter rows from the table "icon". All fields are combined with a logical 'AND'.
input icon_bool_exp {
  _and: [icon_bool_exp]
  _not: icon_bool_exp
  _or: [icon_bool_exp]
  categories: icon_item_category_map_bool_exp
  created_at: timestamptz_comparison_exp
  data: String_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  items: icon_item_map_bool_exp
  labels: icon_label_map_bool_exp
  title: String_comparison_exp
}

# unique or primary key constraints on table "icon"
enum icon_constraint {
  # unique or primary key constraint
  icons_id_key

  # unique or primary key constraint
  icons_pkey
}

# input type for inserting data into table "icon"
input icon_insert_input {
  categories: icon_item_category_map_arr_rel_insert_input
  created_at: timestamptz
  data: String
  description: String
  id: uuid
  items: icon_item_map_arr_rel_insert_input
  labels: icon_label_map_arr_rel_insert_input
  title: String
}

# columns and relationships of "icon_item_category_map"
type icon_item_category_map {
  category: enum_item_class_enum!

  # json rules in the form of:
  #     { [propKey: keyof item_class]: regex }
  # this is then evaluated for each entry
  # evaluation is done in the sequence order
  criteria(
    # JSON select path
    path: String
  ): jsonb
  icon_id: uuid!
  sequence: smallint!
}

# aggregated selection of "icon_item_category_map"
type icon_item_category_map_aggregate {
  aggregate: icon_item_category_map_aggregate_fields
  nodes: [icon_item_category_map!]!
}

# aggregate fields of "icon_item_category_map"
type icon_item_category_map_aggregate_fields {
  avg: icon_item_category_map_avg_fields
  count(columns: [icon_item_category_map_select_column!], distinct: Boolean): Int
  max: icon_item_category_map_max_fields
  min: icon_item_category_map_min_fields
  stddev: icon_item_category_map_stddev_fields
  stddev_pop: icon_item_category_map_stddev_pop_fields
  stddev_samp: icon_item_category_map_stddev_samp_fields
  sum: icon_item_category_map_sum_fields
  var_pop: icon_item_category_map_var_pop_fields
  var_samp: icon_item_category_map_var_samp_fields
  variance: icon_item_category_map_variance_fields
}

# order by aggregate values of table "icon_item_category_map"
input icon_item_category_map_aggregate_order_by {
  avg: icon_item_category_map_avg_order_by
  count: order_by
  max: icon_item_category_map_max_order_by
  min: icon_item_category_map_min_order_by
  stddev: icon_item_category_map_stddev_order_by
  stddev_pop: icon_item_category_map_stddev_pop_order_by
  stddev_samp: icon_item_category_map_stddev_samp_order_by
  sum: icon_item_category_map_sum_order_by
  var_pop: icon_item_category_map_var_pop_order_by
  var_samp: icon_item_category_map_var_samp_order_by
  variance: icon_item_category_map_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input icon_item_category_map_append_input {
  criteria: jsonb
}

# input type for inserting array relation for remote table "icon_item_category_map"
input icon_item_category_map_arr_rel_insert_input {
  data: [icon_item_category_map_insert_input!]!
  on_conflict: icon_item_category_map_on_conflict
}

# aggregate avg on columns
type icon_item_category_map_avg_fields {
  sequence: Float
}

# order by avg() on columns of table "icon_item_category_map"
input icon_item_category_map_avg_order_by {
  sequence: order_by
}

# Boolean expression to filter rows from the table "icon_item_category_map". All fields are combined with a logical 'AND'.
input icon_item_category_map_bool_exp {
  _and: [icon_item_category_map_bool_exp]
  _not: icon_item_category_map_bool_exp
  _or: [icon_item_category_map_bool_exp]
  category: enum_item_class_enum_comparison_exp
  criteria: jsonb_comparison_exp
  icon_id: uuid_comparison_exp
  sequence: smallint_comparison_exp
}

# unique or primary key constraints on table "icon_item_category_map"
enum icon_item_category_map_constraint {
  # unique or primary key constraint
  icon_item_category_map_category_sequence_key

  # unique or primary key constraint
  icon_item_category_map_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input icon_item_category_map_delete_at_path_input {
  criteria: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input icon_item_category_map_delete_elem_input {
  criteria: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input icon_item_category_map_delete_key_input {
  criteria: String
}

# input type for incrementing integer column in table "icon_item_category_map"
input icon_item_category_map_inc_input {
  sequence: smallint
}

# input type for inserting data into table "icon_item_category_map"
input icon_item_category_map_insert_input {
  category: enum_item_class_enum
  criteria: jsonb
  icon_id: uuid
  sequence: smallint
}

# aggregate max on columns
type icon_item_category_map_max_fields {
  icon_id: uuid
  sequence: smallint
}

# order by max() on columns of table "icon_item_category_map"
input icon_item_category_map_max_order_by {
  icon_id: order_by
  sequence: order_by
}

# aggregate min on columns
type icon_item_category_map_min_fields {
  icon_id: uuid
  sequence: smallint
}

# order by min() on columns of table "icon_item_category_map"
input icon_item_category_map_min_order_by {
  icon_id: order_by
  sequence: order_by
}

# response of any mutation on the table "icon_item_category_map"
type icon_item_category_map_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [icon_item_category_map!]!
}

# input type for inserting object relation for remote table "icon_item_category_map"
input icon_item_category_map_obj_rel_insert_input {
  data: icon_item_category_map_insert_input!
  on_conflict: icon_item_category_map_on_conflict
}

# on conflict condition type for table "icon_item_category_map"
input icon_item_category_map_on_conflict {
  constraint: icon_item_category_map_constraint!
  update_columns: [icon_item_category_map_update_column!]!
  where: icon_item_category_map_bool_exp
}

# ordering options when selecting data from "icon_item_category_map"
input icon_item_category_map_order_by {
  category: order_by
  criteria: order_by
  icon_id: order_by
  sequence: order_by
}

# primary key columns input for table: "icon_item_category_map"
input icon_item_category_map_pk_columns_input {
  category: enum_item_class_enum!
  icon_id: uuid!
  sequence: smallint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input icon_item_category_map_prepend_input {
  criteria: jsonb
}

# select columns of table "icon_item_category_map"
enum icon_item_category_map_select_column {
  # column name
  category

  # column name
  criteria

  # column name
  icon_id

  # column name
  sequence
}

# input type for updating data in table "icon_item_category_map"
input icon_item_category_map_set_input {
  category: enum_item_class_enum
  criteria: jsonb
  icon_id: uuid
  sequence: smallint
}

# aggregate stddev on columns
type icon_item_category_map_stddev_fields {
  sequence: Float
}

# order by stddev() on columns of table "icon_item_category_map"
input icon_item_category_map_stddev_order_by {
  sequence: order_by
}

# aggregate stddev_pop on columns
type icon_item_category_map_stddev_pop_fields {
  sequence: Float
}

# order by stddev_pop() on columns of table "icon_item_category_map"
input icon_item_category_map_stddev_pop_order_by {
  sequence: order_by
}

# aggregate stddev_samp on columns
type icon_item_category_map_stddev_samp_fields {
  sequence: Float
}

# order by stddev_samp() on columns of table "icon_item_category_map"
input icon_item_category_map_stddev_samp_order_by {
  sequence: order_by
}

# aggregate sum on columns
type icon_item_category_map_sum_fields {
  sequence: smallint
}

# order by sum() on columns of table "icon_item_category_map"
input icon_item_category_map_sum_order_by {
  sequence: order_by
}

# update columns of table "icon_item_category_map"
enum icon_item_category_map_update_column {
  # column name
  category

  # column name
  criteria

  # column name
  icon_id

  # column name
  sequence
}

# aggregate var_pop on columns
type icon_item_category_map_var_pop_fields {
  sequence: Float
}

# order by var_pop() on columns of table "icon_item_category_map"
input icon_item_category_map_var_pop_order_by {
  sequence: order_by
}

# aggregate var_samp on columns
type icon_item_category_map_var_samp_fields {
  sequence: Float
}

# order by var_samp() on columns of table "icon_item_category_map"
input icon_item_category_map_var_samp_order_by {
  sequence: order_by
}

# aggregate variance on columns
type icon_item_category_map_variance_fields {
  sequence: Float
}

# order by variance() on columns of table "icon_item_category_map"
input icon_item_category_map_variance_order_by {
  sequence: order_by
}

# map icon to specific individual items
#
#
# columns and relationships of "icon_item_map"
type icon_item_map {
  # An object relationship
  icon: icon!
  icon_id: uuid!

  # An object relationship
  item: item!
  item_id: Int!
}

# aggregated selection of "icon_item_map"
type icon_item_map_aggregate {
  aggregate: icon_item_map_aggregate_fields
  nodes: [icon_item_map!]!
}

# aggregate fields of "icon_item_map"
type icon_item_map_aggregate_fields {
  avg: icon_item_map_avg_fields
  count(columns: [icon_item_map_select_column!], distinct: Boolean): Int
  max: icon_item_map_max_fields
  min: icon_item_map_min_fields
  stddev: icon_item_map_stddev_fields
  stddev_pop: icon_item_map_stddev_pop_fields
  stddev_samp: icon_item_map_stddev_samp_fields
  sum: icon_item_map_sum_fields
  var_pop: icon_item_map_var_pop_fields
  var_samp: icon_item_map_var_samp_fields
  variance: icon_item_map_variance_fields
}

# order by aggregate values of table "icon_item_map"
input icon_item_map_aggregate_order_by {
  avg: icon_item_map_avg_order_by
  count: order_by
  max: icon_item_map_max_order_by
  min: icon_item_map_min_order_by
  stddev: icon_item_map_stddev_order_by
  stddev_pop: icon_item_map_stddev_pop_order_by
  stddev_samp: icon_item_map_stddev_samp_order_by
  sum: icon_item_map_sum_order_by
  var_pop: icon_item_map_var_pop_order_by
  var_samp: icon_item_map_var_samp_order_by
  variance: icon_item_map_variance_order_by
}

# input type for inserting array relation for remote table "icon_item_map"
input icon_item_map_arr_rel_insert_input {
  data: [icon_item_map_insert_input!]!
  on_conflict: icon_item_map_on_conflict
}

# aggregate avg on columns
type icon_item_map_avg_fields {
  item_id: Float
}

# order by avg() on columns of table "icon_item_map"
input icon_item_map_avg_order_by {
  item_id: order_by
}

# Boolean expression to filter rows from the table "icon_item_map". All fields are combined with a logical 'AND'.
input icon_item_map_bool_exp {
  _and: [icon_item_map_bool_exp]
  _not: icon_item_map_bool_exp
  _or: [icon_item_map_bool_exp]
  icon: icon_bool_exp
  icon_id: uuid_comparison_exp
  item: item_bool_exp
  item_id: Int_comparison_exp
}

# unique or primary key constraints on table "icon_item_map"
enum icon_item_map_constraint {
  # unique or primary key constraint
  icon_item_map_pkey
}

# input type for incrementing integer column in table "icon_item_map"
input icon_item_map_inc_input {
  item_id: Int
}

# input type for inserting data into table "icon_item_map"
input icon_item_map_insert_input {
  icon: icon_obj_rel_insert_input
  icon_id: uuid
  item: item_obj_rel_insert_input
  item_id: Int
}

# aggregate max on columns
type icon_item_map_max_fields {
  icon_id: uuid
  item_id: Int
}

# order by max() on columns of table "icon_item_map"
input icon_item_map_max_order_by {
  icon_id: order_by
  item_id: order_by
}

# aggregate min on columns
type icon_item_map_min_fields {
  icon_id: uuid
  item_id: Int
}

# order by min() on columns of table "icon_item_map"
input icon_item_map_min_order_by {
  icon_id: order_by
  item_id: order_by
}

# response of any mutation on the table "icon_item_map"
type icon_item_map_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [icon_item_map!]!
}

# input type for inserting object relation for remote table "icon_item_map"
input icon_item_map_obj_rel_insert_input {
  data: icon_item_map_insert_input!
  on_conflict: icon_item_map_on_conflict
}

# on conflict condition type for table "icon_item_map"
input icon_item_map_on_conflict {
  constraint: icon_item_map_constraint!
  update_columns: [icon_item_map_update_column!]!
  where: icon_item_map_bool_exp
}

# ordering options when selecting data from "icon_item_map"
input icon_item_map_order_by {
  icon: icon_order_by
  icon_id: order_by
  item: item_order_by
  item_id: order_by
}

# primary key columns input for table: "icon_item_map"
input icon_item_map_pk_columns_input {
  icon_id: uuid!
  item_id: Int!
}

# select columns of table "icon_item_map"
enum icon_item_map_select_column {
  # column name
  icon_id

  # column name
  item_id
}

# input type for updating data in table "icon_item_map"
input icon_item_map_set_input {
  icon_id: uuid
  item_id: Int
}

# aggregate stddev on columns
type icon_item_map_stddev_fields {
  item_id: Float
}

# order by stddev() on columns of table "icon_item_map"
input icon_item_map_stddev_order_by {
  item_id: order_by
}

# aggregate stddev_pop on columns
type icon_item_map_stddev_pop_fields {
  item_id: Float
}

# order by stddev_pop() on columns of table "icon_item_map"
input icon_item_map_stddev_pop_order_by {
  item_id: order_by
}

# aggregate stddev_samp on columns
type icon_item_map_stddev_samp_fields {
  item_id: Float
}

# order by stddev_samp() on columns of table "icon_item_map"
input icon_item_map_stddev_samp_order_by {
  item_id: order_by
}

# aggregate sum on columns
type icon_item_map_sum_fields {
  item_id: Int
}

# order by sum() on columns of table "icon_item_map"
input icon_item_map_sum_order_by {
  item_id: order_by
}

# update columns of table "icon_item_map"
enum icon_item_map_update_column {
  # column name
  icon_id

  # column name
  item_id
}

# aggregate var_pop on columns
type icon_item_map_var_pop_fields {
  item_id: Float
}

# order by var_pop() on columns of table "icon_item_map"
input icon_item_map_var_pop_order_by {
  item_id: order_by
}

# aggregate var_samp on columns
type icon_item_map_var_samp_fields {
  item_id: Float
}

# order by var_samp() on columns of table "icon_item_map"
input icon_item_map_var_samp_order_by {
  item_id: order_by
}

# aggregate variance on columns
type icon_item_map_variance_fields {
  item_id: Float
}

# order by variance() on columns of table "icon_item_map"
input icon_item_map_variance_order_by {
  item_id: order_by
}

# columns and relationships of "icon_label_map"
type icon_label_map {
  # An object relationship
  icon: icon!
  icon_id: uuid!
  label_id: uuid!
}

# aggregated selection of "icon_label_map"
type icon_label_map_aggregate {
  aggregate: icon_label_map_aggregate_fields
  nodes: [icon_label_map!]!
}

# aggregate fields of "icon_label_map"
type icon_label_map_aggregate_fields {
  count(columns: [icon_label_map_select_column!], distinct: Boolean): Int
  max: icon_label_map_max_fields
  min: icon_label_map_min_fields
}

# order by aggregate values of table "icon_label_map"
input icon_label_map_aggregate_order_by {
  count: order_by
  max: icon_label_map_max_order_by
  min: icon_label_map_min_order_by
}

# input type for inserting array relation for remote table "icon_label_map"
input icon_label_map_arr_rel_insert_input {
  data: [icon_label_map_insert_input!]!
  on_conflict: icon_label_map_on_conflict
}

# Boolean expression to filter rows from the table "icon_label_map". All fields are combined with a logical 'AND'.
input icon_label_map_bool_exp {
  _and: [icon_label_map_bool_exp]
  _not: icon_label_map_bool_exp
  _or: [icon_label_map_bool_exp]
  icon: icon_bool_exp
  icon_id: uuid_comparison_exp
  label_id: uuid_comparison_exp
}

# unique or primary key constraints on table "icon_label_map"
enum icon_label_map_constraint {
  # unique or primary key constraint
  icon_label_map_pkey
}

# input type for inserting data into table "icon_label_map"
input icon_label_map_insert_input {
  icon: icon_obj_rel_insert_input
  icon_id: uuid
  label_id: uuid
}

# aggregate max on columns
type icon_label_map_max_fields {
  icon_id: uuid
  label_id: uuid
}

# order by max() on columns of table "icon_label_map"
input icon_label_map_max_order_by {
  icon_id: order_by
  label_id: order_by
}

# aggregate min on columns
type icon_label_map_min_fields {
  icon_id: uuid
  label_id: uuid
}

# order by min() on columns of table "icon_label_map"
input icon_label_map_min_order_by {
  icon_id: order_by
  label_id: order_by
}

# response of any mutation on the table "icon_label_map"
type icon_label_map_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [icon_label_map!]!
}

# input type for inserting object relation for remote table "icon_label_map"
input icon_label_map_obj_rel_insert_input {
  data: icon_label_map_insert_input!
  on_conflict: icon_label_map_on_conflict
}

# on conflict condition type for table "icon_label_map"
input icon_label_map_on_conflict {
  constraint: icon_label_map_constraint!
  update_columns: [icon_label_map_update_column!]!
  where: icon_label_map_bool_exp
}

# ordering options when selecting data from "icon_label_map"
input icon_label_map_order_by {
  icon: icon_order_by
  icon_id: order_by
  label_id: order_by
}

# primary key columns input for table: "icon_label_map"
input icon_label_map_pk_columns_input {
  icon_id: uuid!
  label_id: uuid!
}

# select columns of table "icon_label_map"
enum icon_label_map_select_column {
  # column name
  icon_id

  # column name
  label_id
}

# input type for updating data in table "icon_label_map"
input icon_label_map_set_input {
  icon_id: uuid
  label_id: uuid
}

# update columns of table "icon_label_map"
enum icon_label_map_update_column {
  # column name
  icon_id

  # column name
  label_id
}

# aggregate max on columns
type icon_max_fields {
  created_at: timestamptz
  data: String
  description: String
  id: uuid
  title: String
}

# order by max() on columns of table "icon"
input icon_max_order_by {
  created_at: order_by
  data: order_by
  description: order_by
  id: order_by
  title: order_by
}

# aggregate min on columns
type icon_min_fields {
  created_at: timestamptz
  data: String
  description: String
  id: uuid
  title: String
}

# order by min() on columns of table "icon"
input icon_min_order_by {
  created_at: order_by
  data: order_by
  description: order_by
  id: order_by
  title: order_by
}

# response of any mutation on the table "icon"
type icon_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [icon!]!
}

# input type for inserting object relation for remote table "icon"
input icon_obj_rel_insert_input {
  data: icon_insert_input!
  on_conflict: icon_on_conflict
}

# on conflict condition type for table "icon"
input icon_on_conflict {
  constraint: icon_constraint!
  update_columns: [icon_update_column!]!
  where: icon_bool_exp
}

# ordering options when selecting data from "icon"
input icon_order_by {
  categories_aggregate: icon_item_category_map_aggregate_order_by
  created_at: order_by
  data: order_by
  description: order_by
  id: order_by
  items_aggregate: icon_item_map_aggregate_order_by
  labels_aggregate: icon_label_map_aggregate_order_by
  title: order_by
}

# primary key columns input for table: "icon"
input icon_pk_columns_input {
  id: uuid!
}

# select columns of table "icon"
enum icon_select_column {
  # column name
  created_at

  # column name
  data

  # column name
  description

  # column name
  id

  # column name
  title
}

# input type for updating data in table "icon"
input icon_set_input {
  created_at: timestamptz
  data: String
  description: String
  id: uuid
  title: String
}

# update columns of table "icon"
enum icon_update_column {
  # column name
  created_at

  # column name
  data

  # column name
  description

  # column name
  id

  # column name
  title
}

# columns and relationships of "item"
type item {
  # An array relationship
  bundle(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): [item_bundle_map!]!

  # An aggregated array relationship
  bundle_aggregate(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): item_bundle_map_aggregate!
  class: enum_item_class_enum!
  id: Int!

  # An array relationship
  itemVariants(
    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): [item_variant!]!

  # An aggregated array relationship
  itemVariants_aggregate(
    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): item_variant_aggregate!

  # An array relationship
  labelTemplates(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): [label_template_map!]!

  # An aggregated array relationship
  labelTemplates_aggregate(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): label_template_map_aggregate!

  # An array relationship
  labels(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): [label!]!

  # An aggregated array relationship
  labels_aggregate(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): label_aggregate!

  # An array relationship
  manufacturerItems(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): [manufacturer_item!]!

  # An aggregated array relationship
  manufacturerItems_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): manufacturer_item_aggregate!
  object(
    # JSON select path
    path: String
  ): jsonb

  # An array relationship
  orderItems(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): [order_item!]!

  # An aggregated array relationship
  orderItems_aggregate(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): order_item_aggregate!

  # An array relationship
  vendorItems(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): [vendor_item!]!

  # An aggregated array relationship
  vendorItems_aggregate(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): vendor_item_aggregate!
}

# aggregated selection of "item"
type item_aggregate {
  aggregate: item_aggregate_fields
  nodes: [item!]!
}

# aggregate fields of "item"
type item_aggregate_fields {
  avg: item_avg_fields
  count(columns: [item_select_column!], distinct: Boolean): Int
  max: item_max_fields
  min: item_min_fields
  stddev: item_stddev_fields
  stddev_pop: item_stddev_pop_fields
  stddev_samp: item_stddev_samp_fields
  sum: item_sum_fields
  var_pop: item_var_pop_fields
  var_samp: item_var_samp_fields
  variance: item_variance_fields
}

# order by aggregate values of table "item"
input item_aggregate_order_by {
  avg: item_avg_order_by
  count: order_by
  max: item_max_order_by
  min: item_min_order_by
  stddev: item_stddev_order_by
  stddev_pop: item_stddev_pop_order_by
  stddev_samp: item_stddev_samp_order_by
  sum: item_sum_order_by
  var_pop: item_var_pop_order_by
  var_samp: item_var_samp_order_by
  variance: item_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input item_append_input {
  object: jsonb
}

# input type for inserting array relation for remote table "item"
input item_arr_rel_insert_input {
  data: [item_insert_input!]!
  on_conflict: item_on_conflict
}

# aggregate avg on columns
type item_avg_fields {
  id: Float
}

# order by avg() on columns of table "item"
input item_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "item". All fields are combined with a logical 'AND'.
input item_bool_exp {
  _and: [item_bool_exp]
  _not: item_bool_exp
  _or: [item_bool_exp]
  bundle: item_bundle_map_bool_exp
  class: enum_item_class_enum_comparison_exp
  id: Int_comparison_exp
  itemVariants: item_variant_bool_exp
  labelTemplates: label_template_map_bool_exp
  labels: label_bool_exp
  manufacturerItems: manufacturer_item_bool_exp
  object: jsonb_comparison_exp
  orderItems: order_item_bool_exp
  vendorItems: vendor_item_bool_exp
}

# for items purchased as a bundle or kit (a box of screws for example)
#
#
# columns and relationships of "item.bundle"
type item_bundle {
  created_at: timestamptz!
  description: String
  id: Int!

  # An object relationship
  item: item!

  # An array relationship
  items(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): [item_bundle_map!]!

  # An aggregated array relationship
  items_aggregate(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): item_bundle_map_aggregate!
  name: String!
  updated_at: timestamptz!
}

# aggregated selection of "item.bundle"
type item_bundle_aggregate {
  aggregate: item_bundle_aggregate_fields
  nodes: [item_bundle!]!
}

# aggregate fields of "item.bundle"
type item_bundle_aggregate_fields {
  avg: item_bundle_avg_fields
  count(columns: [item_bundle_select_column!], distinct: Boolean): Int
  max: item_bundle_max_fields
  min: item_bundle_min_fields
  stddev: item_bundle_stddev_fields
  stddev_pop: item_bundle_stddev_pop_fields
  stddev_samp: item_bundle_stddev_samp_fields
  sum: item_bundle_sum_fields
  var_pop: item_bundle_var_pop_fields
  var_samp: item_bundle_var_samp_fields
  variance: item_bundle_variance_fields
}

# order by aggregate values of table "item.bundle"
input item_bundle_aggregate_order_by {
  avg: item_bundle_avg_order_by
  count: order_by
  max: item_bundle_max_order_by
  min: item_bundle_min_order_by
  stddev: item_bundle_stddev_order_by
  stddev_pop: item_bundle_stddev_pop_order_by
  stddev_samp: item_bundle_stddev_samp_order_by
  sum: item_bundle_sum_order_by
  var_pop: item_bundle_var_pop_order_by
  var_samp: item_bundle_var_samp_order_by
  variance: item_bundle_variance_order_by
}

# input type for inserting array relation for remote table "item.bundle"
input item_bundle_arr_rel_insert_input {
  data: [item_bundle_insert_input!]!
  on_conflict: item_bundle_on_conflict
}

# aggregate avg on columns
type item_bundle_avg_fields {
  id: Float
}

# order by avg() on columns of table "item.bundle"
input item_bundle_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "item.bundle". All fields are combined with a logical 'AND'.
input item_bundle_bool_exp {
  _and: [item_bundle_bool_exp]
  _not: item_bundle_bool_exp
  _or: [item_bundle_bool_exp]
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  item: item_bool_exp
  items: item_bundle_map_bool_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "item.bundle"
enum item_bundle_constraint {
  # unique or primary key constraint
  item_bundle_name_key

  # unique or primary key constraint
  item_bundle_pkey
}

# input type for incrementing integer column in table "item.bundle"
input item_bundle_inc_input {
  id: Int
}

# input type for inserting data into table "item.bundle"
input item_bundle_insert_input {
  created_at: timestamptz
  description: String
  id: Int
  item: item_obj_rel_insert_input
  items: item_bundle_map_arr_rel_insert_input
  name: String
  updated_at: timestamptz
}

# columns and relationships of "item.bundle_map"
type item_bundle_map {
  # An object relationship
  bundle: item_bundle!

  # An object relationship
  item: item!
  item_bundle_id: Int!
  item_member_id: Int!
  quantity: numeric
}

# aggregated selection of "item.bundle_map"
type item_bundle_map_aggregate {
  aggregate: item_bundle_map_aggregate_fields
  nodes: [item_bundle_map!]!
}

# aggregate fields of "item.bundle_map"
type item_bundle_map_aggregate_fields {
  avg: item_bundle_map_avg_fields
  count(columns: [item_bundle_map_select_column!], distinct: Boolean): Int
  max: item_bundle_map_max_fields
  min: item_bundle_map_min_fields
  stddev: item_bundle_map_stddev_fields
  stddev_pop: item_bundle_map_stddev_pop_fields
  stddev_samp: item_bundle_map_stddev_samp_fields
  sum: item_bundle_map_sum_fields
  var_pop: item_bundle_map_var_pop_fields
  var_samp: item_bundle_map_var_samp_fields
  variance: item_bundle_map_variance_fields
}

# order by aggregate values of table "item.bundle_map"
input item_bundle_map_aggregate_order_by {
  avg: item_bundle_map_avg_order_by
  count: order_by
  max: item_bundle_map_max_order_by
  min: item_bundle_map_min_order_by
  stddev: item_bundle_map_stddev_order_by
  stddev_pop: item_bundle_map_stddev_pop_order_by
  stddev_samp: item_bundle_map_stddev_samp_order_by
  sum: item_bundle_map_sum_order_by
  var_pop: item_bundle_map_var_pop_order_by
  var_samp: item_bundle_map_var_samp_order_by
  variance: item_bundle_map_variance_order_by
}

# input type for inserting array relation for remote table "item.bundle_map"
input item_bundle_map_arr_rel_insert_input {
  data: [item_bundle_map_insert_input!]!
  on_conflict: item_bundle_map_on_conflict
}

# aggregate avg on columns
type item_bundle_map_avg_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by avg() on columns of table "item.bundle_map"
input item_bundle_map_avg_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# Boolean expression to filter rows from the table "item.bundle_map". All fields are combined with a logical 'AND'.
input item_bundle_map_bool_exp {
  _and: [item_bundle_map_bool_exp]
  _not: item_bundle_map_bool_exp
  _or: [item_bundle_map_bool_exp]
  bundle: item_bundle_bool_exp
  item: item_bool_exp
  item_bundle_id: Int_comparison_exp
  item_member_id: Int_comparison_exp
  quantity: numeric_comparison_exp
}

# unique or primary key constraints on table "item.bundle_map"
enum item_bundle_map_constraint {
  # unique or primary key constraint
  item_bundle_map_pkey
}

# input type for incrementing integer column in table "item.bundle_map"
input item_bundle_map_inc_input {
  item_bundle_id: Int
  item_member_id: Int
  quantity: numeric
}

# input type for inserting data into table "item.bundle_map"
input item_bundle_map_insert_input {
  bundle: item_bundle_obj_rel_insert_input
  item: item_obj_rel_insert_input
  item_bundle_id: Int
  item_member_id: Int
  quantity: numeric
}

# aggregate max on columns
type item_bundle_map_max_fields {
  item_bundle_id: Int
  item_member_id: Int
  quantity: numeric
}

# order by max() on columns of table "item.bundle_map"
input item_bundle_map_max_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate min on columns
type item_bundle_map_min_fields {
  item_bundle_id: Int
  item_member_id: Int
  quantity: numeric
}

# order by min() on columns of table "item.bundle_map"
input item_bundle_map_min_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# response of any mutation on the table "item.bundle_map"
type item_bundle_map_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_bundle_map!]!
}

# input type for inserting object relation for remote table "item.bundle_map"
input item_bundle_map_obj_rel_insert_input {
  data: item_bundle_map_insert_input!
  on_conflict: item_bundle_map_on_conflict
}

# on conflict condition type for table "item.bundle_map"
input item_bundle_map_on_conflict {
  constraint: item_bundle_map_constraint!
  update_columns: [item_bundle_map_update_column!]!
  where: item_bundle_map_bool_exp
}

# ordering options when selecting data from "item.bundle_map"
input item_bundle_map_order_by {
  bundle: item_bundle_order_by
  item: item_order_by
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# primary key columns input for table: "item.bundle_map"
input item_bundle_map_pk_columns_input {
  item_bundle_id: Int!
  item_member_id: Int!
}

# select columns of table "item.bundle_map"
enum item_bundle_map_select_column {
  # column name
  item_bundle_id

  # column name
  item_member_id

  # column name
  quantity
}

# input type for updating data in table "item.bundle_map"
input item_bundle_map_set_input {
  item_bundle_id: Int
  item_member_id: Int
  quantity: numeric
}

# aggregate stddev on columns
type item_bundle_map_stddev_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by stddev() on columns of table "item.bundle_map"
input item_bundle_map_stddev_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate stddev_pop on columns
type item_bundle_map_stddev_pop_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by stddev_pop() on columns of table "item.bundle_map"
input item_bundle_map_stddev_pop_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate stddev_samp on columns
type item_bundle_map_stddev_samp_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by stddev_samp() on columns of table "item.bundle_map"
input item_bundle_map_stddev_samp_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate sum on columns
type item_bundle_map_sum_fields {
  item_bundle_id: Int
  item_member_id: Int
  quantity: numeric
}

# order by sum() on columns of table "item.bundle_map"
input item_bundle_map_sum_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# update columns of table "item.bundle_map"
enum item_bundle_map_update_column {
  # column name
  item_bundle_id

  # column name
  item_member_id

  # column name
  quantity
}

# aggregate var_pop on columns
type item_bundle_map_var_pop_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by var_pop() on columns of table "item.bundle_map"
input item_bundle_map_var_pop_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate var_samp on columns
type item_bundle_map_var_samp_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by var_samp() on columns of table "item.bundle_map"
input item_bundle_map_var_samp_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate variance on columns
type item_bundle_map_variance_fields {
  item_bundle_id: Float
  item_member_id: Float
  quantity: Float
}

# order by variance() on columns of table "item.bundle_map"
input item_bundle_map_variance_order_by {
  item_bundle_id: order_by
  item_member_id: order_by
  quantity: order_by
}

# aggregate max on columns
type item_bundle_max_fields {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

# order by max() on columns of table "item.bundle"
input item_bundle_max_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# aggregate min on columns
type item_bundle_min_fields {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

# order by min() on columns of table "item.bundle"
input item_bundle_min_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# response of any mutation on the table "item.bundle"
type item_bundle_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_bundle!]!
}

# input type for inserting object relation for remote table "item.bundle"
input item_bundle_obj_rel_insert_input {
  data: item_bundle_insert_input!
  on_conflict: item_bundle_on_conflict
}

# on conflict condition type for table "item.bundle"
input item_bundle_on_conflict {
  constraint: item_bundle_constraint!
  update_columns: [item_bundle_update_column!]!
  where: item_bundle_bool_exp
}

# ordering options when selecting data from "item.bundle"
input item_bundle_order_by {
  created_at: order_by
  description: order_by
  id: order_by
  item: item_order_by
  items_aggregate: item_bundle_map_aggregate_order_by
  name: order_by
  updated_at: order_by
}

# primary key columns input for table: "item.bundle"
input item_bundle_pk_columns_input {
  id: Int!
}

# select columns of table "item.bundle"
enum item_bundle_select_column {
  # column name
  created_at

  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# input type for updating data in table "item.bundle"
input item_bundle_set_input {
  created_at: timestamptz
  description: String
  id: Int
  name: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type item_bundle_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "item.bundle"
input item_bundle_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type item_bundle_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "item.bundle"
input item_bundle_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type item_bundle_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "item.bundle"
input item_bundle_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type item_bundle_sum_fields {
  id: Int
}

# order by sum() on columns of table "item.bundle"
input item_bundle_sum_order_by {
  id: order_by
}

# update columns of table "item.bundle"
enum item_bundle_update_column {
  # column name
  created_at

  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# aggregate var_pop on columns
type item_bundle_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "item.bundle"
input item_bundle_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type item_bundle_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "item.bundle"
input item_bundle_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type item_bundle_variance_fields {
  id: Float
}

# order by variance() on columns of table "item.bundle"
input item_bundle_variance_order_by {
  id: order_by
}

# electrically conductive cables (cables consist of multiple wires) 
#
#
# columns and relationships of "item.cable_conductive"
type item_cable_conductive {
  cable_diameter: numeric
  cable_sheath_material: String
  conductor_count: Int!
  conductor_diameter: numeric
  conductor_diameter_label: String
  conductor_material: String
  conductor_sheath_material: String
  connector_a: String!
  connector_b: String!
  connector_extra(
    # JSON select path
    path: String
  ): jsonb
  fire_rating: String
  id: Int!
  length: numeric
  max_frequency: Int
  name: String!
  sheath_max_temperature: numeric
  sheath_type: String
  shield_material: String
  smoke_rating: String
  standards_met(
    # JSON select path
    path: String
  ): jsonb
  strand_count: Int
  unit: enum_unit_enum!
}

# aggregated selection of "item.cable_conductive"
type item_cable_conductive_aggregate {
  aggregate: item_cable_conductive_aggregate_fields
  nodes: [item_cable_conductive!]!
}

# aggregate fields of "item.cable_conductive"
type item_cable_conductive_aggregate_fields {
  avg: item_cable_conductive_avg_fields
  count(columns: [item_cable_conductive_select_column!], distinct: Boolean): Int
  max: item_cable_conductive_max_fields
  min: item_cable_conductive_min_fields
  stddev: item_cable_conductive_stddev_fields
  stddev_pop: item_cable_conductive_stddev_pop_fields
  stddev_samp: item_cable_conductive_stddev_samp_fields
  sum: item_cable_conductive_sum_fields
  var_pop: item_cable_conductive_var_pop_fields
  var_samp: item_cable_conductive_var_samp_fields
  variance: item_cable_conductive_variance_fields
}

# order by aggregate values of table "item.cable_conductive"
input item_cable_conductive_aggregate_order_by {
  avg: item_cable_conductive_avg_order_by
  count: order_by
  max: item_cable_conductive_max_order_by
  min: item_cable_conductive_min_order_by
  stddev: item_cable_conductive_stddev_order_by
  stddev_pop: item_cable_conductive_stddev_pop_order_by
  stddev_samp: item_cable_conductive_stddev_samp_order_by
  sum: item_cable_conductive_sum_order_by
  var_pop: item_cable_conductive_var_pop_order_by
  var_samp: item_cable_conductive_var_samp_order_by
  variance: item_cable_conductive_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input item_cable_conductive_append_input {
  connector_extra: jsonb
  standards_met: jsonb
}

# input type for inserting array relation for remote table "item.cable_conductive"
input item_cable_conductive_arr_rel_insert_input {
  data: [item_cable_conductive_insert_input!]!
  on_conflict: item_cable_conductive_on_conflict
}

# aggregate avg on columns
type item_cable_conductive_avg_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by avg() on columns of table "item.cable_conductive"
input item_cable_conductive_avg_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# Boolean expression to filter rows from the table "item.cable_conductive". All fields are combined with a logical 'AND'.
input item_cable_conductive_bool_exp {
  _and: [item_cable_conductive_bool_exp]
  _not: item_cable_conductive_bool_exp
  _or: [item_cable_conductive_bool_exp]
  cable_diameter: numeric_comparison_exp
  cable_sheath_material: String_comparison_exp
  conductor_count: Int_comparison_exp
  conductor_diameter: numeric_comparison_exp
  conductor_diameter_label: String_comparison_exp
  conductor_material: String_comparison_exp
  conductor_sheath_material: String_comparison_exp
  connector_a: String_comparison_exp
  connector_b: String_comparison_exp
  connector_extra: jsonb_comparison_exp
  fire_rating: String_comparison_exp
  id: Int_comparison_exp
  length: numeric_comparison_exp
  max_frequency: Int_comparison_exp
  name: String_comparison_exp
  sheath_max_temperature: numeric_comparison_exp
  sheath_type: String_comparison_exp
  shield_material: String_comparison_exp
  smoke_rating: String_comparison_exp
  standards_met: jsonb_comparison_exp
  strand_count: Int_comparison_exp
  unit: enum_unit_enum_comparison_exp
}

# unique or primary key constraints on table "item.cable_conductive"
enum item_cable_conductive_constraint {
  # unique or primary key constraint
  conductive_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input item_cable_conductive_delete_at_path_input {
  connector_extra: [String]
  standards_met: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input item_cable_conductive_delete_elem_input {
  connector_extra: Int
  standards_met: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input item_cable_conductive_delete_key_input {
  connector_extra: String
  standards_met: String
}

# input type for incrementing integer column in table "item.cable_conductive"
input item_cable_conductive_inc_input {
  cable_diameter: numeric
  conductor_count: Int
  conductor_diameter: numeric
  id: Int
  length: numeric
  max_frequency: Int
  sheath_max_temperature: numeric
  strand_count: Int
}

# input type for inserting data into table "item.cable_conductive"
input item_cable_conductive_insert_input {
  cable_diameter: numeric
  cable_sheath_material: String
  conductor_count: Int
  conductor_diameter: numeric
  conductor_diameter_label: String
  conductor_material: String
  conductor_sheath_material: String
  connector_a: String
  connector_b: String
  connector_extra: jsonb
  fire_rating: String
  id: Int
  length: numeric
  max_frequency: Int
  name: String
  sheath_max_temperature: numeric
  sheath_type: String
  shield_material: String
  smoke_rating: String
  standards_met: jsonb
  strand_count: Int
  unit: enum_unit_enum
}

# aggregate max on columns
type item_cable_conductive_max_fields {
  cable_diameter: numeric
  cable_sheath_material: String
  conductor_count: Int
  conductor_diameter: numeric
  conductor_diameter_label: String
  conductor_material: String
  conductor_sheath_material: String
  connector_a: String
  connector_b: String
  fire_rating: String
  id: Int
  length: numeric
  max_frequency: Int
  name: String
  sheath_max_temperature: numeric
  sheath_type: String
  shield_material: String
  smoke_rating: String
  strand_count: Int
}

# order by max() on columns of table "item.cable_conductive"
input item_cable_conductive_max_order_by {
  cable_diameter: order_by
  cable_sheath_material: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  conductor_diameter_label: order_by
  conductor_material: order_by
  conductor_sheath_material: order_by
  connector_a: order_by
  connector_b: order_by
  fire_rating: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  name: order_by
  sheath_max_temperature: order_by
  sheath_type: order_by
  shield_material: order_by
  smoke_rating: order_by
  strand_count: order_by
}

# aggregate min on columns
type item_cable_conductive_min_fields {
  cable_diameter: numeric
  cable_sheath_material: String
  conductor_count: Int
  conductor_diameter: numeric
  conductor_diameter_label: String
  conductor_material: String
  conductor_sheath_material: String
  connector_a: String
  connector_b: String
  fire_rating: String
  id: Int
  length: numeric
  max_frequency: Int
  name: String
  sheath_max_temperature: numeric
  sheath_type: String
  shield_material: String
  smoke_rating: String
  strand_count: Int
}

# order by min() on columns of table "item.cable_conductive"
input item_cable_conductive_min_order_by {
  cable_diameter: order_by
  cable_sheath_material: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  conductor_diameter_label: order_by
  conductor_material: order_by
  conductor_sheath_material: order_by
  connector_a: order_by
  connector_b: order_by
  fire_rating: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  name: order_by
  sheath_max_temperature: order_by
  sheath_type: order_by
  shield_material: order_by
  smoke_rating: order_by
  strand_count: order_by
}

# response of any mutation on the table "item.cable_conductive"
type item_cable_conductive_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_cable_conductive!]!
}

# input type for inserting object relation for remote table "item.cable_conductive"
input item_cable_conductive_obj_rel_insert_input {
  data: item_cable_conductive_insert_input!
  on_conflict: item_cable_conductive_on_conflict
}

# on conflict condition type for table "item.cable_conductive"
input item_cable_conductive_on_conflict {
  constraint: item_cable_conductive_constraint!
  update_columns: [item_cable_conductive_update_column!]!
  where: item_cable_conductive_bool_exp
}

# ordering options when selecting data from "item.cable_conductive"
input item_cable_conductive_order_by {
  cable_diameter: order_by
  cable_sheath_material: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  conductor_diameter_label: order_by
  conductor_material: order_by
  conductor_sheath_material: order_by
  connector_a: order_by
  connector_b: order_by
  connector_extra: order_by
  fire_rating: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  name: order_by
  sheath_max_temperature: order_by
  sheath_type: order_by
  shield_material: order_by
  smoke_rating: order_by
  standards_met: order_by
  strand_count: order_by
  unit: order_by
}

# primary key columns input for table: "item.cable_conductive"
input item_cable_conductive_pk_columns_input {
  id: Int!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input item_cable_conductive_prepend_input {
  connector_extra: jsonb
  standards_met: jsonb
}

# select columns of table "item.cable_conductive"
enum item_cable_conductive_select_column {
  # column name
  cable_diameter

  # column name
  cable_sheath_material

  # column name
  conductor_count

  # column name
  conductor_diameter

  # column name
  conductor_diameter_label

  # column name
  conductor_material

  # column name
  conductor_sheath_material

  # column name
  connector_a

  # column name
  connector_b

  # column name
  connector_extra

  # column name
  fire_rating

  # column name
  id

  # column name
  length

  # column name
  max_frequency

  # column name
  name

  # column name
  sheath_max_temperature

  # column name
  sheath_type

  # column name
  shield_material

  # column name
  smoke_rating

  # column name
  standards_met

  # column name
  strand_count

  # column name
  unit
}

# input type for updating data in table "item.cable_conductive"
input item_cable_conductive_set_input {
  cable_diameter: numeric
  cable_sheath_material: String
  conductor_count: Int
  conductor_diameter: numeric
  conductor_diameter_label: String
  conductor_material: String
  conductor_sheath_material: String
  connector_a: String
  connector_b: String
  connector_extra: jsonb
  fire_rating: String
  id: Int
  length: numeric
  max_frequency: Int
  name: String
  sheath_max_temperature: numeric
  sheath_type: String
  shield_material: String
  smoke_rating: String
  standards_met: jsonb
  strand_count: Int
  unit: enum_unit_enum
}

# aggregate stddev on columns
type item_cable_conductive_stddev_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by stddev() on columns of table "item.cable_conductive"
input item_cable_conductive_stddev_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# aggregate stddev_pop on columns
type item_cable_conductive_stddev_pop_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by stddev_pop() on columns of table "item.cable_conductive"
input item_cable_conductive_stddev_pop_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# aggregate stddev_samp on columns
type item_cable_conductive_stddev_samp_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by stddev_samp() on columns of table "item.cable_conductive"
input item_cable_conductive_stddev_samp_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# aggregate sum on columns
type item_cable_conductive_sum_fields {
  cable_diameter: numeric
  conductor_count: Int
  conductor_diameter: numeric
  id: Int
  length: numeric
  max_frequency: Int
  sheath_max_temperature: numeric
  strand_count: Int
}

# order by sum() on columns of table "item.cable_conductive"
input item_cable_conductive_sum_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# update columns of table "item.cable_conductive"
enum item_cable_conductive_update_column {
  # column name
  cable_diameter

  # column name
  cable_sheath_material

  # column name
  conductor_count

  # column name
  conductor_diameter

  # column name
  conductor_diameter_label

  # column name
  conductor_material

  # column name
  conductor_sheath_material

  # column name
  connector_a

  # column name
  connector_b

  # column name
  connector_extra

  # column name
  fire_rating

  # column name
  id

  # column name
  length

  # column name
  max_frequency

  # column name
  name

  # column name
  sheath_max_temperature

  # column name
  sheath_type

  # column name
  shield_material

  # column name
  smoke_rating

  # column name
  standards_met

  # column name
  strand_count

  # column name
  unit
}

# aggregate var_pop on columns
type item_cable_conductive_var_pop_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by var_pop() on columns of table "item.cable_conductive"
input item_cable_conductive_var_pop_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# aggregate var_samp on columns
type item_cable_conductive_var_samp_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by var_samp() on columns of table "item.cable_conductive"
input item_cable_conductive_var_samp_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# aggregate variance on columns
type item_cable_conductive_variance_fields {
  cable_diameter: Float
  conductor_count: Float
  conductor_diameter: Float
  id: Float
  length: Float
  max_frequency: Float
  sheath_max_temperature: Float
  strand_count: Float
}

# order by variance() on columns of table "item.cable_conductive"
input item_cable_conductive_variance_order_by {
  cable_diameter: order_by
  conductor_count: order_by
  conductor_diameter: order_by
  id: order_by
  length: order_by
  max_frequency: order_by
  sheath_max_temperature: order_by
  strand_count: order_by
}

# unique or primary key constraints on table "item"
enum item_constraint {
  # unique or primary key constraint
  item_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input item_delete_at_path_input {
  object: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input item_delete_elem_input {
  object: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input item_delete_key_input {
  object: String
}

# columns and relationships of "item.hardware_drill_bit"
type item_hardware_drill_bit {
  diameter: numeric!
  finish: String

  # NOTE: CAN BE DEFAULT
  flute_direction: enum_item_handedness_enum!

  # NOTE: CAN BE DEFAULT
  hammer: Boolean!
  id: Int!
  label: String
  length: numeric!

  # NOTE: CAN BE DEFAULT
  length_class: String
  material: String
  maximum_drilling_depth: numeric
  name: String!
  point: String
  point_angle: numeric
  shank: String!
  shank_size: numeric
  specifications_met(
    # JSON select path
    path: String
  ): jsonb
  style: String
  unit: String!
  use_material(
    # JSON select path
    path: String
  ): jsonb
}

# aggregated selection of "item.hardware_drill_bit"
type item_hardware_drill_bit_aggregate {
  aggregate: item_hardware_drill_bit_aggregate_fields
  nodes: [item_hardware_drill_bit!]!
}

# aggregate fields of "item.hardware_drill_bit"
type item_hardware_drill_bit_aggregate_fields {
  avg: item_hardware_drill_bit_avg_fields
  count(columns: [item_hardware_drill_bit_select_column!], distinct: Boolean): Int
  max: item_hardware_drill_bit_max_fields
  min: item_hardware_drill_bit_min_fields
  stddev: item_hardware_drill_bit_stddev_fields
  stddev_pop: item_hardware_drill_bit_stddev_pop_fields
  stddev_samp: item_hardware_drill_bit_stddev_samp_fields
  sum: item_hardware_drill_bit_sum_fields
  var_pop: item_hardware_drill_bit_var_pop_fields
  var_samp: item_hardware_drill_bit_var_samp_fields
  variance: item_hardware_drill_bit_variance_fields
}

# order by aggregate values of table "item.hardware_drill_bit"
input item_hardware_drill_bit_aggregate_order_by {
  avg: item_hardware_drill_bit_avg_order_by
  count: order_by
  max: item_hardware_drill_bit_max_order_by
  min: item_hardware_drill_bit_min_order_by
  stddev: item_hardware_drill_bit_stddev_order_by
  stddev_pop: item_hardware_drill_bit_stddev_pop_order_by
  stddev_samp: item_hardware_drill_bit_stddev_samp_order_by
  sum: item_hardware_drill_bit_sum_order_by
  var_pop: item_hardware_drill_bit_var_pop_order_by
  var_samp: item_hardware_drill_bit_var_samp_order_by
  variance: item_hardware_drill_bit_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input item_hardware_drill_bit_append_input {
  specifications_met: jsonb
  use_material: jsonb
}

# input type for inserting array relation for remote table "item.hardware_drill_bit"
input item_hardware_drill_bit_arr_rel_insert_input {
  data: [item_hardware_drill_bit_insert_input!]!
  on_conflict: item_hardware_drill_bit_on_conflict
}

# aggregate avg on columns
type item_hardware_drill_bit_avg_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by avg() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_avg_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# Boolean expression to filter rows from the table "item.hardware_drill_bit". All fields are combined with a logical 'AND'.
input item_hardware_drill_bit_bool_exp {
  _and: [item_hardware_drill_bit_bool_exp]
  _not: item_hardware_drill_bit_bool_exp
  _or: [item_hardware_drill_bit_bool_exp]
  diameter: numeric_comparison_exp
  finish: String_comparison_exp
  flute_direction: enum_item_handedness_enum_comparison_exp
  hammer: Boolean_comparison_exp
  id: Int_comparison_exp
  label: String_comparison_exp
  length: numeric_comparison_exp
  length_class: String_comparison_exp
  material: String_comparison_exp
  maximum_drilling_depth: numeric_comparison_exp
  name: String_comparison_exp
  point: String_comparison_exp
  point_angle: numeric_comparison_exp
  shank: String_comparison_exp
  shank_size: numeric_comparison_exp
  specifications_met: jsonb_comparison_exp
  style: String_comparison_exp
  unit: String_comparison_exp
  use_material: jsonb_comparison_exp
}

# unique or primary key constraints on table "item.hardware_drill_bit"
enum item_hardware_drill_bit_constraint {
  # unique or primary key constraint
  hardware_drill_bit_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input item_hardware_drill_bit_delete_at_path_input {
  specifications_met: [String]
  use_material: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input item_hardware_drill_bit_delete_elem_input {
  specifications_met: Int
  use_material: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input item_hardware_drill_bit_delete_key_input {
  specifications_met: String
  use_material: String
}

# input type for incrementing integer column in table "item.hardware_drill_bit"
input item_hardware_drill_bit_inc_input {
  diameter: numeric
  id: Int
  length: numeric
  maximum_drilling_depth: numeric
  point_angle: numeric
  shank_size: numeric
}

# input type for inserting data into table "item.hardware_drill_bit"
input item_hardware_drill_bit_insert_input {
  diameter: numeric
  finish: String
  flute_direction: enum_item_handedness_enum
  hammer: Boolean
  id: Int
  label: String
  length: numeric
  length_class: String
  material: String
  maximum_drilling_depth: numeric
  name: String
  point: String
  point_angle: numeric
  shank: String
  shank_size: numeric
  specifications_met: jsonb
  style: String
  unit: String
  use_material: jsonb
}

# aggregate max on columns
type item_hardware_drill_bit_max_fields {
  diameter: numeric
  finish: String
  id: Int
  label: String
  length: numeric
  length_class: String
  material: String
  maximum_drilling_depth: numeric
  name: String
  point: String
  point_angle: numeric
  shank: String
  shank_size: numeric
  style: String
  unit: String
}

# order by max() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_max_order_by {
  diameter: order_by
  finish: order_by
  id: order_by
  label: order_by
  length: order_by
  length_class: order_by
  material: order_by
  maximum_drilling_depth: order_by
  name: order_by
  point: order_by
  point_angle: order_by
  shank: order_by
  shank_size: order_by
  style: order_by
  unit: order_by
}

# aggregate min on columns
type item_hardware_drill_bit_min_fields {
  diameter: numeric
  finish: String
  id: Int
  label: String
  length: numeric
  length_class: String
  material: String
  maximum_drilling_depth: numeric
  name: String
  point: String
  point_angle: numeric
  shank: String
  shank_size: numeric
  style: String
  unit: String
}

# order by min() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_min_order_by {
  diameter: order_by
  finish: order_by
  id: order_by
  label: order_by
  length: order_by
  length_class: order_by
  material: order_by
  maximum_drilling_depth: order_by
  name: order_by
  point: order_by
  point_angle: order_by
  shank: order_by
  shank_size: order_by
  style: order_by
  unit: order_by
}

# response of any mutation on the table "item.hardware_drill_bit"
type item_hardware_drill_bit_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_drill_bit!]!
}

# input type for inserting object relation for remote table "item.hardware_drill_bit"
input item_hardware_drill_bit_obj_rel_insert_input {
  data: item_hardware_drill_bit_insert_input!
  on_conflict: item_hardware_drill_bit_on_conflict
}

# on conflict condition type for table "item.hardware_drill_bit"
input item_hardware_drill_bit_on_conflict {
  constraint: item_hardware_drill_bit_constraint!
  update_columns: [item_hardware_drill_bit_update_column!]!
  where: item_hardware_drill_bit_bool_exp
}

# ordering options when selecting data from "item.hardware_drill_bit"
input item_hardware_drill_bit_order_by {
  diameter: order_by
  finish: order_by
  flute_direction: order_by
  hammer: order_by
  id: order_by
  label: order_by
  length: order_by
  length_class: order_by
  material: order_by
  maximum_drilling_depth: order_by
  name: order_by
  point: order_by
  point_angle: order_by
  shank: order_by
  shank_size: order_by
  specifications_met: order_by
  style: order_by
  unit: order_by
  use_material: order_by
}

# primary key columns input for table: "item.hardware_drill_bit"
input item_hardware_drill_bit_pk_columns_input {
  id: Int!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input item_hardware_drill_bit_prepend_input {
  specifications_met: jsonb
  use_material: jsonb
}

# select columns of table "item.hardware_drill_bit"
enum item_hardware_drill_bit_select_column {
  # column name
  diameter

  # column name
  finish

  # column name
  flute_direction

  # column name
  hammer

  # column name
  id

  # column name
  label

  # column name
  length

  # column name
  length_class

  # column name
  material

  # column name
  maximum_drilling_depth

  # column name
  name

  # column name
  point

  # column name
  point_angle

  # column name
  shank

  # column name
  shank_size

  # column name
  specifications_met

  # column name
  style

  # column name
  unit

  # column name
  use_material
}

# input type for updating data in table "item.hardware_drill_bit"
input item_hardware_drill_bit_set_input {
  diameter: numeric
  finish: String
  flute_direction: enum_item_handedness_enum
  hammer: Boolean
  id: Int
  label: String
  length: numeric
  length_class: String
  material: String
  maximum_drilling_depth: numeric
  name: String
  point: String
  point_angle: numeric
  shank: String
  shank_size: numeric
  specifications_met: jsonb
  style: String
  unit: String
  use_material: jsonb
}

# aggregate stddev on columns
type item_hardware_drill_bit_stddev_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by stddev() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_stddev_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# aggregate stddev_pop on columns
type item_hardware_drill_bit_stddev_pop_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by stddev_pop() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_stddev_pop_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# aggregate stddev_samp on columns
type item_hardware_drill_bit_stddev_samp_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by stddev_samp() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_stddev_samp_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# aggregate sum on columns
type item_hardware_drill_bit_sum_fields {
  diameter: numeric
  id: Int
  length: numeric
  maximum_drilling_depth: numeric
  point_angle: numeric
  shank_size: numeric
}

# order by sum() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_sum_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# update columns of table "item.hardware_drill_bit"
enum item_hardware_drill_bit_update_column {
  # column name
  diameter

  # column name
  finish

  # column name
  flute_direction

  # column name
  hammer

  # column name
  id

  # column name
  label

  # column name
  length

  # column name
  length_class

  # column name
  material

  # column name
  maximum_drilling_depth

  # column name
  name

  # column name
  point

  # column name
  point_angle

  # column name
  shank

  # column name
  shank_size

  # column name
  specifications_met

  # column name
  style

  # column name
  unit

  # column name
  use_material
}

# aggregate var_pop on columns
type item_hardware_drill_bit_var_pop_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by var_pop() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_var_pop_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# aggregate var_samp on columns
type item_hardware_drill_bit_var_samp_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by var_samp() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_var_samp_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# aggregate variance on columns
type item_hardware_drill_bit_variance_fields {
  diameter: Float
  id: Float
  length: Float
  maximum_drilling_depth: Float
  point_angle: Float
  shank_size: Float
}

# order by variance() on columns of table "item.hardware_drill_bit"
input item_hardware_drill_bit_variance_order_by {
  diameter: order_by
  id: order_by
  length: order_by
  maximum_drilling_depth: order_by
  point_angle: order_by
  shank_size: order_by
}

# columns and relationships of "item.hardware_fastener_insert"
type item_hardware_fastener_insert {
  id: Int!
  name: String!
}

# aggregated selection of "item.hardware_fastener_insert"
type item_hardware_fastener_insert_aggregate {
  aggregate: item_hardware_fastener_insert_aggregate_fields
  nodes: [item_hardware_fastener_insert!]!
}

# aggregate fields of "item.hardware_fastener_insert"
type item_hardware_fastener_insert_aggregate_fields {
  avg: item_hardware_fastener_insert_avg_fields
  count(columns: [item_hardware_fastener_insert_select_column!], distinct: Boolean): Int
  max: item_hardware_fastener_insert_max_fields
  min: item_hardware_fastener_insert_min_fields
  stddev: item_hardware_fastener_insert_stddev_fields
  stddev_pop: item_hardware_fastener_insert_stddev_pop_fields
  stddev_samp: item_hardware_fastener_insert_stddev_samp_fields
  sum: item_hardware_fastener_insert_sum_fields
  var_pop: item_hardware_fastener_insert_var_pop_fields
  var_samp: item_hardware_fastener_insert_var_samp_fields
  variance: item_hardware_fastener_insert_variance_fields
}

# order by aggregate values of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_aggregate_order_by {
  avg: item_hardware_fastener_insert_avg_order_by
  count: order_by
  max: item_hardware_fastener_insert_max_order_by
  min: item_hardware_fastener_insert_min_order_by
  stddev: item_hardware_fastener_insert_stddev_order_by
  stddev_pop: item_hardware_fastener_insert_stddev_pop_order_by
  stddev_samp: item_hardware_fastener_insert_stddev_samp_order_by
  sum: item_hardware_fastener_insert_sum_order_by
  var_pop: item_hardware_fastener_insert_var_pop_order_by
  var_samp: item_hardware_fastener_insert_var_samp_order_by
  variance: item_hardware_fastener_insert_variance_order_by
}

# input type for inserting array relation for remote table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_arr_rel_insert_input {
  data: [item_hardware_fastener_insert_insert_input!]!
  on_conflict: item_hardware_fastener_insert_on_conflict
}

# aggregate avg on columns
type item_hardware_fastener_insert_avg_fields {
  id: Float
}

# order by avg() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "item.hardware_fastener_insert". All fields are combined with a logical 'AND'.
input item_hardware_fastener_insert_bool_exp {
  _and: [item_hardware_fastener_insert_bool_exp]
  _not: item_hardware_fastener_insert_bool_exp
  _or: [item_hardware_fastener_insert_bool_exp]
  id: Int_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "item.hardware_fastener_insert"
enum item_hardware_fastener_insert_constraint {
  # unique or primary key constraint
  hardware_fastener_insert_pkey
}

# input type for incrementing integer column in table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_inc_input {
  id: Int
}

# input type for inserting data into table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_insert_input {
  id: Int
  name: String
}

# aggregate max on columns
type item_hardware_fastener_insert_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type item_hardware_fastener_insert_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "item.hardware_fastener_insert"
type item_hardware_fastener_insert_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_fastener_insert!]!
}

# input type for inserting object relation for remote table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_obj_rel_insert_input {
  data: item_hardware_fastener_insert_insert_input!
  on_conflict: item_hardware_fastener_insert_on_conflict
}

# on conflict condition type for table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_on_conflict {
  constraint: item_hardware_fastener_insert_constraint!
  update_columns: [item_hardware_fastener_insert_update_column!]!
  where: item_hardware_fastener_insert_bool_exp
}

# ordering options when selecting data from "item.hardware_fastener_insert"
input item_hardware_fastener_insert_order_by {
  id: order_by
  name: order_by
}

# primary key columns input for table: "item.hardware_fastener_insert"
input item_hardware_fastener_insert_pk_columns_input {
  id: Int!
}

# select columns of table "item.hardware_fastener_insert"
enum item_hardware_fastener_insert_select_column {
  # column name
  id

  # column name
  name
}

# input type for updating data in table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_set_input {
  id: Int
  name: String
}

# aggregate stddev on columns
type item_hardware_fastener_insert_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type item_hardware_fastener_insert_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type item_hardware_fastener_insert_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type item_hardware_fastener_insert_sum_fields {
  id: Int
}

# order by sum() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_sum_order_by {
  id: order_by
}

# update columns of table "item.hardware_fastener_insert"
enum item_hardware_fastener_insert_update_column {
  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type item_hardware_fastener_insert_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type item_hardware_fastener_insert_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type item_hardware_fastener_insert_variance_fields {
  id: Float
}

# order by variance() on columns of table "item.hardware_fastener_insert"
input item_hardware_fastener_insert_variance_order_by {
  id: order_by
}

# Nuts are used to fasten machine threaded fasteners in through-hole applications. Lock nuts help prevent loosening.
#
#
# columns and relationships of "item.hardware_fastener_nut"
type item_hardware_fastener_nut {
  description: String!
  form: enum_item_hardware_fastener_nut_form_enum!
  id: Int!
  name: String!
  strength: enum_item_hardware_fastener_nut_strength_enum
  thread_fit: enum_item_hardware_fastener_nut_thread_fit_enum
  unit: enum_unit_enum!
}

# aggregated selection of "item.hardware_fastener_nut"
type item_hardware_fastener_nut_aggregate {
  aggregate: item_hardware_fastener_nut_aggregate_fields
  nodes: [item_hardware_fastener_nut!]!
}

# aggregate fields of "item.hardware_fastener_nut"
type item_hardware_fastener_nut_aggregate_fields {
  avg: item_hardware_fastener_nut_avg_fields
  count(columns: [item_hardware_fastener_nut_select_column!], distinct: Boolean): Int
  max: item_hardware_fastener_nut_max_fields
  min: item_hardware_fastener_nut_min_fields
  stddev: item_hardware_fastener_nut_stddev_fields
  stddev_pop: item_hardware_fastener_nut_stddev_pop_fields
  stddev_samp: item_hardware_fastener_nut_stddev_samp_fields
  sum: item_hardware_fastener_nut_sum_fields
  var_pop: item_hardware_fastener_nut_var_pop_fields
  var_samp: item_hardware_fastener_nut_var_samp_fields
  variance: item_hardware_fastener_nut_variance_fields
}

# order by aggregate values of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_aggregate_order_by {
  avg: item_hardware_fastener_nut_avg_order_by
  count: order_by
  max: item_hardware_fastener_nut_max_order_by
  min: item_hardware_fastener_nut_min_order_by
  stddev: item_hardware_fastener_nut_stddev_order_by
  stddev_pop: item_hardware_fastener_nut_stddev_pop_order_by
  stddev_samp: item_hardware_fastener_nut_stddev_samp_order_by
  sum: item_hardware_fastener_nut_sum_order_by
  var_pop: item_hardware_fastener_nut_var_pop_order_by
  var_samp: item_hardware_fastener_nut_var_samp_order_by
  variance: item_hardware_fastener_nut_variance_order_by
}

# input type for inserting array relation for remote table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_arr_rel_insert_input {
  data: [item_hardware_fastener_nut_insert_input!]!
  on_conflict: item_hardware_fastener_nut_on_conflict
}

# aggregate avg on columns
type item_hardware_fastener_nut_avg_fields {
  id: Float
}

# order by avg() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "item.hardware_fastener_nut". All fields are combined with a logical 'AND'.
input item_hardware_fastener_nut_bool_exp {
  _and: [item_hardware_fastener_nut_bool_exp]
  _not: item_hardware_fastener_nut_bool_exp
  _or: [item_hardware_fastener_nut_bool_exp]
  description: String_comparison_exp
  form: enum_item_hardware_fastener_nut_form_enum_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  strength: enum_item_hardware_fastener_nut_strength_enum_comparison_exp
  thread_fit: enum_item_hardware_fastener_nut_thread_fit_enum_comparison_exp
  unit: enum_unit_enum_comparison_exp
}

# unique or primary key constraints on table "item.hardware_fastener_nut"
enum item_hardware_fastener_nut_constraint {
  # unique or primary key constraint
  items_hardware_nut_pkey
}

# input type for incrementing integer column in table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_inc_input {
  id: Int
}

# input type for inserting data into table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_insert_input {
  description: String
  form: enum_item_hardware_fastener_nut_form_enum
  id: Int
  name: String
  strength: enum_item_hardware_fastener_nut_strength_enum
  thread_fit: enum_item_hardware_fastener_nut_thread_fit_enum
  unit: enum_unit_enum
}

# aggregate max on columns
type item_hardware_fastener_nut_max_fields {
  description: String
  id: Int
  name: String
}

# order by max() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_max_order_by {
  description: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type item_hardware_fastener_nut_min_fields {
  description: String
  id: Int
  name: String
}

# order by min() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_min_order_by {
  description: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "item.hardware_fastener_nut"
type item_hardware_fastener_nut_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_fastener_nut!]!
}

# input type for inserting object relation for remote table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_obj_rel_insert_input {
  data: item_hardware_fastener_nut_insert_input!
  on_conflict: item_hardware_fastener_nut_on_conflict
}

# on conflict condition type for table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_on_conflict {
  constraint: item_hardware_fastener_nut_constraint!
  update_columns: [item_hardware_fastener_nut_update_column!]!
  where: item_hardware_fastener_nut_bool_exp
}

# ordering options when selecting data from "item.hardware_fastener_nut"
input item_hardware_fastener_nut_order_by {
  description: order_by
  form: order_by
  id: order_by
  name: order_by
  strength: order_by
  thread_fit: order_by
  unit: order_by
}

# primary key columns input for table: "item.hardware_fastener_nut"
input item_hardware_fastener_nut_pk_columns_input {
  id: Int!
}

# select columns of table "item.hardware_fastener_nut"
enum item_hardware_fastener_nut_select_column {
  # column name
  description

  # column name
  form

  # column name
  id

  # column name
  name

  # column name
  strength

  # column name
  thread_fit

  # column name
  unit
}

# input type for updating data in table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_set_input {
  description: String
  form: enum_item_hardware_fastener_nut_form_enum
  id: Int
  name: String
  strength: enum_item_hardware_fastener_nut_strength_enum
  thread_fit: enum_item_hardware_fastener_nut_thread_fit_enum
  unit: enum_unit_enum
}

# aggregate stddev on columns
type item_hardware_fastener_nut_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type item_hardware_fastener_nut_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type item_hardware_fastener_nut_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type item_hardware_fastener_nut_sum_fields {
  id: Int
}

# order by sum() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_sum_order_by {
  id: order_by
}

# update columns of table "item.hardware_fastener_nut"
enum item_hardware_fastener_nut_update_column {
  # column name
  description

  # column name
  form

  # column name
  id

  # column name
  name

  # column name
  strength

  # column name
  thread_fit

  # column name
  unit
}

# aggregate var_pop on columns
type item_hardware_fastener_nut_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type item_hardware_fastener_nut_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type item_hardware_fastener_nut_variance_fields {
  id: Float
}

# order by variance() on columns of table "item.hardware_fastener_nut"
input item_hardware_fastener_nut_variance_order_by {
  id: order_by
}

# columns and relationships of "item.hardware_fastener_screw"
type item_hardware_fastener_screw {
  description: String
  id: Int!
  name: String!
  point: enum_item_hardware_fastener_screw_machine_point_enum!
  unit: enum_unit_enum!
  use_material: enum_item_hardware_use_material_enum
}

# aggregated selection of "item.hardware_fastener_screw"
type item_hardware_fastener_screw_aggregate {
  aggregate: item_hardware_fastener_screw_aggregate_fields
  nodes: [item_hardware_fastener_screw!]!
}

# aggregate fields of "item.hardware_fastener_screw"
type item_hardware_fastener_screw_aggregate_fields {
  avg: item_hardware_fastener_screw_avg_fields
  count(columns: [item_hardware_fastener_screw_select_column!], distinct: Boolean): Int
  max: item_hardware_fastener_screw_max_fields
  min: item_hardware_fastener_screw_min_fields
  stddev: item_hardware_fastener_screw_stddev_fields
  stddev_pop: item_hardware_fastener_screw_stddev_pop_fields
  stddev_samp: item_hardware_fastener_screw_stddev_samp_fields
  sum: item_hardware_fastener_screw_sum_fields
  var_pop: item_hardware_fastener_screw_var_pop_fields
  var_samp: item_hardware_fastener_screw_var_samp_fields
  variance: item_hardware_fastener_screw_variance_fields
}

# order by aggregate values of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_aggregate_order_by {
  avg: item_hardware_fastener_screw_avg_order_by
  count: order_by
  max: item_hardware_fastener_screw_max_order_by
  min: item_hardware_fastener_screw_min_order_by
  stddev: item_hardware_fastener_screw_stddev_order_by
  stddev_pop: item_hardware_fastener_screw_stddev_pop_order_by
  stddev_samp: item_hardware_fastener_screw_stddev_samp_order_by
  sum: item_hardware_fastener_screw_sum_order_by
  var_pop: item_hardware_fastener_screw_var_pop_order_by
  var_samp: item_hardware_fastener_screw_var_samp_order_by
  variance: item_hardware_fastener_screw_variance_order_by
}

# input type for inserting array relation for remote table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_arr_rel_insert_input {
  data: [item_hardware_fastener_screw_insert_input!]!
  on_conflict: item_hardware_fastener_screw_on_conflict
}

# aggregate avg on columns
type item_hardware_fastener_screw_avg_fields {
  id: Float
}

# order by avg() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "item.hardware_fastener_screw". All fields are combined with a logical 'AND'.
input item_hardware_fastener_screw_bool_exp {
  _and: [item_hardware_fastener_screw_bool_exp]
  _not: item_hardware_fastener_screw_bool_exp
  _or: [item_hardware_fastener_screw_bool_exp]
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  point: enum_item_hardware_fastener_screw_machine_point_enum_comparison_exp
  unit: enum_unit_enum_comparison_exp
  use_material: enum_item_hardware_use_material_enum_comparison_exp
}

# unique or primary key constraints on table "item.hardware_fastener_screw"
enum item_hardware_fastener_screw_constraint {
  # unique or primary key constraint
  hardware_fastener_screw_pkey
}

# input type for incrementing integer column in table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_inc_input {
  id: Int
}

# input type for inserting data into table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_insert_input {
  description: String
  id: Int
  name: String
  point: enum_item_hardware_fastener_screw_machine_point_enum
  unit: enum_unit_enum
  use_material: enum_item_hardware_use_material_enum
}

# columns and relationships of "item.hardware_fastener_screw_machine"
type item_hardware_fastener_screw_machine {
  countersunk_angle: numeric

  # Any value here means it is countersunk; A value != the `head_height` means it is only partially countersunk
  countersunk_height: numeric
  default_fields(
    # JSON select path
    path: String
  ): jsonb
  description: String
  drive_size: String
  drive_type: enum_item_hardware_fastener_drive_enum!

  # This is what is typically stated as a fastener's length. Length of bolt that is within the material it is screwed into
  embedded_length: numeric!

  # Coating
  finish: enum_item_hardware_finish_enum
  hardness: enum_item_hardware_fastener_screw_hardness_enum
  head_diameter: numeric
  head_height: numeric
  head_type: enum_item_hardware_fastener_screw_head_enum!
  id: Int!

  # Material, such as Zinc coated steel or Stainless Steel
  material: enum_item_hardware_fastener_material_enum
  name: String!
  point_type: enum_item_hardware_fastener_screw_machine_point_enum

  # Specifications Met ; array of Organizations that certified this
  # Examples:
  # ASME
  # DIN
  # ISO
  # ASTM
  # Mil. Spec.
  # Fed. Spec.
  # NAS
  # JIS
  specifications_met(
    # JSON select path
    path: String
  ): jsonb
  strength_class: enum_item_hardware_fastener_screw_machine_strength_enum

  # psi
  tensile_strength: numeric

  # ie. M3 or #6. Measure of the outer diameter. For US items, diameters smaller than ¼" get #<numbers>
  thread_diameter: numeric!
  thread_direction: enum_item_handedness_enum
  thread_fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  thread_label: enum_item_hardware_fastener_thread_label_enum

  # if fully threaded, this should be === `shaft_length`
  thread_length: numeric

  # TPI for usc, Pitch for metric ; ie. the 0.5 in M3 x 0.5
  thread_pitch: numeric!
  thread_standard: enum_item_hardware_fastener_thread_standard_enum!

  # ENUM:Unit
  unit: enum_unit_enum!

  # Material this fastener is meant to thread into.
  use_material: enum_item_hardware_use_material_enum
}

# aggregated selection of "item.hardware_fastener_screw_machine"
type item_hardware_fastener_screw_machine_aggregate {
  aggregate: item_hardware_fastener_screw_machine_aggregate_fields
  nodes: [item_hardware_fastener_screw_machine!]!
}

# aggregate fields of "item.hardware_fastener_screw_machine"
type item_hardware_fastener_screw_machine_aggregate_fields {
  avg: item_hardware_fastener_screw_machine_avg_fields
  count(columns: [item_hardware_fastener_screw_machine_select_column!], distinct: Boolean): Int
  max: item_hardware_fastener_screw_machine_max_fields
  min: item_hardware_fastener_screw_machine_min_fields
  stddev: item_hardware_fastener_screw_machine_stddev_fields
  stddev_pop: item_hardware_fastener_screw_machine_stddev_pop_fields
  stddev_samp: item_hardware_fastener_screw_machine_stddev_samp_fields
  sum: item_hardware_fastener_screw_machine_sum_fields
  var_pop: item_hardware_fastener_screw_machine_var_pop_fields
  var_samp: item_hardware_fastener_screw_machine_var_samp_fields
  variance: item_hardware_fastener_screw_machine_variance_fields
}

# order by aggregate values of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_aggregate_order_by {
  avg: item_hardware_fastener_screw_machine_avg_order_by
  count: order_by
  max: item_hardware_fastener_screw_machine_max_order_by
  min: item_hardware_fastener_screw_machine_min_order_by
  stddev: item_hardware_fastener_screw_machine_stddev_order_by
  stddev_pop: item_hardware_fastener_screw_machine_stddev_pop_order_by
  stddev_samp: item_hardware_fastener_screw_machine_stddev_samp_order_by
  sum: item_hardware_fastener_screw_machine_sum_order_by
  var_pop: item_hardware_fastener_screw_machine_var_pop_order_by
  var_samp: item_hardware_fastener_screw_machine_var_samp_order_by
  variance: item_hardware_fastener_screw_machine_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input item_hardware_fastener_screw_machine_append_input {
  default_fields: jsonb
  specifications_met: jsonb
}

# input type for inserting array relation for remote table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_arr_rel_insert_input {
  data: [item_hardware_fastener_screw_machine_insert_input!]!
  on_conflict: item_hardware_fastener_screw_machine_on_conflict
}

# aggregate avg on columns
type item_hardware_fastener_screw_machine_avg_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by avg() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_avg_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# Boolean expression to filter rows from the table "item.hardware_fastener_screw_machine". All fields are combined with a logical 'AND'.
input item_hardware_fastener_screw_machine_bool_exp {
  _and: [item_hardware_fastener_screw_machine_bool_exp]
  _not: item_hardware_fastener_screw_machine_bool_exp
  _or: [item_hardware_fastener_screw_machine_bool_exp]
  countersunk_angle: numeric_comparison_exp
  countersunk_height: numeric_comparison_exp
  default_fields: jsonb_comparison_exp
  description: String_comparison_exp
  drive_size: String_comparison_exp
  drive_type: enum_item_hardware_fastener_drive_enum_comparison_exp
  embedded_length: numeric_comparison_exp
  finish: enum_item_hardware_finish_enum_comparison_exp
  hardness: enum_item_hardware_fastener_screw_hardness_enum_comparison_exp
  head_diameter: numeric_comparison_exp
  head_height: numeric_comparison_exp
  head_type: enum_item_hardware_fastener_screw_head_enum_comparison_exp
  id: Int_comparison_exp
  material: enum_item_hardware_fastener_material_enum_comparison_exp
  name: String_comparison_exp
  point_type: enum_item_hardware_fastener_screw_machine_point_enum_comparison_exp
  specifications_met: jsonb_comparison_exp
  strength_class: enum_item_hardware_fastener_screw_machine_strength_enum_comparison_exp
  tensile_strength: numeric_comparison_exp
  thread_diameter: numeric_comparison_exp
  thread_direction: enum_item_handedness_enum_comparison_exp
  thread_fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum_comparison_exp
  thread_label: enum_item_hardware_fastener_thread_label_enum_comparison_exp
  thread_length: numeric_comparison_exp
  thread_pitch: numeric_comparison_exp
  thread_standard: enum_item_hardware_fastener_thread_standard_enum_comparison_exp
  unit: enum_unit_enum_comparison_exp
  use_material: enum_item_hardware_use_material_enum_comparison_exp
}

# unique or primary key constraints on table "item.hardware_fastener_screw_machine"
enum item_hardware_fastener_screw_machine_constraint {
  # unique or primary key constraint
  item_hardware_fastener_bolt_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input item_hardware_fastener_screw_machine_delete_at_path_input {
  default_fields: [String]
  specifications_met: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input item_hardware_fastener_screw_machine_delete_elem_input {
  default_fields: Int
  specifications_met: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input item_hardware_fastener_screw_machine_delete_key_input {
  default_fields: String
  specifications_met: String
}

# input type for incrementing integer column in table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_inc_input {
  countersunk_angle: numeric
  countersunk_height: numeric
  embedded_length: numeric
  head_diameter: numeric
  head_height: numeric
  id: Int
  tensile_strength: numeric
  thread_diameter: numeric
  thread_length: numeric
  thread_pitch: numeric
}

# input type for inserting data into table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_insert_input {
  countersunk_angle: numeric
  countersunk_height: numeric
  default_fields: jsonb
  description: String
  drive_size: String
  drive_type: enum_item_hardware_fastener_drive_enum
  embedded_length: numeric
  finish: enum_item_hardware_finish_enum
  hardness: enum_item_hardware_fastener_screw_hardness_enum
  head_diameter: numeric
  head_height: numeric
  head_type: enum_item_hardware_fastener_screw_head_enum
  id: Int
  material: enum_item_hardware_fastener_material_enum
  name: String
  point_type: enum_item_hardware_fastener_screw_machine_point_enum
  specifications_met: jsonb
  strength_class: enum_item_hardware_fastener_screw_machine_strength_enum
  tensile_strength: numeric
  thread_diameter: numeric
  thread_direction: enum_item_handedness_enum
  thread_fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  thread_label: enum_item_hardware_fastener_thread_label_enum
  thread_length: numeric
  thread_pitch: numeric
  thread_standard: enum_item_hardware_fastener_thread_standard_enum
  unit: enum_unit_enum
  use_material: enum_item_hardware_use_material_enum
}

# aggregate max on columns
type item_hardware_fastener_screw_machine_max_fields {
  countersunk_angle: numeric
  countersunk_height: numeric
  description: String
  drive_size: String
  embedded_length: numeric
  head_diameter: numeric
  head_height: numeric
  id: Int
  name: String
  tensile_strength: numeric
  thread_diameter: numeric
  thread_length: numeric
  thread_pitch: numeric
}

# order by max() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_max_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  description: order_by
  drive_size: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  name: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate min on columns
type item_hardware_fastener_screw_machine_min_fields {
  countersunk_angle: numeric
  countersunk_height: numeric
  description: String
  drive_size: String
  embedded_length: numeric
  head_diameter: numeric
  head_height: numeric
  id: Int
  name: String
  tensile_strength: numeric
  thread_diameter: numeric
  thread_length: numeric
  thread_pitch: numeric
}

# order by min() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_min_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  description: order_by
  drive_size: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  name: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# response of any mutation on the table "item.hardware_fastener_screw_machine"
type item_hardware_fastener_screw_machine_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_fastener_screw_machine!]!
}

# input type for inserting object relation for remote table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_obj_rel_insert_input {
  data: item_hardware_fastener_screw_machine_insert_input!
  on_conflict: item_hardware_fastener_screw_machine_on_conflict
}

# on conflict condition type for table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_on_conflict {
  constraint: item_hardware_fastener_screw_machine_constraint!
  update_columns: [item_hardware_fastener_screw_machine_update_column!]!
  where: item_hardware_fastener_screw_machine_bool_exp
}

# ordering options when selecting data from "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  default_fields: order_by
  description: order_by
  drive_size: order_by
  drive_type: order_by
  embedded_length: order_by
  finish: order_by
  hardness: order_by
  head_diameter: order_by
  head_height: order_by
  head_type: order_by
  id: order_by
  material: order_by
  name: order_by
  point_type: order_by
  specifications_met: order_by
  strength_class: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_direction: order_by
  thread_fit: order_by
  thread_label: order_by
  thread_length: order_by
  thread_pitch: order_by
  thread_standard: order_by
  unit: order_by
  use_material: order_by
}

# primary key columns input for table: "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_pk_columns_input {
  id: Int!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input item_hardware_fastener_screw_machine_prepend_input {
  default_fields: jsonb
  specifications_met: jsonb
}

# select columns of table "item.hardware_fastener_screw_machine"
enum item_hardware_fastener_screw_machine_select_column {
  # column name
  countersunk_angle

  # column name
  countersunk_height

  # column name
  default_fields

  # column name
  description

  # column name
  drive_size

  # column name
  drive_type

  # column name
  embedded_length

  # column name
  finish

  # column name
  hardness

  # column name
  head_diameter

  # column name
  head_height

  # column name
  head_type

  # column name
  id

  # column name
  material

  # column name
  name

  # column name
  point_type

  # column name
  specifications_met

  # column name
  strength_class

  # column name
  tensile_strength

  # column name
  thread_diameter

  # column name
  thread_direction

  # column name
  thread_fit

  # column name
  thread_label

  # column name
  thread_length

  # column name
  thread_pitch

  # column name
  thread_standard

  # column name
  unit

  # column name
  use_material
}

# input type for updating data in table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_set_input {
  countersunk_angle: numeric
  countersunk_height: numeric
  default_fields: jsonb
  description: String
  drive_size: String
  drive_type: enum_item_hardware_fastener_drive_enum
  embedded_length: numeric
  finish: enum_item_hardware_finish_enum
  hardness: enum_item_hardware_fastener_screw_hardness_enum
  head_diameter: numeric
  head_height: numeric
  head_type: enum_item_hardware_fastener_screw_head_enum
  id: Int
  material: enum_item_hardware_fastener_material_enum
  name: String
  point_type: enum_item_hardware_fastener_screw_machine_point_enum
  specifications_met: jsonb
  strength_class: enum_item_hardware_fastener_screw_machine_strength_enum
  tensile_strength: numeric
  thread_diameter: numeric
  thread_direction: enum_item_handedness_enum
  thread_fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  thread_label: enum_item_hardware_fastener_thread_label_enum
  thread_length: numeric
  thread_pitch: numeric
  thread_standard: enum_item_hardware_fastener_thread_standard_enum
  unit: enum_unit_enum
  use_material: enum_item_hardware_use_material_enum
}

# aggregate stddev on columns
type item_hardware_fastener_screw_machine_stddev_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by stddev() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_stddev_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate stddev_pop on columns
type item_hardware_fastener_screw_machine_stddev_pop_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by stddev_pop() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_stddev_pop_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate stddev_samp on columns
type item_hardware_fastener_screw_machine_stddev_samp_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by stddev_samp() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_stddev_samp_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate sum on columns
type item_hardware_fastener_screw_machine_sum_fields {
  countersunk_angle: numeric
  countersunk_height: numeric
  embedded_length: numeric
  head_diameter: numeric
  head_height: numeric
  id: Int
  tensile_strength: numeric
  thread_diameter: numeric
  thread_length: numeric
  thread_pitch: numeric
}

# order by sum() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_sum_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# update columns of table "item.hardware_fastener_screw_machine"
enum item_hardware_fastener_screw_machine_update_column {
  # column name
  countersunk_angle

  # column name
  countersunk_height

  # column name
  default_fields

  # column name
  description

  # column name
  drive_size

  # column name
  drive_type

  # column name
  embedded_length

  # column name
  finish

  # column name
  hardness

  # column name
  head_diameter

  # column name
  head_height

  # column name
  head_type

  # column name
  id

  # column name
  material

  # column name
  name

  # column name
  point_type

  # column name
  specifications_met

  # column name
  strength_class

  # column name
  tensile_strength

  # column name
  thread_diameter

  # column name
  thread_direction

  # column name
  thread_fit

  # column name
  thread_label

  # column name
  thread_length

  # column name
  thread_pitch

  # column name
  thread_standard

  # column name
  unit

  # column name
  use_material
}

# aggregate var_pop on columns
type item_hardware_fastener_screw_machine_var_pop_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by var_pop() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_var_pop_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate var_samp on columns
type item_hardware_fastener_screw_machine_var_samp_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by var_samp() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_var_samp_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate variance on columns
type item_hardware_fastener_screw_machine_variance_fields {
  countersunk_angle: Float
  countersunk_height: Float
  embedded_length: Float
  head_diameter: Float
  head_height: Float
  id: Float
  tensile_strength: Float
  thread_diameter: Float
  thread_length: Float
  thread_pitch: Float
}

# order by variance() on columns of table "item.hardware_fastener_screw_machine"
input item_hardware_fastener_screw_machine_variance_order_by {
  countersunk_angle: order_by
  countersunk_height: order_by
  embedded_length: order_by
  head_diameter: order_by
  head_height: order_by
  id: order_by
  tensile_strength: order_by
  thread_diameter: order_by
  thread_length: order_by
  thread_pitch: order_by
}

# aggregate max on columns
type item_hardware_fastener_screw_max_fields {
  description: String
  id: Int
  name: String
}

# order by max() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_max_order_by {
  description: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type item_hardware_fastener_screw_min_fields {
  description: String
  id: Int
  name: String
}

# order by min() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_min_order_by {
  description: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "item.hardware_fastener_screw"
type item_hardware_fastener_screw_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_fastener_screw!]!
}

# input type for inserting object relation for remote table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_obj_rel_insert_input {
  data: item_hardware_fastener_screw_insert_input!
  on_conflict: item_hardware_fastener_screw_on_conflict
}

# on conflict condition type for table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_on_conflict {
  constraint: item_hardware_fastener_screw_constraint!
  update_columns: [item_hardware_fastener_screw_update_column!]!
  where: item_hardware_fastener_screw_bool_exp
}

# ordering options when selecting data from "item.hardware_fastener_screw"
input item_hardware_fastener_screw_order_by {
  description: order_by
  id: order_by
  name: order_by
  point: order_by
  unit: order_by
  use_material: order_by
}

# primary key columns input for table: "item.hardware_fastener_screw"
input item_hardware_fastener_screw_pk_columns_input {
  id: Int!
}

# select columns of table "item.hardware_fastener_screw"
enum item_hardware_fastener_screw_select_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  point

  # column name
  unit

  # column name
  use_material
}

# input type for updating data in table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_set_input {
  description: String
  id: Int
  name: String
  point: enum_item_hardware_fastener_screw_machine_point_enum
  unit: enum_unit_enum
  use_material: enum_item_hardware_use_material_enum
}

# aggregate stddev on columns
type item_hardware_fastener_screw_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type item_hardware_fastener_screw_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type item_hardware_fastener_screw_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type item_hardware_fastener_screw_sum_fields {
  id: Int
}

# order by sum() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_sum_order_by {
  id: order_by
}

# update columns of table "item.hardware_fastener_screw"
enum item_hardware_fastener_screw_update_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  point

  # column name
  unit

  # column name
  use_material
}

# aggregate var_pop on columns
type item_hardware_fastener_screw_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type item_hardware_fastener_screw_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type item_hardware_fastener_screw_variance_fields {
  id: Float
}

# order by variance() on columns of table "item.hardware_fastener_screw"
input item_hardware_fastener_screw_variance_order_by {
  id: order_by
}

# columns and relationships of "item.hardware_fastener_standoff"
type item_hardware_fastener_standoff {
  description: String
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric

  # In a typical male-female standoff, this is usually listed as the item's length
  female_thread_length: numeric
  female_thread_pitch: numeric
  female_thread_tolerance: String
  hardness: enum_item_hardware_fastener_screw_hardness_enum!
  id: Int!
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  male_thread_tolerance: String
  material: enum_item_hardware_fastener_material_enum!

  # Male threads don't have an OD, but there may still be a portion of the spacer that is wider than the female portion ( or there is no female end )
  max_od: numeric
  name: String!
  shape: enum_item_hardware_fastener_standoff_shape_enum!
  unit: enum_unit_enum!
}

# aggregated selection of "item.hardware_fastener_standoff"
type item_hardware_fastener_standoff_aggregate {
  aggregate: item_hardware_fastener_standoff_aggregate_fields
  nodes: [item_hardware_fastener_standoff!]!
}

# aggregate fields of "item.hardware_fastener_standoff"
type item_hardware_fastener_standoff_aggregate_fields {
  avg: item_hardware_fastener_standoff_avg_fields
  count(columns: [item_hardware_fastener_standoff_select_column!], distinct: Boolean): Int
  max: item_hardware_fastener_standoff_max_fields
  min: item_hardware_fastener_standoff_min_fields
  stddev: item_hardware_fastener_standoff_stddev_fields
  stddev_pop: item_hardware_fastener_standoff_stddev_pop_fields
  stddev_samp: item_hardware_fastener_standoff_stddev_samp_fields
  sum: item_hardware_fastener_standoff_sum_fields
  var_pop: item_hardware_fastener_standoff_var_pop_fields
  var_samp: item_hardware_fastener_standoff_var_samp_fields
  variance: item_hardware_fastener_standoff_variance_fields
}

# order by aggregate values of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_aggregate_order_by {
  avg: item_hardware_fastener_standoff_avg_order_by
  count: order_by
  max: item_hardware_fastener_standoff_max_order_by
  min: item_hardware_fastener_standoff_min_order_by
  stddev: item_hardware_fastener_standoff_stddev_order_by
  stddev_pop: item_hardware_fastener_standoff_stddev_pop_order_by
  stddev_samp: item_hardware_fastener_standoff_stddev_samp_order_by
  sum: item_hardware_fastener_standoff_sum_order_by
  var_pop: item_hardware_fastener_standoff_var_pop_order_by
  var_samp: item_hardware_fastener_standoff_var_samp_order_by
  variance: item_hardware_fastener_standoff_variance_order_by
}

# input type for inserting array relation for remote table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_arr_rel_insert_input {
  data: [item_hardware_fastener_standoff_insert_input!]!
  on_conflict: item_hardware_fastener_standoff_on_conflict
}

# aggregate avg on columns
type item_hardware_fastener_standoff_avg_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by avg() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_avg_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# Boolean expression to filter rows from the table "item.hardware_fastener_standoff". All fields are combined with a logical 'AND'.
input item_hardware_fastener_standoff_bool_exp {
  _and: [item_hardware_fastener_standoff_bool_exp]
  _not: item_hardware_fastener_standoff_bool_exp
  _or: [item_hardware_fastener_standoff_bool_exp]
  description: String_comparison_exp
  female_length: numeric_comparison_exp
  female_od: numeric_comparison_exp
  female_thread_diameter: numeric_comparison_exp
  female_thread_length: numeric_comparison_exp
  female_thread_pitch: numeric_comparison_exp
  female_thread_tolerance: String_comparison_exp
  hardness: enum_item_hardware_fastener_screw_hardness_enum_comparison_exp
  id: Int_comparison_exp
  male_length: numeric_comparison_exp
  male_thread_diameter: numeric_comparison_exp
  male_thread_length: numeric_comparison_exp
  male_thread_pitch: numeric_comparison_exp
  male_thread_tolerance: String_comparison_exp
  material: enum_item_hardware_fastener_material_enum_comparison_exp
  max_od: numeric_comparison_exp
  name: String_comparison_exp
  shape: enum_item_hardware_fastener_standoff_shape_enum_comparison_exp
  unit: enum_unit_enum_comparison_exp
}

# unique or primary key constraints on table "item.hardware_fastener_standoff"
enum item_hardware_fastener_standoff_constraint {
  # unique or primary key constraint
  hardware_fastener_standoff_pkey
}

# input type for incrementing integer column in table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_inc_input {
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric
  female_thread_length: numeric
  female_thread_pitch: numeric
  id: Int
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  max_od: numeric
}

# input type for inserting data into table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_insert_input {
  description: String
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric
  female_thread_length: numeric
  female_thread_pitch: numeric
  female_thread_tolerance: String
  hardness: enum_item_hardware_fastener_screw_hardness_enum
  id: Int
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  male_thread_tolerance: String
  material: enum_item_hardware_fastener_material_enum
  max_od: numeric
  name: String
  shape: enum_item_hardware_fastener_standoff_shape_enum
  unit: enum_unit_enum
}

# aggregate max on columns
type item_hardware_fastener_standoff_max_fields {
  description: String
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric
  female_thread_length: numeric
  female_thread_pitch: numeric
  female_thread_tolerance: String
  id: Int
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  male_thread_tolerance: String
  max_od: numeric
  name: String
}

# order by max() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_max_order_by {
  description: order_by
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  female_thread_tolerance: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  male_thread_tolerance: order_by
  max_od: order_by
  name: order_by
}

# aggregate min on columns
type item_hardware_fastener_standoff_min_fields {
  description: String
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric
  female_thread_length: numeric
  female_thread_pitch: numeric
  female_thread_tolerance: String
  id: Int
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  male_thread_tolerance: String
  max_od: numeric
  name: String
}

# order by min() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_min_order_by {
  description: order_by
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  female_thread_tolerance: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  male_thread_tolerance: order_by
  max_od: order_by
  name: order_by
}

# response of any mutation on the table "item.hardware_fastener_standoff"
type item_hardware_fastener_standoff_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_fastener_standoff!]!
}

# input type for inserting object relation for remote table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_obj_rel_insert_input {
  data: item_hardware_fastener_standoff_insert_input!
  on_conflict: item_hardware_fastener_standoff_on_conflict
}

# on conflict condition type for table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_on_conflict {
  constraint: item_hardware_fastener_standoff_constraint!
  update_columns: [item_hardware_fastener_standoff_update_column!]!
  where: item_hardware_fastener_standoff_bool_exp
}

# ordering options when selecting data from "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_order_by {
  description: order_by
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  female_thread_tolerance: order_by
  hardness: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  male_thread_tolerance: order_by
  material: order_by
  max_od: order_by
  name: order_by
  shape: order_by
  unit: order_by
}

# primary key columns input for table: "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_pk_columns_input {
  id: Int!
}

# select columns of table "item.hardware_fastener_standoff"
enum item_hardware_fastener_standoff_select_column {
  # column name
  description

  # column name
  female_length

  # column name
  female_od

  # column name
  female_thread_diameter

  # column name
  female_thread_length

  # column name
  female_thread_pitch

  # column name
  female_thread_tolerance

  # column name
  hardness

  # column name
  id

  # column name
  male_length

  # column name
  male_thread_diameter

  # column name
  male_thread_length

  # column name
  male_thread_pitch

  # column name
  male_thread_tolerance

  # column name
  material

  # column name
  max_od

  # column name
  name

  # column name
  shape

  # column name
  unit
}

# input type for updating data in table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_set_input {
  description: String
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric
  female_thread_length: numeric
  female_thread_pitch: numeric
  female_thread_tolerance: String
  hardness: enum_item_hardware_fastener_screw_hardness_enum
  id: Int
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  male_thread_tolerance: String
  material: enum_item_hardware_fastener_material_enum
  max_od: numeric
  name: String
  shape: enum_item_hardware_fastener_standoff_shape_enum
  unit: enum_unit_enum
}

# aggregate stddev on columns
type item_hardware_fastener_standoff_stddev_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by stddev() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_stddev_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# aggregate stddev_pop on columns
type item_hardware_fastener_standoff_stddev_pop_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by stddev_pop() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_stddev_pop_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# aggregate stddev_samp on columns
type item_hardware_fastener_standoff_stddev_samp_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by stddev_samp() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_stddev_samp_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# aggregate sum on columns
type item_hardware_fastener_standoff_sum_fields {
  female_length: numeric
  female_od: numeric
  female_thread_diameter: numeric
  female_thread_length: numeric
  female_thread_pitch: numeric
  id: Int
  male_length: numeric
  male_thread_diameter: numeric
  male_thread_length: numeric
  male_thread_pitch: numeric
  max_od: numeric
}

# order by sum() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_sum_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# update columns of table "item.hardware_fastener_standoff"
enum item_hardware_fastener_standoff_update_column {
  # column name
  description

  # column name
  female_length

  # column name
  female_od

  # column name
  female_thread_diameter

  # column name
  female_thread_length

  # column name
  female_thread_pitch

  # column name
  female_thread_tolerance

  # column name
  hardness

  # column name
  id

  # column name
  male_length

  # column name
  male_thread_diameter

  # column name
  male_thread_length

  # column name
  male_thread_pitch

  # column name
  male_thread_tolerance

  # column name
  material

  # column name
  max_od

  # column name
  name

  # column name
  shape

  # column name
  unit
}

# aggregate var_pop on columns
type item_hardware_fastener_standoff_var_pop_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by var_pop() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_var_pop_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# aggregate var_samp on columns
type item_hardware_fastener_standoff_var_samp_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by var_samp() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_var_samp_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# aggregate variance on columns
type item_hardware_fastener_standoff_variance_fields {
  female_length: Float
  female_od: Float
  female_thread_diameter: Float
  female_thread_length: Float
  female_thread_pitch: Float
  id: Float
  male_length: Float
  male_thread_diameter: Float
  male_thread_length: Float
  male_thread_pitch: Float
  max_od: Float
}

# order by variance() on columns of table "item.hardware_fastener_standoff"
input item_hardware_fastener_standoff_variance_order_by {
  female_length: order_by
  female_od: order_by
  female_thread_diameter: order_by
  female_thread_length: order_by
  female_thread_pitch: order_by
  id: order_by
  male_length: order_by
  male_thread_diameter: order_by
  male_thread_length: order_by
  male_thread_pitch: order_by
  max_od: order_by
}

# Washers spread the load over a greater surface area when tightening a bolt, screw, or nut. Lock washers help prevent loosening.
#
#
# columns and relationships of "item.hardware_fastener_washer"
type item_hardware_fastener_washer {
  description: String
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric!
  finish: enum_item_hardware_finish_enum
  form: enum_item_hardware_fastener_washer_form_enum!
  id: Int!
  lock_method: enum_item_hardware_fastener_washer_mechanism_enum
  material: enum_item_hardware_fastener_material_enum
  name: String!
  pattern: enum_item_hardware_fastener_washer_pattern_enum
  thickness: numeric
  unit: enum_unit_enum!
}

# aggregated selection of "item.hardware_fastener_washer"
type item_hardware_fastener_washer_aggregate {
  aggregate: item_hardware_fastener_washer_aggregate_fields
  nodes: [item_hardware_fastener_washer!]!
}

# aggregate fields of "item.hardware_fastener_washer"
type item_hardware_fastener_washer_aggregate_fields {
  avg: item_hardware_fastener_washer_avg_fields
  count(columns: [item_hardware_fastener_washer_select_column!], distinct: Boolean): Int
  max: item_hardware_fastener_washer_max_fields
  min: item_hardware_fastener_washer_min_fields
  stddev: item_hardware_fastener_washer_stddev_fields
  stddev_pop: item_hardware_fastener_washer_stddev_pop_fields
  stddev_samp: item_hardware_fastener_washer_stddev_samp_fields
  sum: item_hardware_fastener_washer_sum_fields
  var_pop: item_hardware_fastener_washer_var_pop_fields
  var_samp: item_hardware_fastener_washer_var_samp_fields
  variance: item_hardware_fastener_washer_variance_fields
}

# order by aggregate values of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_aggregate_order_by {
  avg: item_hardware_fastener_washer_avg_order_by
  count: order_by
  max: item_hardware_fastener_washer_max_order_by
  min: item_hardware_fastener_washer_min_order_by
  stddev: item_hardware_fastener_washer_stddev_order_by
  stddev_pop: item_hardware_fastener_washer_stddev_pop_order_by
  stddev_samp: item_hardware_fastener_washer_stddev_samp_order_by
  sum: item_hardware_fastener_washer_sum_order_by
  var_pop: item_hardware_fastener_washer_var_pop_order_by
  var_samp: item_hardware_fastener_washer_var_samp_order_by
  variance: item_hardware_fastener_washer_variance_order_by
}

# input type for inserting array relation for remote table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_arr_rel_insert_input {
  data: [item_hardware_fastener_washer_insert_input!]!
  on_conflict: item_hardware_fastener_washer_on_conflict
}

# aggregate avg on columns
type item_hardware_fastener_washer_avg_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by avg() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_avg_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# Boolean expression to filter rows from the table "item.hardware_fastener_washer". All fields are combined with a logical 'AND'.
input item_hardware_fastener_washer_bool_exp {
  _and: [item_hardware_fastener_washer_bool_exp]
  _not: item_hardware_fastener_washer_bool_exp
  _or: [item_hardware_fastener_washer_bool_exp]
  description: String_comparison_exp
  diameter_inner: numeric_comparison_exp
  diameter_outer: numeric_comparison_exp
  diameter_use: numeric_comparison_exp
  finish: enum_item_hardware_finish_enum_comparison_exp
  form: enum_item_hardware_fastener_washer_form_enum_comparison_exp
  id: Int_comparison_exp
  lock_method: enum_item_hardware_fastener_washer_mechanism_enum_comparison_exp
  material: enum_item_hardware_fastener_material_enum_comparison_exp
  name: String_comparison_exp
  pattern: enum_item_hardware_fastener_washer_pattern_enum_comparison_exp
  thickness: numeric_comparison_exp
  unit: enum_unit_enum_comparison_exp
}

# unique or primary key constraints on table "item.hardware_fastener_washer"
enum item_hardware_fastener_washer_constraint {
  # unique or primary key constraint
  hardware_fastener_washer_pkey
}

# input type for incrementing integer column in table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_inc_input {
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric
  id: Int
  thickness: numeric
}

# input type for inserting data into table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_insert_input {
  description: String
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric
  finish: enum_item_hardware_finish_enum
  form: enum_item_hardware_fastener_washer_form_enum
  id: Int
  lock_method: enum_item_hardware_fastener_washer_mechanism_enum
  material: enum_item_hardware_fastener_material_enum
  name: String
  pattern: enum_item_hardware_fastener_washer_pattern_enum
  thickness: numeric
  unit: enum_unit_enum
}

# aggregate max on columns
type item_hardware_fastener_washer_max_fields {
  description: String
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric
  id: Int
  name: String
  thickness: numeric
}

# order by max() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_max_order_by {
  description: order_by
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  name: order_by
  thickness: order_by
}

# aggregate min on columns
type item_hardware_fastener_washer_min_fields {
  description: String
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric
  id: Int
  name: String
  thickness: numeric
}

# order by min() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_min_order_by {
  description: order_by
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  name: order_by
  thickness: order_by
}

# response of any mutation on the table "item.hardware_fastener_washer"
type item_hardware_fastener_washer_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item_hardware_fastener_washer!]!
}

# input type for inserting object relation for remote table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_obj_rel_insert_input {
  data: item_hardware_fastener_washer_insert_input!
  on_conflict: item_hardware_fastener_washer_on_conflict
}

# on conflict condition type for table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_on_conflict {
  constraint: item_hardware_fastener_washer_constraint!
  update_columns: [item_hardware_fastener_washer_update_column!]!
  where: item_hardware_fastener_washer_bool_exp
}

# ordering options when selecting data from "item.hardware_fastener_washer"
input item_hardware_fastener_washer_order_by {
  description: order_by
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  finish: order_by
  form: order_by
  id: order_by
  lock_method: order_by
  material: order_by
  name: order_by
  pattern: order_by
  thickness: order_by
  unit: order_by
}

# primary key columns input for table: "item.hardware_fastener_washer"
input item_hardware_fastener_washer_pk_columns_input {
  id: Int!
}

# select columns of table "item.hardware_fastener_washer"
enum item_hardware_fastener_washer_select_column {
  # column name
  description

  # column name
  diameter_inner

  # column name
  diameter_outer

  # column name
  diameter_use

  # column name
  finish

  # column name
  form

  # column name
  id

  # column name
  lock_method

  # column name
  material

  # column name
  name

  # column name
  pattern

  # column name
  thickness

  # column name
  unit
}

# input type for updating data in table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_set_input {
  description: String
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric
  finish: enum_item_hardware_finish_enum
  form: enum_item_hardware_fastener_washer_form_enum
  id: Int
  lock_method: enum_item_hardware_fastener_washer_mechanism_enum
  material: enum_item_hardware_fastener_material_enum
  name: String
  pattern: enum_item_hardware_fastener_washer_pattern_enum
  thickness: numeric
  unit: enum_unit_enum
}

# aggregate stddev on columns
type item_hardware_fastener_washer_stddev_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by stddev() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_stddev_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# aggregate stddev_pop on columns
type item_hardware_fastener_washer_stddev_pop_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by stddev_pop() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_stddev_pop_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# aggregate stddev_samp on columns
type item_hardware_fastener_washer_stddev_samp_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by stddev_samp() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_stddev_samp_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# aggregate sum on columns
type item_hardware_fastener_washer_sum_fields {
  diameter_inner: numeric
  diameter_outer: numeric
  diameter_use: numeric
  id: Int
  thickness: numeric
}

# order by sum() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_sum_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# update columns of table "item.hardware_fastener_washer"
enum item_hardware_fastener_washer_update_column {
  # column name
  description

  # column name
  diameter_inner

  # column name
  diameter_outer

  # column name
  diameter_use

  # column name
  finish

  # column name
  form

  # column name
  id

  # column name
  lock_method

  # column name
  material

  # column name
  name

  # column name
  pattern

  # column name
  thickness

  # column name
  unit
}

# aggregate var_pop on columns
type item_hardware_fastener_washer_var_pop_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by var_pop() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_var_pop_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# aggregate var_samp on columns
type item_hardware_fastener_washer_var_samp_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by var_samp() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_var_samp_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# aggregate variance on columns
type item_hardware_fastener_washer_variance_fields {
  diameter_inner: Float
  diameter_outer: Float
  diameter_use: Float
  id: Float
  thickness: Float
}

# order by variance() on columns of table "item.hardware_fastener_washer"
input item_hardware_fastener_washer_variance_order_by {
  diameter_inner: order_by
  diameter_outer: order_by
  diameter_use: order_by
  id: order_by
  thickness: order_by
}

# input type for incrementing integer column in table "item"
input item_inc_input {
  id: Int
}

# input type for inserting data into table "item"
input item_insert_input {
  bundle: item_bundle_map_arr_rel_insert_input
  class: enum_item_class_enum
  id: Int
  labelTemplates: label_template_map_arr_rel_insert_input
  labels: label_arr_rel_insert_input
  manufacturerItems: manufacturer_item_arr_rel_insert_input
  object: jsonb
  orderItems: order_item_arr_rel_insert_input
  vendorItems: vendor_item_arr_rel_insert_input
}

# aggregate max on columns
type item_max_fields {
  id: Int
}

# order by max() on columns of table "item"
input item_max_order_by {
  id: order_by
}

# aggregate min on columns
type item_min_fields {
  id: Int
}

# order by min() on columns of table "item"
input item_min_order_by {
  id: order_by
}

# response of any mutation on the table "item"
type item_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [item!]!
}

# input type for inserting object relation for remote table "item"
input item_obj_rel_insert_input {
  data: item_insert_input!
  on_conflict: item_on_conflict
}

# on conflict condition type for table "item"
input item_on_conflict {
  constraint: item_constraint!
  update_columns: [item_update_column!]!
  where: item_bool_exp
}

# ordering options when selecting data from "item"
input item_order_by {
  bundle_aggregate: item_bundle_map_aggregate_order_by
  class: order_by
  id: order_by
  itemVariants_aggregate: item_variant_aggregate_order_by
  labelTemplates_aggregate: label_template_map_aggregate_order_by
  labels_aggregate: label_aggregate_order_by
  manufacturerItems_aggregate: manufacturer_item_aggregate_order_by
  object: order_by
  orderItems_aggregate: order_item_aggregate_order_by
  vendorItems_aggregate: vendor_item_aggregate_order_by
}

# primary key columns input for table: "item"
input item_pk_columns_input {
  id: Int!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input item_prepend_input {
  object: jsonb
}

# select columns of table "item"
enum item_select_column {
  # column name
  class

  # column name
  id

  # column name
  object
}

# input type for updating data in table "item"
input item_set_input {
  class: enum_item_class_enum
  id: Int
  object: jsonb
}

# aggregate stddev on columns
type item_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "item"
input item_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type item_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "item"
input item_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type item_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "item"
input item_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type item_sum_fields {
  id: Int
}

# order by sum() on columns of table "item"
input item_sum_order_by {
  id: order_by
}

# update columns of table "item"
enum item_update_column {
  # column name
  class

  # column name
  id

  # column name
  object
}

# aggregate var_pop on columns
type item_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "item"
input item_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type item_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "item"
input item_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type item_variance_fields {
  id: Float
}

# order by variance() on columns of table "item"
input item_variance_order_by {
  id: order_by
}

# All existing combinations of vendor and manufacturer for an item, including null for both.
#
#
# columns and relationships of "item_variant"
type item_variant {
  class: String
  id: Int

  # An object relationship
  item: item
  item_id: Int

  # An object relationship
  manufacturer: manufacturer
  manufacturer_id: Int
  manufacturer_item_id: Int
  object(
    # JSON select path
    path: String
  ): jsonb
  order_id: Int
  order_item_id: Int

  # An object relationship
  vendor: vendor
  vendor_id: Int
  vendor_item_id: Int
}

# aggregated selection of "item_variant"
type item_variant_aggregate {
  aggregate: item_variant_aggregate_fields
  nodes: [item_variant!]!
}

# aggregate fields of "item_variant"
type item_variant_aggregate_fields {
  avg: item_variant_avg_fields
  count(columns: [item_variant_select_column!], distinct: Boolean): Int
  max: item_variant_max_fields
  min: item_variant_min_fields
  stddev: item_variant_stddev_fields
  stddev_pop: item_variant_stddev_pop_fields
  stddev_samp: item_variant_stddev_samp_fields
  sum: item_variant_sum_fields
  var_pop: item_variant_var_pop_fields
  var_samp: item_variant_var_samp_fields
  variance: item_variant_variance_fields
}

# order by aggregate values of table "item_variant"
input item_variant_aggregate_order_by {
  avg: item_variant_avg_order_by
  count: order_by
  max: item_variant_max_order_by
  min: item_variant_min_order_by
  stddev: item_variant_stddev_order_by
  stddev_pop: item_variant_stddev_pop_order_by
  stddev_samp: item_variant_stddev_samp_order_by
  sum: item_variant_sum_order_by
  var_pop: item_variant_var_pop_order_by
  var_samp: item_variant_var_samp_order_by
  variance: item_variant_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input item_variant_append_input {
  object: jsonb
}

# aggregate avg on columns
type item_variant_avg_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by avg() on columns of table "item_variant"
input item_variant_avg_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# Boolean expression to filter rows from the table "item_variant". All fields are combined with a logical 'AND'.
input item_variant_bool_exp {
  _and: [item_variant_bool_exp]
  _not: item_variant_bool_exp
  _or: [item_variant_bool_exp]
  class: String_comparison_exp
  id: Int_comparison_exp
  item: item_bool_exp
  item_id: Int_comparison_exp
  manufacturer: manufacturer_bool_exp
  manufacturer_id: Int_comparison_exp
  manufacturer_item_id: Int_comparison_exp
  object: jsonb_comparison_exp
  order_id: Int_comparison_exp
  order_item_id: Int_comparison_exp
  vendor: vendor_bool_exp
  vendor_id: Int_comparison_exp
  vendor_item_id: Int_comparison_exp
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input item_variant_delete_at_path_input {
  object: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input item_variant_delete_elem_input {
  object: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input item_variant_delete_key_input {
  object: String
}

# aggregate max on columns
type item_variant_max_fields {
  class: String
  id: Int
  item_id: Int
  manufacturer_id: Int
  manufacturer_item_id: Int
  order_id: Int
  order_item_id: Int
  vendor_id: Int
  vendor_item_id: Int
}

# order by max() on columns of table "item_variant"
input item_variant_max_order_by {
  class: order_by
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate min on columns
type item_variant_min_fields {
  class: String
  id: Int
  item_id: Int
  manufacturer_id: Int
  manufacturer_item_id: Int
  order_id: Int
  order_item_id: Int
  vendor_id: Int
  vendor_item_id: Int
}

# order by min() on columns of table "item_variant"
input item_variant_min_order_by {
  class: order_by
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# ordering options when selecting data from "item_variant"
input item_variant_order_by {
  class: order_by
  id: order_by
  item: item_order_by
  item_id: order_by
  manufacturer: manufacturer_order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  object: order_by
  order_id: order_by
  order_item_id: order_by
  vendor: vendor_order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# prepend existing jsonb value of filtered columns with new jsonb value
input item_variant_prepend_input {
  object: jsonb
}

# select columns of table "item_variant"
enum item_variant_select_column {
  # column name
  class

  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_id

  # column name
  manufacturer_item_id

  # column name
  object

  # column name
  order_id

  # column name
  order_item_id

  # column name
  vendor_id

  # column name
  vendor_item_id
}

# aggregate stddev on columns
type item_variant_stddev_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by stddev() on columns of table "item_variant"
input item_variant_stddev_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate stddev_pop on columns
type item_variant_stddev_pop_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by stddev_pop() on columns of table "item_variant"
input item_variant_stddev_pop_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate stddev_samp on columns
type item_variant_stddev_samp_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by stddev_samp() on columns of table "item_variant"
input item_variant_stddev_samp_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate sum on columns
type item_variant_sum_fields {
  id: Int
  item_id: Int
  manufacturer_id: Int
  manufacturer_item_id: Int
  order_id: Int
  order_item_id: Int
  vendor_id: Int
  vendor_item_id: Int
}

# order by sum() on columns of table "item_variant"
input item_variant_sum_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate var_pop on columns
type item_variant_var_pop_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by var_pop() on columns of table "item_variant"
input item_variant_var_pop_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate var_samp on columns
type item_variant_var_samp_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by var_samp() on columns of table "item_variant"
input item_variant_var_samp_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

# aggregate variance on columns
type item_variant_variance_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
  manufacturer_item_id: Float
  order_id: Float
  order_item_id: Float
  vendor_id: Float
  vendor_item_id: Float
}

# order by variance() on columns of table "item_variant"
input item_variant_variance_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  order_item_id: order_by
  vendor_id: order_by
  vendor_item_id: order_by
}

scalar jsonb

# expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
input jsonb_comparison_exp {
  # is the column contained in the given json value
  _contained_in: jsonb

  # does the column contain the given json value at the top level
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  # does the string exist as a top-level key in the column
  _has_key: String

  # do all of these strings exist as top-level keys in the column
  _has_keys_all: [String!]

  # do any of these strings exist as top-level keys in the column
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

# For saved labels, use to reprint or template
#
#
# columns and relationships of "label"
type label {
  content(
    # JSON select path
    path: String
  ): jsonb!
  created_at: timestamptz!

  # An object relationship
  edit_of: label
  edit_of_id: uuid
  height: Int!
  id: uuid!

  # An object relationship
  item: item
  item_id: Int

  # An array relationship
  parent_of(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): [label!]!

  # An aggregated array relationship
  parent_of_aggregate(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): label_aggregate!

  # An array relationship
  template_items(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): [label_template_map!]!

  # An aggregated array relationship
  template_items_aggregate(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): label_template_map_aggregate!
  title: String
  updated_at: timestamptz!
  width: Int!
}

# aggregated selection of "label"
type label_aggregate {
  aggregate: label_aggregate_fields
  nodes: [label!]!
}

# aggregate fields of "label"
type label_aggregate_fields {
  avg: label_avg_fields
  count(columns: [label_select_column!], distinct: Boolean): Int
  max: label_max_fields
  min: label_min_fields
  stddev: label_stddev_fields
  stddev_pop: label_stddev_pop_fields
  stddev_samp: label_stddev_samp_fields
  sum: label_sum_fields
  var_pop: label_var_pop_fields
  var_samp: label_var_samp_fields
  variance: label_variance_fields
}

# order by aggregate values of table "label"
input label_aggregate_order_by {
  avg: label_avg_order_by
  count: order_by
  max: label_max_order_by
  min: label_min_order_by
  stddev: label_stddev_order_by
  stddev_pop: label_stddev_pop_order_by
  stddev_samp: label_stddev_samp_order_by
  sum: label_sum_order_by
  var_pop: label_var_pop_order_by
  var_samp: label_var_samp_order_by
  variance: label_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input label_append_input {
  content: jsonb
}

# input type for inserting array relation for remote table "label"
input label_arr_rel_insert_input {
  data: [label_insert_input!]!
  on_conflict: label_on_conflict
}

# aggregate avg on columns
type label_avg_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by avg() on columns of table "label"
input label_avg_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# Boolean expression to filter rows from the table "label". All fields are combined with a logical 'AND'.
input label_bool_exp {
  _and: [label_bool_exp]
  _not: label_bool_exp
  _or: [label_bool_exp]
  content: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  edit_of: label_bool_exp
  edit_of_id: uuid_comparison_exp
  height: Int_comparison_exp
  id: uuid_comparison_exp
  item: item_bool_exp
  item_id: Int_comparison_exp
  parent_of: label_bool_exp
  template_items: label_template_map_bool_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  width: Int_comparison_exp
}

# unique or primary key constraints on table "label"
enum label_constraint {
  # unique or primary key constraint
  label_id_key

  # unique or primary key constraint
  label_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input label_delete_at_path_input {
  content: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input label_delete_elem_input {
  content: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input label_delete_key_input {
  content: String
}

# input type for incrementing integer column in table "label"
input label_inc_input {
  height: Int
  item_id: Int
  width: Int
}

# input type for inserting data into table "label"
input label_insert_input {
  content: jsonb
  created_at: timestamptz
  edit_of: label_obj_rel_insert_input
  edit_of_id: uuid
  height: Int
  id: uuid
  item: item_obj_rel_insert_input
  item_id: Int
  parent_of: label_arr_rel_insert_input
  template_items: label_template_map_arr_rel_insert_input
  title: String
  updated_at: timestamptz
  width: Int
}

# columns and relationships of "label_item_map"
type label_item_map {
  item_id: Int!
  label_id: uuid!
}

# aggregated selection of "label_item_map"
type label_item_map_aggregate {
  aggregate: label_item_map_aggregate_fields
  nodes: [label_item_map!]!
}

# aggregate fields of "label_item_map"
type label_item_map_aggregate_fields {
  avg: label_item_map_avg_fields
  count(columns: [label_item_map_select_column!], distinct: Boolean): Int
  max: label_item_map_max_fields
  min: label_item_map_min_fields
  stddev: label_item_map_stddev_fields
  stddev_pop: label_item_map_stddev_pop_fields
  stddev_samp: label_item_map_stddev_samp_fields
  sum: label_item_map_sum_fields
  var_pop: label_item_map_var_pop_fields
  var_samp: label_item_map_var_samp_fields
  variance: label_item_map_variance_fields
}

# order by aggregate values of table "label_item_map"
input label_item_map_aggregate_order_by {
  avg: label_item_map_avg_order_by
  count: order_by
  max: label_item_map_max_order_by
  min: label_item_map_min_order_by
  stddev: label_item_map_stddev_order_by
  stddev_pop: label_item_map_stddev_pop_order_by
  stddev_samp: label_item_map_stddev_samp_order_by
  sum: label_item_map_sum_order_by
  var_pop: label_item_map_var_pop_order_by
  var_samp: label_item_map_var_samp_order_by
  variance: label_item_map_variance_order_by
}

# input type for inserting array relation for remote table "label_item_map"
input label_item_map_arr_rel_insert_input {
  data: [label_item_map_insert_input!]!
  on_conflict: label_item_map_on_conflict
}

# aggregate avg on columns
type label_item_map_avg_fields {
  item_id: Float
}

# order by avg() on columns of table "label_item_map"
input label_item_map_avg_order_by {
  item_id: order_by
}

# Boolean expression to filter rows from the table "label_item_map". All fields are combined with a logical 'AND'.
input label_item_map_bool_exp {
  _and: [label_item_map_bool_exp]
  _not: label_item_map_bool_exp
  _or: [label_item_map_bool_exp]
  item_id: Int_comparison_exp
  label_id: uuid_comparison_exp
}

# unique or primary key constraints on table "label_item_map"
enum label_item_map_constraint {
  # unique or primary key constraint
  label_item_map_pkey
}

# input type for incrementing integer column in table "label_item_map"
input label_item_map_inc_input {
  item_id: Int
}

# input type for inserting data into table "label_item_map"
input label_item_map_insert_input {
  item_id: Int
  label_id: uuid
}

# aggregate max on columns
type label_item_map_max_fields {
  item_id: Int
  label_id: uuid
}

# order by max() on columns of table "label_item_map"
input label_item_map_max_order_by {
  item_id: order_by
  label_id: order_by
}

# aggregate min on columns
type label_item_map_min_fields {
  item_id: Int
  label_id: uuid
}

# order by min() on columns of table "label_item_map"
input label_item_map_min_order_by {
  item_id: order_by
  label_id: order_by
}

# response of any mutation on the table "label_item_map"
type label_item_map_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [label_item_map!]!
}

# input type for inserting object relation for remote table "label_item_map"
input label_item_map_obj_rel_insert_input {
  data: label_item_map_insert_input!
  on_conflict: label_item_map_on_conflict
}

# on conflict condition type for table "label_item_map"
input label_item_map_on_conflict {
  constraint: label_item_map_constraint!
  update_columns: [label_item_map_update_column!]!
  where: label_item_map_bool_exp
}

# ordering options when selecting data from "label_item_map"
input label_item_map_order_by {
  item_id: order_by
  label_id: order_by
}

# primary key columns input for table: "label_item_map"
input label_item_map_pk_columns_input {
  item_id: Int!
  label_id: uuid!
}

# select columns of table "label_item_map"
enum label_item_map_select_column {
  # column name
  item_id

  # column name
  label_id
}

# input type for updating data in table "label_item_map"
input label_item_map_set_input {
  item_id: Int
  label_id: uuid
}

# aggregate stddev on columns
type label_item_map_stddev_fields {
  item_id: Float
}

# order by stddev() on columns of table "label_item_map"
input label_item_map_stddev_order_by {
  item_id: order_by
}

# aggregate stddev_pop on columns
type label_item_map_stddev_pop_fields {
  item_id: Float
}

# order by stddev_pop() on columns of table "label_item_map"
input label_item_map_stddev_pop_order_by {
  item_id: order_by
}

# aggregate stddev_samp on columns
type label_item_map_stddev_samp_fields {
  item_id: Float
}

# order by stddev_samp() on columns of table "label_item_map"
input label_item_map_stddev_samp_order_by {
  item_id: order_by
}

# aggregate sum on columns
type label_item_map_sum_fields {
  item_id: Int
}

# order by sum() on columns of table "label_item_map"
input label_item_map_sum_order_by {
  item_id: order_by
}

# update columns of table "label_item_map"
enum label_item_map_update_column {
  # column name
  item_id

  # column name
  label_id
}

# aggregate var_pop on columns
type label_item_map_var_pop_fields {
  item_id: Float
}

# order by var_pop() on columns of table "label_item_map"
input label_item_map_var_pop_order_by {
  item_id: order_by
}

# aggregate var_samp on columns
type label_item_map_var_samp_fields {
  item_id: Float
}

# order by var_samp() on columns of table "label_item_map"
input label_item_map_var_samp_order_by {
  item_id: order_by
}

# aggregate variance on columns
type label_item_map_variance_fields {
  item_id: Float
}

# order by variance() on columns of table "label_item_map"
input label_item_map_variance_order_by {
  item_id: order_by
}

# aggregate max on columns
type label_max_fields {
  created_at: timestamptz
  edit_of_id: uuid
  height: Int
  id: uuid
  item_id: Int
  title: String
  updated_at: timestamptz
  width: Int
}

# order by max() on columns of table "label"
input label_max_order_by {
  created_at: order_by
  edit_of_id: order_by
  height: order_by
  id: order_by
  item_id: order_by
  title: order_by
  updated_at: order_by
  width: order_by
}

# aggregate min on columns
type label_min_fields {
  created_at: timestamptz
  edit_of_id: uuid
  height: Int
  id: uuid
  item_id: Int
  title: String
  updated_at: timestamptz
  width: Int
}

# order by min() on columns of table "label"
input label_min_order_by {
  created_at: order_by
  edit_of_id: order_by
  height: order_by
  id: order_by
  item_id: order_by
  title: order_by
  updated_at: order_by
  width: order_by
}

# response of any mutation on the table "label"
type label_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [label!]!
}

# input type for inserting object relation for remote table "label"
input label_obj_rel_insert_input {
  data: label_insert_input!
  on_conflict: label_on_conflict
}

# on conflict condition type for table "label"
input label_on_conflict {
  constraint: label_constraint!
  update_columns: [label_update_column!]!
  where: label_bool_exp
}

# ordering options when selecting data from "label"
input label_order_by {
  content: order_by
  created_at: order_by
  edit_of: label_order_by
  edit_of_id: order_by
  height: order_by
  id: order_by
  item: item_order_by
  item_id: order_by
  parent_of_aggregate: label_aggregate_order_by
  template_items_aggregate: label_template_map_aggregate_order_by
  title: order_by
  updated_at: order_by
  width: order_by
}

# primary key columns input for table: "label"
input label_pk_columns_input {
  id: uuid!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input label_prepend_input {
  content: jsonb
}

# select columns of table "label"
enum label_select_column {
  # column name
  content

  # column name
  created_at

  # column name
  edit_of_id

  # column name
  height

  # column name
  id

  # column name
  item_id

  # column name
  title

  # column name
  updated_at

  # column name
  width
}

# input type for updating data in table "label"
input label_set_input {
  content: jsonb
  created_at: timestamptz
  edit_of_id: uuid
  height: Int
  id: uuid
  item_id: Int
  title: String
  updated_at: timestamptz
  width: Int
}

# aggregate stddev on columns
type label_stddev_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by stddev() on columns of table "label"
input label_stddev_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# aggregate stddev_pop on columns
type label_stddev_pop_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by stddev_pop() on columns of table "label"
input label_stddev_pop_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# aggregate stddev_samp on columns
type label_stddev_samp_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by stddev_samp() on columns of table "label"
input label_stddev_samp_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# aggregate sum on columns
type label_sum_fields {
  height: Int
  item_id: Int
  width: Int
}

# order by sum() on columns of table "label"
input label_sum_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# map label to item use for template
#
#
# columns and relationships of "label_template_map"
type label_template_map {
  # json rules in the form of:
  #             { [propKey: keyof item_class]: regex }
  # this is then evaluated for each entry
  # evaluation is done in the sequence order
  criteria(
    # JSON select path
    path: String
  ): jsonb
  item_class: String!
  item_id: Int!

  # An object relationship
  label: label!
  label_id: uuid!
  sequence: smallint!
}

# aggregated selection of "label_template_map"
type label_template_map_aggregate {
  aggregate: label_template_map_aggregate_fields
  nodes: [label_template_map!]!
}

# aggregate fields of "label_template_map"
type label_template_map_aggregate_fields {
  avg: label_template_map_avg_fields
  count(columns: [label_template_map_select_column!], distinct: Boolean): Int
  max: label_template_map_max_fields
  min: label_template_map_min_fields
  stddev: label_template_map_stddev_fields
  stddev_pop: label_template_map_stddev_pop_fields
  stddev_samp: label_template_map_stddev_samp_fields
  sum: label_template_map_sum_fields
  var_pop: label_template_map_var_pop_fields
  var_samp: label_template_map_var_samp_fields
  variance: label_template_map_variance_fields
}

# order by aggregate values of table "label_template_map"
input label_template_map_aggregate_order_by {
  avg: label_template_map_avg_order_by
  count: order_by
  max: label_template_map_max_order_by
  min: label_template_map_min_order_by
  stddev: label_template_map_stddev_order_by
  stddev_pop: label_template_map_stddev_pop_order_by
  stddev_samp: label_template_map_stddev_samp_order_by
  sum: label_template_map_sum_order_by
  var_pop: label_template_map_var_pop_order_by
  var_samp: label_template_map_var_samp_order_by
  variance: label_template_map_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input label_template_map_append_input {
  criteria: jsonb
}

# input type for inserting array relation for remote table "label_template_map"
input label_template_map_arr_rel_insert_input {
  data: [label_template_map_insert_input!]!
  on_conflict: label_template_map_on_conflict
}

# aggregate avg on columns
type label_template_map_avg_fields {
  item_id: Float
  sequence: Float
}

# order by avg() on columns of table "label_template_map"
input label_template_map_avg_order_by {
  item_id: order_by
  sequence: order_by
}

# Boolean expression to filter rows from the table "label_template_map". All fields are combined with a logical 'AND'.
input label_template_map_bool_exp {
  _and: [label_template_map_bool_exp]
  _not: label_template_map_bool_exp
  _or: [label_template_map_bool_exp]
  criteria: jsonb_comparison_exp
  item_class: String_comparison_exp
  item_id: Int_comparison_exp
  label: label_bool_exp
  label_id: uuid_comparison_exp
  sequence: smallint_comparison_exp
}

# unique or primary key constraints on table "label_template_map"
enum label_template_map_constraint {
  # unique or primary key constraint
  label_template_map_item_id_label_id_key

  # unique or primary key constraint
  label_template_map_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input label_template_map_delete_at_path_input {
  criteria: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input label_template_map_delete_elem_input {
  criteria: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input label_template_map_delete_key_input {
  criteria: String
}

# input type for incrementing integer column in table "label_template_map"
input label_template_map_inc_input {
  item_id: Int
  sequence: smallint
}

# input type for inserting data into table "label_template_map"
input label_template_map_insert_input {
  criteria: jsonb
  item_class: String
  item_id: Int
  label: label_obj_rel_insert_input
  label_id: uuid
  sequence: smallint
}

# aggregate max on columns
type label_template_map_max_fields {
  item_class: String
  item_id: Int
  label_id: uuid
  sequence: smallint
}

# order by max() on columns of table "label_template_map"
input label_template_map_max_order_by {
  item_class: order_by
  item_id: order_by
  label_id: order_by
  sequence: order_by
}

# aggregate min on columns
type label_template_map_min_fields {
  item_class: String
  item_id: Int
  label_id: uuid
  sequence: smallint
}

# order by min() on columns of table "label_template_map"
input label_template_map_min_order_by {
  item_class: order_by
  item_id: order_by
  label_id: order_by
  sequence: order_by
}

# response of any mutation on the table "label_template_map"
type label_template_map_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [label_template_map!]!
}

# input type for inserting object relation for remote table "label_template_map"
input label_template_map_obj_rel_insert_input {
  data: label_template_map_insert_input!
  on_conflict: label_template_map_on_conflict
}

# on conflict condition type for table "label_template_map"
input label_template_map_on_conflict {
  constraint: label_template_map_constraint!
  update_columns: [label_template_map_update_column!]!
  where: label_template_map_bool_exp
}

# ordering options when selecting data from "label_template_map"
input label_template_map_order_by {
  criteria: order_by
  item_class: order_by
  item_id: order_by
  label: label_order_by
  label_id: order_by
  sequence: order_by
}

# primary key columns input for table: "label_template_map"
input label_template_map_pk_columns_input {
  item_class: String!
  label_id: uuid!
  sequence: smallint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input label_template_map_prepend_input {
  criteria: jsonb
}

# select columns of table "label_template_map"
enum label_template_map_select_column {
  # column name
  criteria

  # column name
  item_class

  # column name
  item_id

  # column name
  label_id

  # column name
  sequence
}

# input type for updating data in table "label_template_map"
input label_template_map_set_input {
  criteria: jsonb
  item_class: String
  item_id: Int
  label_id: uuid
  sequence: smallint
}

# aggregate stddev on columns
type label_template_map_stddev_fields {
  item_id: Float
  sequence: Float
}

# order by stddev() on columns of table "label_template_map"
input label_template_map_stddev_order_by {
  item_id: order_by
  sequence: order_by
}

# aggregate stddev_pop on columns
type label_template_map_stddev_pop_fields {
  item_id: Float
  sequence: Float
}

# order by stddev_pop() on columns of table "label_template_map"
input label_template_map_stddev_pop_order_by {
  item_id: order_by
  sequence: order_by
}

# aggregate stddev_samp on columns
type label_template_map_stddev_samp_fields {
  item_id: Float
  sequence: Float
}

# order by stddev_samp() on columns of table "label_template_map"
input label_template_map_stddev_samp_order_by {
  item_id: order_by
  sequence: order_by
}

# aggregate sum on columns
type label_template_map_sum_fields {
  item_id: Int
  sequence: smallint
}

# order by sum() on columns of table "label_template_map"
input label_template_map_sum_order_by {
  item_id: order_by
  sequence: order_by
}

# update columns of table "label_template_map"
enum label_template_map_update_column {
  # column name
  criteria

  # column name
  item_class

  # column name
  item_id

  # column name
  label_id

  # column name
  sequence
}

# aggregate var_pop on columns
type label_template_map_var_pop_fields {
  item_id: Float
  sequence: Float
}

# order by var_pop() on columns of table "label_template_map"
input label_template_map_var_pop_order_by {
  item_id: order_by
  sequence: order_by
}

# aggregate var_samp on columns
type label_template_map_var_samp_fields {
  item_id: Float
  sequence: Float
}

# order by var_samp() on columns of table "label_template_map"
input label_template_map_var_samp_order_by {
  item_id: order_by
  sequence: order_by
}

# aggregate variance on columns
type label_template_map_variance_fields {
  item_id: Float
  sequence: Float
}

# order by variance() on columns of table "label_template_map"
input label_template_map_variance_order_by {
  item_id: order_by
  sequence: order_by
}

# update columns of table "label"
enum label_update_column {
  # column name
  content

  # column name
  created_at

  # column name
  edit_of_id

  # column name
  height

  # column name
  id

  # column name
  item_id

  # column name
  title

  # column name
  updated_at

  # column name
  width
}

# aggregate var_pop on columns
type label_var_pop_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by var_pop() on columns of table "label"
input label_var_pop_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# aggregate var_samp on columns
type label_var_samp_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by var_samp() on columns of table "label"
input label_var_samp_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# aggregate variance on columns
type label_variance_fields {
  height: Float
  item_id: Float
  width: Float
}

# order by variance() on columns of table "label"
input label_variance_order_by {
  height: order_by
  item_id: order_by
  width: order_by
}

# columns and relationships of "manufacturer"
type manufacturer {
  id: Int!

  # An array relationship
  manufacturer_items(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): [manufacturer_item!]!

  # An aggregated array relationship
  manufacturer_items_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): manufacturer_item_aggregate!
  name: String!
  url: String!

  # An object relationship
  vendor: vendor
  vendor_id: Int
}

# aggregated selection of "manufacturer"
type manufacturer_aggregate {
  aggregate: manufacturer_aggregate_fields
  nodes: [manufacturer!]!
}

# aggregate fields of "manufacturer"
type manufacturer_aggregate_fields {
  avg: manufacturer_avg_fields
  count(columns: [manufacturer_select_column!], distinct: Boolean): Int
  max: manufacturer_max_fields
  min: manufacturer_min_fields
  stddev: manufacturer_stddev_fields
  stddev_pop: manufacturer_stddev_pop_fields
  stddev_samp: manufacturer_stddev_samp_fields
  sum: manufacturer_sum_fields
  var_pop: manufacturer_var_pop_fields
  var_samp: manufacturer_var_samp_fields
  variance: manufacturer_variance_fields
}

# order by aggregate values of table "manufacturer"
input manufacturer_aggregate_order_by {
  avg: manufacturer_avg_order_by
  count: order_by
  max: manufacturer_max_order_by
  min: manufacturer_min_order_by
  stddev: manufacturer_stddev_order_by
  stddev_pop: manufacturer_stddev_pop_order_by
  stddev_samp: manufacturer_stddev_samp_order_by
  sum: manufacturer_sum_order_by
  var_pop: manufacturer_var_pop_order_by
  var_samp: manufacturer_var_samp_order_by
  variance: manufacturer_variance_order_by
}

# input type for inserting array relation for remote table "manufacturer"
input manufacturer_arr_rel_insert_input {
  data: [manufacturer_insert_input!]!
  on_conflict: manufacturer_on_conflict
}

# aggregate avg on columns
type manufacturer_avg_fields {
  id: Float
  vendor_id: Float
}

# order by avg() on columns of table "manufacturer"
input manufacturer_avg_order_by {
  id: order_by
  vendor_id: order_by
}

# Boolean expression to filter rows from the table "manufacturer". All fields are combined with a logical 'AND'.
input manufacturer_bool_exp {
  _and: [manufacturer_bool_exp]
  _not: manufacturer_bool_exp
  _or: [manufacturer_bool_exp]
  id: Int_comparison_exp
  manufacturer_items: manufacturer_item_bool_exp
  name: String_comparison_exp
  url: String_comparison_exp
  vendor: vendor_bool_exp
  vendor_id: Int_comparison_exp
}

# unique or primary key constraints on table "manufacturer"
enum manufacturer_constraint {
  # unique or primary key constraint
  manufacturer_pkey

  # unique or primary key constraint
  manufacturer_vendor_id_key
}

# input type for incrementing integer column in table "manufacturer"
input manufacturer_inc_input {
  id: Int
  vendor_id: Int
}

# input type for inserting data into table "manufacturer"
input manufacturer_insert_input {
  id: Int
  manufacturer_items: manufacturer_item_arr_rel_insert_input
  name: String
  url: String
  vendor: vendor_obj_rel_insert_input
  vendor_id: Int
}

# columns and relationships of "manufacturer_item"
type manufacturer_item {
  id: Int!

  # An object relationship
  item: item!
  item_id: Int!

  # An object relationship
  manufacturer: manufacturer!
  manufacturer_id: Int!

  # example - Cisco 7204VXR
  manufacturer_product_id: String!

  # example - Cisco 7204
  manufacturer_product_name: String

  # example - Cisco 7200 series
  manufacturer_product_series: String

  # An array relationship
  orderItems(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): [order_item!]!

  # An aggregated array relationship
  orderItems_aggregate(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): order_item_aggregate!
  product_url: String
}

# aggregated selection of "manufacturer_item"
type manufacturer_item_aggregate {
  aggregate: manufacturer_item_aggregate_fields
  nodes: [manufacturer_item!]!
}

# aggregate fields of "manufacturer_item"
type manufacturer_item_aggregate_fields {
  avg: manufacturer_item_avg_fields
  count(columns: [manufacturer_item_select_column!], distinct: Boolean): Int
  max: manufacturer_item_max_fields
  min: manufacturer_item_min_fields
  stddev: manufacturer_item_stddev_fields
  stddev_pop: manufacturer_item_stddev_pop_fields
  stddev_samp: manufacturer_item_stddev_samp_fields
  sum: manufacturer_item_sum_fields
  var_pop: manufacturer_item_var_pop_fields
  var_samp: manufacturer_item_var_samp_fields
  variance: manufacturer_item_variance_fields
}

# order by aggregate values of table "manufacturer_item"
input manufacturer_item_aggregate_order_by {
  avg: manufacturer_item_avg_order_by
  count: order_by
  max: manufacturer_item_max_order_by
  min: manufacturer_item_min_order_by
  stddev: manufacturer_item_stddev_order_by
  stddev_pop: manufacturer_item_stddev_pop_order_by
  stddev_samp: manufacturer_item_stddev_samp_order_by
  sum: manufacturer_item_sum_order_by
  var_pop: manufacturer_item_var_pop_order_by
  var_samp: manufacturer_item_var_samp_order_by
  variance: manufacturer_item_variance_order_by
}

# input type for inserting array relation for remote table "manufacturer_item"
input manufacturer_item_arr_rel_insert_input {
  data: [manufacturer_item_insert_input!]!
  on_conflict: manufacturer_item_on_conflict
}

# aggregate avg on columns
type manufacturer_item_avg_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by avg() on columns of table "manufacturer_item"
input manufacturer_item_avg_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# Boolean expression to filter rows from the table "manufacturer_item". All fields are combined with a logical 'AND'.
input manufacturer_item_bool_exp {
  _and: [manufacturer_item_bool_exp]
  _not: manufacturer_item_bool_exp
  _or: [manufacturer_item_bool_exp]
  id: Int_comparison_exp
  item: item_bool_exp
  item_id: Int_comparison_exp
  manufacturer: manufacturer_bool_exp
  manufacturer_id: Int_comparison_exp
  manufacturer_product_id: String_comparison_exp
  manufacturer_product_name: String_comparison_exp
  manufacturer_product_series: String_comparison_exp
  orderItems: order_item_bool_exp
  product_url: String_comparison_exp
}

# unique or primary key constraints on table "manufacturer_item"
enum manufacturer_item_constraint {
  # unique or primary key constraint
  manufacturer_item_id_item_id_key

  # unique or primary key constraint
  manufacturer_item_pkey
}

# input type for incrementing integer column in table "manufacturer_item"
input manufacturer_item_inc_input {
  id: Int
  item_id: Int
  manufacturer_id: Int
}

# input type for inserting data into table "manufacturer_item"
input manufacturer_item_insert_input {
  id: Int
  item: item_obj_rel_insert_input
  item_id: Int
  manufacturer: manufacturer_obj_rel_insert_input
  manufacturer_id: Int
  manufacturer_product_id: String
  manufacturer_product_name: String
  manufacturer_product_series: String
  orderItems: order_item_arr_rel_insert_input
  product_url: String
}

# aggregate max on columns
type manufacturer_item_max_fields {
  id: Int
  item_id: Int
  manufacturer_id: Int
  manufacturer_product_id: String
  manufacturer_product_name: String
  manufacturer_product_series: String
  product_url: String
}

# order by max() on columns of table "manufacturer_item"
input manufacturer_item_max_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_product_id: order_by
  manufacturer_product_name: order_by
  manufacturer_product_series: order_by
  product_url: order_by
}

# aggregate min on columns
type manufacturer_item_min_fields {
  id: Int
  item_id: Int
  manufacturer_id: Int
  manufacturer_product_id: String
  manufacturer_product_name: String
  manufacturer_product_series: String
  product_url: String
}

# order by min() on columns of table "manufacturer_item"
input manufacturer_item_min_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
  manufacturer_product_id: order_by
  manufacturer_product_name: order_by
  manufacturer_product_series: order_by
  product_url: order_by
}

# response of any mutation on the table "manufacturer_item"
type manufacturer_item_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [manufacturer_item!]!
}

# input type for inserting object relation for remote table "manufacturer_item"
input manufacturer_item_obj_rel_insert_input {
  data: manufacturer_item_insert_input!
  on_conflict: manufacturer_item_on_conflict
}

# on conflict condition type for table "manufacturer_item"
input manufacturer_item_on_conflict {
  constraint: manufacturer_item_constraint!
  update_columns: [manufacturer_item_update_column!]!
  where: manufacturer_item_bool_exp
}

# ordering options when selecting data from "manufacturer_item"
input manufacturer_item_order_by {
  id: order_by
  item: item_order_by
  item_id: order_by
  manufacturer: manufacturer_order_by
  manufacturer_id: order_by
  manufacturer_product_id: order_by
  manufacturer_product_name: order_by
  manufacturer_product_series: order_by
  orderItems_aggregate: order_item_aggregate_order_by
  product_url: order_by
}

# primary key columns input for table: "manufacturer_item"
input manufacturer_item_pk_columns_input {
  id: Int!
}

# select columns of table "manufacturer_item"
enum manufacturer_item_select_column {
  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_id

  # column name
  manufacturer_product_id

  # column name
  manufacturer_product_name

  # column name
  manufacturer_product_series

  # column name
  product_url
}

# input type for updating data in table "manufacturer_item"
input manufacturer_item_set_input {
  id: Int
  item_id: Int
  manufacturer_id: Int
  manufacturer_product_id: String
  manufacturer_product_name: String
  manufacturer_product_series: String
  product_url: String
}

# aggregate stddev on columns
type manufacturer_item_stddev_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by stddev() on columns of table "manufacturer_item"
input manufacturer_item_stddev_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# aggregate stddev_pop on columns
type manufacturer_item_stddev_pop_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by stddev_pop() on columns of table "manufacturer_item"
input manufacturer_item_stddev_pop_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# aggregate stddev_samp on columns
type manufacturer_item_stddev_samp_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by stddev_samp() on columns of table "manufacturer_item"
input manufacturer_item_stddev_samp_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# aggregate sum on columns
type manufacturer_item_sum_fields {
  id: Int
  item_id: Int
  manufacturer_id: Int
}

# order by sum() on columns of table "manufacturer_item"
input manufacturer_item_sum_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# update columns of table "manufacturer_item"
enum manufacturer_item_update_column {
  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_id

  # column name
  manufacturer_product_id

  # column name
  manufacturer_product_name

  # column name
  manufacturer_product_series

  # column name
  product_url
}

# aggregate var_pop on columns
type manufacturer_item_var_pop_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by var_pop() on columns of table "manufacturer_item"
input manufacturer_item_var_pop_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# aggregate var_samp on columns
type manufacturer_item_var_samp_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by var_samp() on columns of table "manufacturer_item"
input manufacturer_item_var_samp_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# aggregate variance on columns
type manufacturer_item_variance_fields {
  id: Float
  item_id: Float
  manufacturer_id: Float
}

# order by variance() on columns of table "manufacturer_item"
input manufacturer_item_variance_order_by {
  id: order_by
  item_id: order_by
  manufacturer_id: order_by
}

# aggregate max on columns
type manufacturer_max_fields {
  id: Int
  name: String
  url: String
  vendor_id: Int
}

# order by max() on columns of table "manufacturer"
input manufacturer_max_order_by {
  id: order_by
  name: order_by
  url: order_by
  vendor_id: order_by
}

# aggregate min on columns
type manufacturer_min_fields {
  id: Int
  name: String
  url: String
  vendor_id: Int
}

# order by min() on columns of table "manufacturer"
input manufacturer_min_order_by {
  id: order_by
  name: order_by
  url: order_by
  vendor_id: order_by
}

# response of any mutation on the table "manufacturer"
type manufacturer_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [manufacturer!]!
}

# input type for inserting object relation for remote table "manufacturer"
input manufacturer_obj_rel_insert_input {
  data: manufacturer_insert_input!
  on_conflict: manufacturer_on_conflict
}

# on conflict condition type for table "manufacturer"
input manufacturer_on_conflict {
  constraint: manufacturer_constraint!
  update_columns: [manufacturer_update_column!]!
  where: manufacturer_bool_exp
}

# ordering options when selecting data from "manufacturer"
input manufacturer_order_by {
  id: order_by
  manufacturer_items_aggregate: manufacturer_item_aggregate_order_by
  name: order_by
  url: order_by
  vendor: vendor_order_by
  vendor_id: order_by
}

# primary key columns input for table: "manufacturer"
input manufacturer_pk_columns_input {
  id: Int!
}

# select columns of table "manufacturer"
enum manufacturer_select_column {
  # column name
  id

  # column name
  name

  # column name
  url

  # column name
  vendor_id
}

# input type for updating data in table "manufacturer"
input manufacturer_set_input {
  id: Int
  name: String
  url: String
  vendor_id: Int
}

# aggregate stddev on columns
type manufacturer_stddev_fields {
  id: Float
  vendor_id: Float
}

# order by stddev() on columns of table "manufacturer"
input manufacturer_stddev_order_by {
  id: order_by
  vendor_id: order_by
}

# aggregate stddev_pop on columns
type manufacturer_stddev_pop_fields {
  id: Float
  vendor_id: Float
}

# order by stddev_pop() on columns of table "manufacturer"
input manufacturer_stddev_pop_order_by {
  id: order_by
  vendor_id: order_by
}

# aggregate stddev_samp on columns
type manufacturer_stddev_samp_fields {
  id: Float
  vendor_id: Float
}

# order by stddev_samp() on columns of table "manufacturer"
input manufacturer_stddev_samp_order_by {
  id: order_by
  vendor_id: order_by
}

# aggregate sum on columns
type manufacturer_sum_fields {
  id: Int
  vendor_id: Int
}

# order by sum() on columns of table "manufacturer"
input manufacturer_sum_order_by {
  id: order_by
  vendor_id: order_by
}

# update columns of table "manufacturer"
enum manufacturer_update_column {
  # column name
  id

  # column name
  name

  # column name
  url

  # column name
  vendor_id
}

# aggregate var_pop on columns
type manufacturer_var_pop_fields {
  id: Float
  vendor_id: Float
}

# order by var_pop() on columns of table "manufacturer"
input manufacturer_var_pop_order_by {
  id: order_by
  vendor_id: order_by
}

# aggregate var_samp on columns
type manufacturer_var_samp_fields {
  id: Float
  vendor_id: Float
}

# order by var_samp() on columns of table "manufacturer"
input manufacturer_var_samp_order_by {
  id: order_by
  vendor_id: order_by
}

# aggregate variance on columns
type manufacturer_variance_fields {
  id: Float
  vendor_id: Float
}

# order by variance() on columns of table "manufacturer"
input manufacturer_variance_order_by {
  id: order_by
  vendor_id: order_by
}

scalar money

# expression to compare columns of type money. All fields are combined with logical 'AND'.
input money_comparison_exp {
  _eq: money
  _gt: money
  _gte: money
  _in: [money!]
  _is_null: Boolean
  _lt: money
  _lte: money
  _neq: money
  _nin: [money!]
}

# mutation root
type mutation_root {
  # delete data from the table: "enum_item_cable.connector"
  delete_enum_item_cable_connector(
    # filter the rows which have to be deleted
    where: enum_item_cable_connector_bool_exp!
  ): enum_item_cable_connector_mutation_response

  # delete single row from the table: "enum_item_cable.connector"
  delete_enum_item_cable_connector_by_pk(id: String!): enum_item_cable_connector

  # delete data from the table: "enum.item_class"
  delete_enum_item_class(
    # filter the rows which have to be deleted
    where: enum_item_class_bool_exp!
  ): enum_item_class_mutation_response

  # delete single row from the table: "enum.item_class"
  delete_enum_item_class_by_pk(id: String!): enum_item_class

  # delete data from the table: "enum_item.handedness"
  delete_enum_item_handedness(
    # filter the rows which have to be deleted
    where: enum_item_handedness_bool_exp!
  ): enum_item_handedness_mutation_response

  # delete single row from the table: "enum_item.handedness"
  delete_enum_item_handedness_by_pk(id: String!): enum_item_handedness

  # delete data from the table: "enum_item_hardware_fastener.drive"
  delete_enum_item_hardware_fastener_drive(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_drive_bool_exp!
  ): enum_item_hardware_fastener_drive_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener.drive"
  delete_enum_item_hardware_fastener_drive_by_pk(id: String!): enum_item_hardware_fastener_drive

  # delete data from the table: "enum_item_hardware_fastener.material"
  delete_enum_item_hardware_fastener_material(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_material_bool_exp!
  ): enum_item_hardware_fastener_material_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener.material"
  delete_enum_item_hardware_fastener_material_by_pk(id: String!): enum_item_hardware_fastener_material

  # delete data from the table: "enum_item_hardware_fastener_nut.form"
  delete_enum_item_hardware_fastener_nut_form(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_nut_form_bool_exp!
  ): enum_item_hardware_fastener_nut_form_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_nut.form"
  delete_enum_item_hardware_fastener_nut_form_by_pk(id: String!): enum_item_hardware_fastener_nut_form

  # delete data from the table: "enum_item_hardware_fastener_nut.strength"
  delete_enum_item_hardware_fastener_nut_strength(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_nut_strength_bool_exp!
  ): enum_item_hardware_fastener_nut_strength_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_nut.strength"
  delete_enum_item_hardware_fastener_nut_strength_by_pk(id: String!): enum_item_hardware_fastener_nut_strength

  # delete data from the table: "enum_item_hardware_fastener_nut.thread_fit"
  delete_enum_item_hardware_fastener_nut_thread_fit(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_nut_thread_fit_bool_exp!
  ): enum_item_hardware_fastener_nut_thread_fit_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_nut.thread_fit"
  delete_enum_item_hardware_fastener_nut_thread_fit_by_pk(id: String!): enum_item_hardware_fastener_nut_thread_fit

  # delete data from the table: "enum_item_hardware_fastener_screw.hardness"
  delete_enum_item_hardware_fastener_screw_hardness(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_screw_hardness_bool_exp!
  ): enum_item_hardware_fastener_screw_hardness_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_screw.hardness"
  delete_enum_item_hardware_fastener_screw_hardness_by_pk(id: String!): enum_item_hardware_fastener_screw_hardness

  # delete data from the table: "enum_item_hardware_fastener_screw.head"
  delete_enum_item_hardware_fastener_screw_head(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_screw_head_bool_exp!
  ): enum_item_hardware_fastener_screw_head_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_screw.head"
  delete_enum_item_hardware_fastener_screw_head_by_pk(id: String!): enum_item_hardware_fastener_screw_head

  # delete data from the table: "enum_item_hardware_fastener_screw_machine.point"
  delete_enum_item_hardware_fastener_screw_machine_point(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_screw_machine_point_bool_exp!
  ): enum_item_hardware_fastener_screw_machine_point_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_screw_machine.point"
  delete_enum_item_hardware_fastener_screw_machine_point_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_point

  # delete data from the table: "enum_item_hardware_fastener_screw_machine.strength"
  delete_enum_item_hardware_fastener_screw_machine_strength(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_screw_machine_strength_bool_exp!
  ): enum_item_hardware_fastener_screw_machine_strength_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_screw_machine.strength"
  delete_enum_item_hardware_fastener_screw_machine_strength_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_strength

  # delete data from the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  delete_enum_item_hardware_fastener_screw_machine_thread_fit(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp!
  ): enum_item_hardware_fastener_screw_machine_thread_fit_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  delete_enum_item_hardware_fastener_screw_machine_thread_fit_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_thread_fit

  # delete data from the table: "enum_item_hardware_fastener.standoff_shape"
  delete_enum_item_hardware_fastener_standoff_shape(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_standoff_shape_bool_exp!
  ): enum_item_hardware_fastener_standoff_shape_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener.standoff_shape"
  delete_enum_item_hardware_fastener_standoff_shape_by_pk(id: String!): enum_item_hardware_fastener_standoff_shape

  # delete data from the table: "enum_item_hardware_fastener.thread_label"
  delete_enum_item_hardware_fastener_thread_label(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_thread_label_bool_exp!
  ): enum_item_hardware_fastener_thread_label_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener.thread_label"
  delete_enum_item_hardware_fastener_thread_label_by_pk(id: String!): enum_item_hardware_fastener_thread_label

  # delete data from the table: "enum_item_hardware_fastener.thread_standard"
  delete_enum_item_hardware_fastener_thread_standard(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_thread_standard_bool_exp!
  ): enum_item_hardware_fastener_thread_standard_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener.thread_standard"
  delete_enum_item_hardware_fastener_thread_standard_by_pk(id: String!): enum_item_hardware_fastener_thread_standard

  # delete data from the table: "enum_item_hardware_fastener_washer.form"
  delete_enum_item_hardware_fastener_washer_form(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_washer_form_bool_exp!
  ): enum_item_hardware_fastener_washer_form_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_washer.form"
  delete_enum_item_hardware_fastener_washer_form_by_pk(id: String!): enum_item_hardware_fastener_washer_form

  # delete data from the table: "enum_item_hardware_fastener_washer.mechanism"
  delete_enum_item_hardware_fastener_washer_mechanism(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_washer_mechanism_bool_exp!
  ): enum_item_hardware_fastener_washer_mechanism_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_washer.mechanism"
  delete_enum_item_hardware_fastener_washer_mechanism_by_pk(id: String!): enum_item_hardware_fastener_washer_mechanism

  # delete data from the table: "enum_item_hardware_fastener_washer.pattern"
  delete_enum_item_hardware_fastener_washer_pattern(
    # filter the rows which have to be deleted
    where: enum_item_hardware_fastener_washer_pattern_bool_exp!
  ): enum_item_hardware_fastener_washer_pattern_mutation_response

  # delete single row from the table: "enum_item_hardware_fastener_washer.pattern"
  delete_enum_item_hardware_fastener_washer_pattern_by_pk(id: String!): enum_item_hardware_fastener_washer_pattern

  # delete data from the table: "enum_item_hardware.finish"
  delete_enum_item_hardware_finish(
    # filter the rows which have to be deleted
    where: enum_item_hardware_finish_bool_exp!
  ): enum_item_hardware_finish_mutation_response

  # delete single row from the table: "enum_item_hardware.finish"
  delete_enum_item_hardware_finish_by_pk(id: String!): enum_item_hardware_finish

  # delete data from the table: "enum_item_hardware.use_material"
  delete_enum_item_hardware_use_material(
    # filter the rows which have to be deleted
    where: enum_item_hardware_use_material_bool_exp!
  ): enum_item_hardware_use_material_mutation_response

  # delete single row from the table: "enum_item_hardware.use_material"
  delete_enum_item_hardware_use_material_by_pk(id: String!): enum_item_hardware_use_material

  # delete data from the table: "enum_item_tool.drill_bit_finish"
  delete_enum_item_tool_drill_bit_finish(
    # filter the rows which have to be deleted
    where: enum_item_tool_drill_bit_finish_bool_exp!
  ): enum_item_tool_drill_bit_finish_mutation_response

  # delete single row from the table: "enum_item_tool.drill_bit_finish"
  delete_enum_item_tool_drill_bit_finish_by_pk(id: String!): enum_item_tool_drill_bit_finish

  # delete data from the table: "enum_item_tool.drill_bit_length_class"
  delete_enum_item_tool_drill_bit_length_class(
    # filter the rows which have to be deleted
    where: enum_item_tool_drill_bit_length_class_bool_exp!
  ): enum_item_tool_drill_bit_length_class_mutation_response

  # delete single row from the table: "enum_item_tool.drill_bit_length_class"
  delete_enum_item_tool_drill_bit_length_class_by_pk(id: String!): enum_item_tool_drill_bit_length_class

  # delete data from the table: "enum_item_tool.drill_bit_material"
  delete_enum_item_tool_drill_bit_material(
    # filter the rows which have to be deleted
    where: enum_item_tool_drill_bit_material_bool_exp!
  ): enum_item_tool_drill_bit_material_mutation_response

  # delete single row from the table: "enum_item_tool.drill_bit_material"
  delete_enum_item_tool_drill_bit_material_by_pk(id: String!): enum_item_tool_drill_bit_material

  # delete data from the table: "enum_item_tool.drill_bit_point"
  delete_enum_item_tool_drill_bit_point(
    # filter the rows which have to be deleted
    where: enum_item_tool_drill_bit_point_bool_exp!
  ): enum_item_tool_drill_bit_point_mutation_response

  # delete single row from the table: "enum_item_tool.drill_bit_point"
  delete_enum_item_tool_drill_bit_point_by_pk(id: String!): enum_item_tool_drill_bit_point

  # delete data from the table: "enum_item_tool.drill_bit_shank"
  delete_enum_item_tool_drill_bit_shank(
    # filter the rows which have to be deleted
    where: enum_item_tool_drill_bit_shank_bool_exp!
  ): enum_item_tool_drill_bit_shank_mutation_response

  # delete single row from the table: "enum_item_tool.drill_bit_shank"
  delete_enum_item_tool_drill_bit_shank_by_pk(id: String!): enum_item_tool_drill_bit_shank

  # delete data from the table: "enum_item_tool.drill_bit_style"
  delete_enum_item_tool_drill_bit_style(
    # filter the rows which have to be deleted
    where: enum_item_tool_drill_bit_style_bool_exp!
  ): enum_item_tool_drill_bit_style_mutation_response

  # delete single row from the table: "enum_item_tool.drill_bit_style"
  delete_enum_item_tool_drill_bit_style_by_pk(id: String!): enum_item_tool_drill_bit_style

  # delete data from the table: "enum.mapped_class"
  delete_enum_mapped_class(
    # filter the rows which have to be deleted
    where: enum_mapped_class_bool_exp!
  ): enum_mapped_class_mutation_response

  # delete single row from the table: "enum.mapped_class"
  delete_enum_mapped_class_by_pk(id: String!): enum_mapped_class

  # delete data from the table: "enum.payment_method_type"
  delete_enum_payment_method_type(
    # filter the rows which have to be deleted
    where: enum_payment_method_type_bool_exp!
  ): enum_payment_method_type_mutation_response

  # delete single row from the table: "enum.payment_method_type"
  delete_enum_payment_method_type_by_pk(id: String!): enum_payment_method_type

  # delete data from the table: "enum.space_type"
  delete_enum_space_type(
    # filter the rows which have to be deleted
    where: enum_space_type_bool_exp!
  ): enum_space_type_mutation_response

  # delete single row from the table: "enum.space_type"
  delete_enum_space_type_by_pk(id: String!): enum_space_type

  # delete data from the table: "enum.stock_event_type"
  delete_enum_stock_event_type(
    # filter the rows which have to be deleted
    where: enum_stock_event_type_bool_exp!
  ): enum_stock_event_type_mutation_response

  # delete single row from the table: "enum.stock_event_type"
  delete_enum_stock_event_type_by_pk(id: String!): enum_stock_event_type

  # delete data from the table: "enum.unit"
  delete_enum_unit(
    # filter the rows which have to be deleted
    where: enum_unit_bool_exp!
  ): enum_unit_mutation_response

  # delete single row from the table: "enum.unit"
  delete_enum_unit_by_pk(id: String!): enum_unit

  # delete data from the table: "icon"
  delete_icon(
    # filter the rows which have to be deleted
    where: icon_bool_exp!
  ): icon_mutation_response

  # delete single row from the table: "icon"
  delete_icon_by_pk(id: uuid!): icon

  # delete data from the table: "icon_item_category_map"
  delete_icon_item_category_map(
    # filter the rows which have to be deleted
    where: icon_item_category_map_bool_exp!
  ): icon_item_category_map_mutation_response

  # delete single row from the table: "icon_item_category_map"
  delete_icon_item_category_map_by_pk(category: enum_item_class_enum!, icon_id: uuid!, sequence: smallint!): icon_item_category_map

  # delete data from the table: "icon_item_map"
  delete_icon_item_map(
    # filter the rows which have to be deleted
    where: icon_item_map_bool_exp!
  ): icon_item_map_mutation_response

  # delete single row from the table: "icon_item_map"
  delete_icon_item_map_by_pk(icon_id: uuid!, item_id: Int!): icon_item_map

  # delete data from the table: "icon_label_map"
  delete_icon_label_map(
    # filter the rows which have to be deleted
    where: icon_label_map_bool_exp!
  ): icon_label_map_mutation_response

  # delete single row from the table: "icon_label_map"
  delete_icon_label_map_by_pk(icon_id: uuid!, label_id: uuid!): icon_label_map

  # delete data from the table: "item"
  delete_item(
    # filter the rows which have to be deleted
    where: item_bool_exp!
  ): item_mutation_response

  # delete data from the table: "item.bundle"
  delete_item_bundle(
    # filter the rows which have to be deleted
    where: item_bundle_bool_exp!
  ): item_bundle_mutation_response

  # delete single row from the table: "item.bundle"
  delete_item_bundle_by_pk(id: Int!): item_bundle

  # delete data from the table: "item.bundle_map"
  delete_item_bundle_map(
    # filter the rows which have to be deleted
    where: item_bundle_map_bool_exp!
  ): item_bundle_map_mutation_response

  # delete single row from the table: "item.bundle_map"
  delete_item_bundle_map_by_pk(item_bundle_id: Int!, item_member_id: Int!): item_bundle_map

  # delete single row from the table: "item"
  delete_item_by_pk(id: Int!): item

  # delete data from the table: "item.cable_conductive"
  delete_item_cable_conductive(
    # filter the rows which have to be deleted
    where: item_cable_conductive_bool_exp!
  ): item_cable_conductive_mutation_response

  # delete single row from the table: "item.cable_conductive"
  delete_item_cable_conductive_by_pk(id: Int!): item_cable_conductive

  # delete data from the table: "item.hardware_drill_bit"
  delete_item_hardware_drill_bit(
    # filter the rows which have to be deleted
    where: item_hardware_drill_bit_bool_exp!
  ): item_hardware_drill_bit_mutation_response

  # delete single row from the table: "item.hardware_drill_bit"
  delete_item_hardware_drill_bit_by_pk(id: Int!): item_hardware_drill_bit

  # delete data from the table: "item.hardware_fastener_insert"
  delete_item_hardware_fastener_insert(
    # filter the rows which have to be deleted
    where: item_hardware_fastener_insert_bool_exp!
  ): item_hardware_fastener_insert_mutation_response

  # delete single row from the table: "item.hardware_fastener_insert"
  delete_item_hardware_fastener_insert_by_pk(id: Int!): item_hardware_fastener_insert

  # delete data from the table: "item.hardware_fastener_nut"
  delete_item_hardware_fastener_nut(
    # filter the rows which have to be deleted
    where: item_hardware_fastener_nut_bool_exp!
  ): item_hardware_fastener_nut_mutation_response

  # delete single row from the table: "item.hardware_fastener_nut"
  delete_item_hardware_fastener_nut_by_pk(id: Int!): item_hardware_fastener_nut

  # delete data from the table: "item.hardware_fastener_screw"
  delete_item_hardware_fastener_screw(
    # filter the rows which have to be deleted
    where: item_hardware_fastener_screw_bool_exp!
  ): item_hardware_fastener_screw_mutation_response

  # delete single row from the table: "item.hardware_fastener_screw"
  delete_item_hardware_fastener_screw_by_pk(id: Int!): item_hardware_fastener_screw

  # delete data from the table: "item.hardware_fastener_screw_machine"
  delete_item_hardware_fastener_screw_machine(
    # filter the rows which have to be deleted
    where: item_hardware_fastener_screw_machine_bool_exp!
  ): item_hardware_fastener_screw_machine_mutation_response

  # delete single row from the table: "item.hardware_fastener_screw_machine"
  delete_item_hardware_fastener_screw_machine_by_pk(id: Int!): item_hardware_fastener_screw_machine

  # delete data from the table: "item.hardware_fastener_standoff"
  delete_item_hardware_fastener_standoff(
    # filter the rows which have to be deleted
    where: item_hardware_fastener_standoff_bool_exp!
  ): item_hardware_fastener_standoff_mutation_response

  # delete single row from the table: "item.hardware_fastener_standoff"
  delete_item_hardware_fastener_standoff_by_pk(id: Int!): item_hardware_fastener_standoff

  # delete data from the table: "item.hardware_fastener_washer"
  delete_item_hardware_fastener_washer(
    # filter the rows which have to be deleted
    where: item_hardware_fastener_washer_bool_exp!
  ): item_hardware_fastener_washer_mutation_response

  # delete single row from the table: "item.hardware_fastener_washer"
  delete_item_hardware_fastener_washer_by_pk(id: Int!): item_hardware_fastener_washer

  # delete data from the table: "label"
  delete_label(
    # filter the rows which have to be deleted
    where: label_bool_exp!
  ): label_mutation_response

  # delete single row from the table: "label"
  delete_label_by_pk(id: uuid!): label

  # delete data from the table: "label_item_map"
  delete_label_item_map(
    # filter the rows which have to be deleted
    where: label_item_map_bool_exp!
  ): label_item_map_mutation_response

  # delete single row from the table: "label_item_map"
  delete_label_item_map_by_pk(item_id: Int!, label_id: uuid!): label_item_map

  # delete data from the table: "label_template_map"
  delete_label_template_map(
    # filter the rows which have to be deleted
    where: label_template_map_bool_exp!
  ): label_template_map_mutation_response

  # delete single row from the table: "label_template_map"
  delete_label_template_map_by_pk(item_class: String!, label_id: uuid!, sequence: smallint!): label_template_map

  # delete data from the table: "manufacturer"
  delete_manufacturer(
    # filter the rows which have to be deleted
    where: manufacturer_bool_exp!
  ): manufacturer_mutation_response

  # delete single row from the table: "manufacturer"
  delete_manufacturer_by_pk(id: Int!): manufacturer

  # delete data from the table: "manufacturer_item"
  delete_manufacturer_item(
    # filter the rows which have to be deleted
    where: manufacturer_item_bool_exp!
  ): manufacturer_item_mutation_response

  # delete single row from the table: "manufacturer_item"
  delete_manufacturer_item_by_pk(id: Int!): manufacturer_item

  # delete data from the table: "order"
  delete_order(
    # filter the rows which have to be deleted
    where: order_bool_exp!
  ): order_mutation_response

  # delete single row from the table: "order"
  delete_order_by_pk(id: Int!): order

  # delete data from the table: "order_item"
  delete_order_item(
    # filter the rows which have to be deleted
    where: order_item_bool_exp!
  ): order_item_mutation_response

  # delete single row from the table: "order_item"
  delete_order_item_by_pk(id: Int!): order_item

  # delete data from the table: "payment_method"
  delete_payment_method(
    # filter the rows which have to be deleted
    where: payment_method_bool_exp!
  ): payment_method_mutation_response

  # delete single row from the table: "payment_method"
  delete_payment_method_by_pk(id: Int!): payment_method

  # delete data from the table: "property.item_hardware_fastener_bolt_strength"
  delete_property_item_hardware_fastener_bolt_strength(
    # filter the rows which have to be deleted
    where: property_item_hardware_fastener_bolt_strength_bool_exp!
  ): property_item_hardware_fastener_bolt_strength_mutation_response

  # delete single row from the table: "property.item_hardware_fastener_bolt_strength"
  delete_property_item_hardware_fastener_bolt_strength_by_pk(diameter: numeric!, strength_grade: String!, thread_pitch: numeric!): property_item_hardware_fastener_bolt_strength

  # delete data from the table: "property_item_hardware_fastener_screw_machine.diameter"
  delete_property_item_hardware_fastener_screw_machine_diameter(
    # filter the rows which have to be deleted
    where: property_item_hardware_fastener_screw_machine_diameter_bool_exp!
  ): property_item_hardware_fastener_screw_machine_diameter_mutation_response

  # delete single row from the table: "property_item_hardware_fastener_screw_machine.diameter"
  delete_property_item_hardware_fastener_screw_machine_diameter_by_pk(diameter_major: numeric!, fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum!, pitch: numeric!): property_item_hardware_fastener_screw_machine_diameter

  # delete data from the table: "search_data"
  delete_search_data(
    # filter the rows which have to be deleted
    where: search_data_bool_exp!
  ): search_data_mutation_response

  # delete single row from the table: "search_data"
  delete_search_data_by_pk(id: bigint!): search_data

  # delete data from the table: "shipment"
  delete_shipment(
    # filter the rows which have to be deleted
    where: shipment_bool_exp!
  ): shipment_mutation_response

  # delete single row from the table: "shipment"
  delete_shipment_by_pk(id: Int!): shipment

  # delete data from the table: "stock"
  delete_stock(
    # filter the rows which have to be deleted
    where: stock_bool_exp!
  ): stock_mutation_response

  # delete single row from the table: "stock"
  delete_stock_by_pk(id: Int!): stock

  # delete data from the table: "storage"
  delete_storage(
    # filter the rows which have to be deleted
    where: storage_bool_exp!
  ): storage_mutation_response

  # delete single row from the table: "storage"
  delete_storage_by_pk(id: Int!): storage

  # delete data from the table: "tag"
  delete_tag(
    # filter the rows which have to be deleted
    where: tag_bool_exp!
  ): tag_mutation_response

  # delete single row from the table: "tag"
  delete_tag_by_pk(text: String!): tag

  # delete data from the table: "vendor"
  delete_vendor(
    # filter the rows which have to be deleted
    where: vendor_bool_exp!
  ): vendor_mutation_response

  # delete single row from the table: "vendor"
  delete_vendor_by_pk(id: Int!): vendor

  # delete data from the table: "vendor_item"
  delete_vendor_item(
    # filter the rows which have to be deleted
    where: vendor_item_bool_exp!
  ): vendor_item_mutation_response

  # delete single row from the table: "vendor_item"
  delete_vendor_item_by_pk(id: Int!): vendor_item

  # insert data into the table: "enum_item_cable.connector"
  insert_enum_item_cable_connector(
    # the rows to be inserted
    objects: [enum_item_cable_connector_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_cable_connector_on_conflict
  ): enum_item_cable_connector_mutation_response

  # insert a single row into the table: "enum_item_cable.connector"
  insert_enum_item_cable_connector_one(
    # the row to be inserted
    object: enum_item_cable_connector_insert_input!

    # on conflict condition
    on_conflict: enum_item_cable_connector_on_conflict
  ): enum_item_cable_connector

  # insert data into the table: "enum.item_class"
  insert_enum_item_class(
    # the rows to be inserted
    objects: [enum_item_class_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_class_on_conflict
  ): enum_item_class_mutation_response

  # insert a single row into the table: "enum.item_class"
  insert_enum_item_class_one(
    # the row to be inserted
    object: enum_item_class_insert_input!

    # on conflict condition
    on_conflict: enum_item_class_on_conflict
  ): enum_item_class

  # insert data into the table: "enum_item.handedness"
  insert_enum_item_handedness(
    # the rows to be inserted
    objects: [enum_item_handedness_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_handedness_on_conflict
  ): enum_item_handedness_mutation_response

  # insert a single row into the table: "enum_item.handedness"
  insert_enum_item_handedness_one(
    # the row to be inserted
    object: enum_item_handedness_insert_input!

    # on conflict condition
    on_conflict: enum_item_handedness_on_conflict
  ): enum_item_handedness

  # insert data into the table: "enum_item_hardware_fastener.drive"
  insert_enum_item_hardware_fastener_drive(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_drive_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_drive_on_conflict
  ): enum_item_hardware_fastener_drive_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener.drive"
  insert_enum_item_hardware_fastener_drive_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_drive_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_drive_on_conflict
  ): enum_item_hardware_fastener_drive

  # insert data into the table: "enum_item_hardware_fastener.material"
  insert_enum_item_hardware_fastener_material(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_material_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_material_on_conflict
  ): enum_item_hardware_fastener_material_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener.material"
  insert_enum_item_hardware_fastener_material_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_material_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_material_on_conflict
  ): enum_item_hardware_fastener_material

  # insert data into the table: "enum_item_hardware_fastener_nut.form"
  insert_enum_item_hardware_fastener_nut_form(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_nut_form_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_nut_form_on_conflict
  ): enum_item_hardware_fastener_nut_form_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_nut.form"
  insert_enum_item_hardware_fastener_nut_form_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_nut_form_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_nut_form_on_conflict
  ): enum_item_hardware_fastener_nut_form

  # insert data into the table: "enum_item_hardware_fastener_nut.strength"
  insert_enum_item_hardware_fastener_nut_strength(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_nut_strength_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_nut_strength_on_conflict
  ): enum_item_hardware_fastener_nut_strength_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_nut.strength"
  insert_enum_item_hardware_fastener_nut_strength_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_nut_strength_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_nut_strength_on_conflict
  ): enum_item_hardware_fastener_nut_strength

  # insert data into the table: "enum_item_hardware_fastener_nut.thread_fit"
  insert_enum_item_hardware_fastener_nut_thread_fit(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_nut_thread_fit_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_nut_thread_fit_on_conflict
  ): enum_item_hardware_fastener_nut_thread_fit_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_nut.thread_fit"
  insert_enum_item_hardware_fastener_nut_thread_fit_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_nut_thread_fit_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_nut_thread_fit_on_conflict
  ): enum_item_hardware_fastener_nut_thread_fit

  # insert data into the table: "enum_item_hardware_fastener_screw.hardness"
  insert_enum_item_hardware_fastener_screw_hardness(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_screw_hardness_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_hardness_on_conflict
  ): enum_item_hardware_fastener_screw_hardness_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_screw.hardness"
  insert_enum_item_hardware_fastener_screw_hardness_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_screw_hardness_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_hardness_on_conflict
  ): enum_item_hardware_fastener_screw_hardness

  # insert data into the table: "enum_item_hardware_fastener_screw.head"
  insert_enum_item_hardware_fastener_screw_head(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_screw_head_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_head_on_conflict
  ): enum_item_hardware_fastener_screw_head_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_screw.head"
  insert_enum_item_hardware_fastener_screw_head_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_screw_head_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_head_on_conflict
  ): enum_item_hardware_fastener_screw_head

  # insert data into the table: "enum_item_hardware_fastener_screw_machine.point"
  insert_enum_item_hardware_fastener_screw_machine_point(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_screw_machine_point_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_machine_point_on_conflict
  ): enum_item_hardware_fastener_screw_machine_point_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_screw_machine.point"
  insert_enum_item_hardware_fastener_screw_machine_point_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_screw_machine_point_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_machine_point_on_conflict
  ): enum_item_hardware_fastener_screw_machine_point

  # insert data into the table: "enum_item_hardware_fastener_screw_machine.strength"
  insert_enum_item_hardware_fastener_screw_machine_strength(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_screw_machine_strength_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_machine_strength_on_conflict
  ): enum_item_hardware_fastener_screw_machine_strength_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_screw_machine.strength"
  insert_enum_item_hardware_fastener_screw_machine_strength_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_screw_machine_strength_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_machine_strength_on_conflict
  ): enum_item_hardware_fastener_screw_machine_strength

  # insert data into the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  insert_enum_item_hardware_fastener_screw_machine_thread_fit(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_screw_machine_thread_fit_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_machine_thread_fit_on_conflict
  ): enum_item_hardware_fastener_screw_machine_thread_fit_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  insert_enum_item_hardware_fastener_screw_machine_thread_fit_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_screw_machine_thread_fit_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_screw_machine_thread_fit_on_conflict
  ): enum_item_hardware_fastener_screw_machine_thread_fit

  # insert data into the table: "enum_item_hardware_fastener.standoff_shape"
  insert_enum_item_hardware_fastener_standoff_shape(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_standoff_shape_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_standoff_shape_on_conflict
  ): enum_item_hardware_fastener_standoff_shape_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener.standoff_shape"
  insert_enum_item_hardware_fastener_standoff_shape_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_standoff_shape_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_standoff_shape_on_conflict
  ): enum_item_hardware_fastener_standoff_shape

  # insert data into the table: "enum_item_hardware_fastener.thread_label"
  insert_enum_item_hardware_fastener_thread_label(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_thread_label_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_thread_label_on_conflict
  ): enum_item_hardware_fastener_thread_label_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener.thread_label"
  insert_enum_item_hardware_fastener_thread_label_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_thread_label_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_thread_label_on_conflict
  ): enum_item_hardware_fastener_thread_label

  # insert data into the table: "enum_item_hardware_fastener.thread_standard"
  insert_enum_item_hardware_fastener_thread_standard(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_thread_standard_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_thread_standard_on_conflict
  ): enum_item_hardware_fastener_thread_standard_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener.thread_standard"
  insert_enum_item_hardware_fastener_thread_standard_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_thread_standard_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_thread_standard_on_conflict
  ): enum_item_hardware_fastener_thread_standard

  # insert data into the table: "enum_item_hardware_fastener_washer.form"
  insert_enum_item_hardware_fastener_washer_form(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_washer_form_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_washer_form_on_conflict
  ): enum_item_hardware_fastener_washer_form_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_washer.form"
  insert_enum_item_hardware_fastener_washer_form_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_washer_form_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_washer_form_on_conflict
  ): enum_item_hardware_fastener_washer_form

  # insert data into the table: "enum_item_hardware_fastener_washer.mechanism"
  insert_enum_item_hardware_fastener_washer_mechanism(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_washer_mechanism_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_washer_mechanism_on_conflict
  ): enum_item_hardware_fastener_washer_mechanism_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_washer.mechanism"
  insert_enum_item_hardware_fastener_washer_mechanism_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_washer_mechanism_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_washer_mechanism_on_conflict
  ): enum_item_hardware_fastener_washer_mechanism

  # insert data into the table: "enum_item_hardware_fastener_washer.pattern"
  insert_enum_item_hardware_fastener_washer_pattern(
    # the rows to be inserted
    objects: [enum_item_hardware_fastener_washer_pattern_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_washer_pattern_on_conflict
  ): enum_item_hardware_fastener_washer_pattern_mutation_response

  # insert a single row into the table: "enum_item_hardware_fastener_washer.pattern"
  insert_enum_item_hardware_fastener_washer_pattern_one(
    # the row to be inserted
    object: enum_item_hardware_fastener_washer_pattern_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_fastener_washer_pattern_on_conflict
  ): enum_item_hardware_fastener_washer_pattern

  # insert data into the table: "enum_item_hardware.finish"
  insert_enum_item_hardware_finish(
    # the rows to be inserted
    objects: [enum_item_hardware_finish_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_finish_on_conflict
  ): enum_item_hardware_finish_mutation_response

  # insert a single row into the table: "enum_item_hardware.finish"
  insert_enum_item_hardware_finish_one(
    # the row to be inserted
    object: enum_item_hardware_finish_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_finish_on_conflict
  ): enum_item_hardware_finish

  # insert data into the table: "enum_item_hardware.use_material"
  insert_enum_item_hardware_use_material(
    # the rows to be inserted
    objects: [enum_item_hardware_use_material_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_hardware_use_material_on_conflict
  ): enum_item_hardware_use_material_mutation_response

  # insert a single row into the table: "enum_item_hardware.use_material"
  insert_enum_item_hardware_use_material_one(
    # the row to be inserted
    object: enum_item_hardware_use_material_insert_input!

    # on conflict condition
    on_conflict: enum_item_hardware_use_material_on_conflict
  ): enum_item_hardware_use_material

  # insert data into the table: "enum_item_tool.drill_bit_finish"
  insert_enum_item_tool_drill_bit_finish(
    # the rows to be inserted
    objects: [enum_item_tool_drill_bit_finish_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_finish_on_conflict
  ): enum_item_tool_drill_bit_finish_mutation_response

  # insert a single row into the table: "enum_item_tool.drill_bit_finish"
  insert_enum_item_tool_drill_bit_finish_one(
    # the row to be inserted
    object: enum_item_tool_drill_bit_finish_insert_input!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_finish_on_conflict
  ): enum_item_tool_drill_bit_finish

  # insert data into the table: "enum_item_tool.drill_bit_length_class"
  insert_enum_item_tool_drill_bit_length_class(
    # the rows to be inserted
    objects: [enum_item_tool_drill_bit_length_class_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_length_class_on_conflict
  ): enum_item_tool_drill_bit_length_class_mutation_response

  # insert a single row into the table: "enum_item_tool.drill_bit_length_class"
  insert_enum_item_tool_drill_bit_length_class_one(
    # the row to be inserted
    object: enum_item_tool_drill_bit_length_class_insert_input!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_length_class_on_conflict
  ): enum_item_tool_drill_bit_length_class

  # insert data into the table: "enum_item_tool.drill_bit_material"
  insert_enum_item_tool_drill_bit_material(
    # the rows to be inserted
    objects: [enum_item_tool_drill_bit_material_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_material_on_conflict
  ): enum_item_tool_drill_bit_material_mutation_response

  # insert a single row into the table: "enum_item_tool.drill_bit_material"
  insert_enum_item_tool_drill_bit_material_one(
    # the row to be inserted
    object: enum_item_tool_drill_bit_material_insert_input!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_material_on_conflict
  ): enum_item_tool_drill_bit_material

  # insert data into the table: "enum_item_tool.drill_bit_point"
  insert_enum_item_tool_drill_bit_point(
    # the rows to be inserted
    objects: [enum_item_tool_drill_bit_point_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_point_on_conflict
  ): enum_item_tool_drill_bit_point_mutation_response

  # insert a single row into the table: "enum_item_tool.drill_bit_point"
  insert_enum_item_tool_drill_bit_point_one(
    # the row to be inserted
    object: enum_item_tool_drill_bit_point_insert_input!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_point_on_conflict
  ): enum_item_tool_drill_bit_point

  # insert data into the table: "enum_item_tool.drill_bit_shank"
  insert_enum_item_tool_drill_bit_shank(
    # the rows to be inserted
    objects: [enum_item_tool_drill_bit_shank_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_shank_on_conflict
  ): enum_item_tool_drill_bit_shank_mutation_response

  # insert a single row into the table: "enum_item_tool.drill_bit_shank"
  insert_enum_item_tool_drill_bit_shank_one(
    # the row to be inserted
    object: enum_item_tool_drill_bit_shank_insert_input!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_shank_on_conflict
  ): enum_item_tool_drill_bit_shank

  # insert data into the table: "enum_item_tool.drill_bit_style"
  insert_enum_item_tool_drill_bit_style(
    # the rows to be inserted
    objects: [enum_item_tool_drill_bit_style_insert_input!]!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_style_on_conflict
  ): enum_item_tool_drill_bit_style_mutation_response

  # insert a single row into the table: "enum_item_tool.drill_bit_style"
  insert_enum_item_tool_drill_bit_style_one(
    # the row to be inserted
    object: enum_item_tool_drill_bit_style_insert_input!

    # on conflict condition
    on_conflict: enum_item_tool_drill_bit_style_on_conflict
  ): enum_item_tool_drill_bit_style

  # insert data into the table: "enum.mapped_class"
  insert_enum_mapped_class(
    # the rows to be inserted
    objects: [enum_mapped_class_insert_input!]!

    # on conflict condition
    on_conflict: enum_mapped_class_on_conflict
  ): enum_mapped_class_mutation_response

  # insert a single row into the table: "enum.mapped_class"
  insert_enum_mapped_class_one(
    # the row to be inserted
    object: enum_mapped_class_insert_input!

    # on conflict condition
    on_conflict: enum_mapped_class_on_conflict
  ): enum_mapped_class

  # insert data into the table: "enum.payment_method_type"
  insert_enum_payment_method_type(
    # the rows to be inserted
    objects: [enum_payment_method_type_insert_input!]!

    # on conflict condition
    on_conflict: enum_payment_method_type_on_conflict
  ): enum_payment_method_type_mutation_response

  # insert a single row into the table: "enum.payment_method_type"
  insert_enum_payment_method_type_one(
    # the row to be inserted
    object: enum_payment_method_type_insert_input!

    # on conflict condition
    on_conflict: enum_payment_method_type_on_conflict
  ): enum_payment_method_type

  # insert data into the table: "enum.space_type"
  insert_enum_space_type(
    # the rows to be inserted
    objects: [enum_space_type_insert_input!]!

    # on conflict condition
    on_conflict: enum_space_type_on_conflict
  ): enum_space_type_mutation_response

  # insert a single row into the table: "enum.space_type"
  insert_enum_space_type_one(
    # the row to be inserted
    object: enum_space_type_insert_input!

    # on conflict condition
    on_conflict: enum_space_type_on_conflict
  ): enum_space_type

  # insert data into the table: "enum.stock_event_type"
  insert_enum_stock_event_type(
    # the rows to be inserted
    objects: [enum_stock_event_type_insert_input!]!

    # on conflict condition
    on_conflict: enum_stock_event_type_on_conflict
  ): enum_stock_event_type_mutation_response

  # insert a single row into the table: "enum.stock_event_type"
  insert_enum_stock_event_type_one(
    # the row to be inserted
    object: enum_stock_event_type_insert_input!

    # on conflict condition
    on_conflict: enum_stock_event_type_on_conflict
  ): enum_stock_event_type

  # insert data into the table: "enum.unit"
  insert_enum_unit(
    # the rows to be inserted
    objects: [enum_unit_insert_input!]!

    # on conflict condition
    on_conflict: enum_unit_on_conflict
  ): enum_unit_mutation_response

  # insert a single row into the table: "enum.unit"
  insert_enum_unit_one(
    # the row to be inserted
    object: enum_unit_insert_input!

    # on conflict condition
    on_conflict: enum_unit_on_conflict
  ): enum_unit

  # insert data into the table: "icon"
  insert_icon(
    # the rows to be inserted
    objects: [icon_insert_input!]!

    # on conflict condition
    on_conflict: icon_on_conflict
  ): icon_mutation_response

  # insert data into the table: "icon_item_category_map"
  insert_icon_item_category_map(
    # the rows to be inserted
    objects: [icon_item_category_map_insert_input!]!

    # on conflict condition
    on_conflict: icon_item_category_map_on_conflict
  ): icon_item_category_map_mutation_response

  # insert a single row into the table: "icon_item_category_map"
  insert_icon_item_category_map_one(
    # the row to be inserted
    object: icon_item_category_map_insert_input!

    # on conflict condition
    on_conflict: icon_item_category_map_on_conflict
  ): icon_item_category_map

  # insert data into the table: "icon_item_map"
  insert_icon_item_map(
    # the rows to be inserted
    objects: [icon_item_map_insert_input!]!

    # on conflict condition
    on_conflict: icon_item_map_on_conflict
  ): icon_item_map_mutation_response

  # insert a single row into the table: "icon_item_map"
  insert_icon_item_map_one(
    # the row to be inserted
    object: icon_item_map_insert_input!

    # on conflict condition
    on_conflict: icon_item_map_on_conflict
  ): icon_item_map

  # insert data into the table: "icon_label_map"
  insert_icon_label_map(
    # the rows to be inserted
    objects: [icon_label_map_insert_input!]!

    # on conflict condition
    on_conflict: icon_label_map_on_conflict
  ): icon_label_map_mutation_response

  # insert a single row into the table: "icon_label_map"
  insert_icon_label_map_one(
    # the row to be inserted
    object: icon_label_map_insert_input!

    # on conflict condition
    on_conflict: icon_label_map_on_conflict
  ): icon_label_map

  # insert a single row into the table: "icon"
  insert_icon_one(
    # the row to be inserted
    object: icon_insert_input!

    # on conflict condition
    on_conflict: icon_on_conflict
  ): icon

  # insert data into the table: "item"
  insert_item(
    # the rows to be inserted
    objects: [item_insert_input!]!

    # on conflict condition
    on_conflict: item_on_conflict
  ): item_mutation_response

  # insert data into the table: "item.bundle"
  insert_item_bundle(
    # the rows to be inserted
    objects: [item_bundle_insert_input!]!

    # on conflict condition
    on_conflict: item_bundle_on_conflict
  ): item_bundle_mutation_response

  # insert data into the table: "item.bundle_map"
  insert_item_bundle_map(
    # the rows to be inserted
    objects: [item_bundle_map_insert_input!]!

    # on conflict condition
    on_conflict: item_bundle_map_on_conflict
  ): item_bundle_map_mutation_response

  # insert a single row into the table: "item.bundle_map"
  insert_item_bundle_map_one(
    # the row to be inserted
    object: item_bundle_map_insert_input!

    # on conflict condition
    on_conflict: item_bundle_map_on_conflict
  ): item_bundle_map

  # insert a single row into the table: "item.bundle"
  insert_item_bundle_one(
    # the row to be inserted
    object: item_bundle_insert_input!

    # on conflict condition
    on_conflict: item_bundle_on_conflict
  ): item_bundle

  # insert data into the table: "item.cable_conductive"
  insert_item_cable_conductive(
    # the rows to be inserted
    objects: [item_cable_conductive_insert_input!]!

    # on conflict condition
    on_conflict: item_cable_conductive_on_conflict
  ): item_cable_conductive_mutation_response

  # insert a single row into the table: "item.cable_conductive"
  insert_item_cable_conductive_one(
    # the row to be inserted
    object: item_cable_conductive_insert_input!

    # on conflict condition
    on_conflict: item_cable_conductive_on_conflict
  ): item_cable_conductive

  # insert data into the table: "item.hardware_drill_bit"
  insert_item_hardware_drill_bit(
    # the rows to be inserted
    objects: [item_hardware_drill_bit_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_drill_bit_on_conflict
  ): item_hardware_drill_bit_mutation_response

  # insert a single row into the table: "item.hardware_drill_bit"
  insert_item_hardware_drill_bit_one(
    # the row to be inserted
    object: item_hardware_drill_bit_insert_input!

    # on conflict condition
    on_conflict: item_hardware_drill_bit_on_conflict
  ): item_hardware_drill_bit

  # insert data into the table: "item.hardware_fastener_insert"
  insert_item_hardware_fastener_insert(
    # the rows to be inserted
    objects: [item_hardware_fastener_insert_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_fastener_insert_on_conflict
  ): item_hardware_fastener_insert_mutation_response

  # insert a single row into the table: "item.hardware_fastener_insert"
  insert_item_hardware_fastener_insert_one(
    # the row to be inserted
    object: item_hardware_fastener_insert_insert_input!

    # on conflict condition
    on_conflict: item_hardware_fastener_insert_on_conflict
  ): item_hardware_fastener_insert

  # insert data into the table: "item.hardware_fastener_nut"
  insert_item_hardware_fastener_nut(
    # the rows to be inserted
    objects: [item_hardware_fastener_nut_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_fastener_nut_on_conflict
  ): item_hardware_fastener_nut_mutation_response

  # insert a single row into the table: "item.hardware_fastener_nut"
  insert_item_hardware_fastener_nut_one(
    # the row to be inserted
    object: item_hardware_fastener_nut_insert_input!

    # on conflict condition
    on_conflict: item_hardware_fastener_nut_on_conflict
  ): item_hardware_fastener_nut

  # insert data into the table: "item.hardware_fastener_screw"
  insert_item_hardware_fastener_screw(
    # the rows to be inserted
    objects: [item_hardware_fastener_screw_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_fastener_screw_on_conflict
  ): item_hardware_fastener_screw_mutation_response

  # insert data into the table: "item.hardware_fastener_screw_machine"
  insert_item_hardware_fastener_screw_machine(
    # the rows to be inserted
    objects: [item_hardware_fastener_screw_machine_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_fastener_screw_machine_on_conflict
  ): item_hardware_fastener_screw_machine_mutation_response

  # insert a single row into the table: "item.hardware_fastener_screw_machine"
  insert_item_hardware_fastener_screw_machine_one(
    # the row to be inserted
    object: item_hardware_fastener_screw_machine_insert_input!

    # on conflict condition
    on_conflict: item_hardware_fastener_screw_machine_on_conflict
  ): item_hardware_fastener_screw_machine

  # insert a single row into the table: "item.hardware_fastener_screw"
  insert_item_hardware_fastener_screw_one(
    # the row to be inserted
    object: item_hardware_fastener_screw_insert_input!

    # on conflict condition
    on_conflict: item_hardware_fastener_screw_on_conflict
  ): item_hardware_fastener_screw

  # insert data into the table: "item.hardware_fastener_standoff"
  insert_item_hardware_fastener_standoff(
    # the rows to be inserted
    objects: [item_hardware_fastener_standoff_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_fastener_standoff_on_conflict
  ): item_hardware_fastener_standoff_mutation_response

  # insert a single row into the table: "item.hardware_fastener_standoff"
  insert_item_hardware_fastener_standoff_one(
    # the row to be inserted
    object: item_hardware_fastener_standoff_insert_input!

    # on conflict condition
    on_conflict: item_hardware_fastener_standoff_on_conflict
  ): item_hardware_fastener_standoff

  # insert data into the table: "item.hardware_fastener_washer"
  insert_item_hardware_fastener_washer(
    # the rows to be inserted
    objects: [item_hardware_fastener_washer_insert_input!]!

    # on conflict condition
    on_conflict: item_hardware_fastener_washer_on_conflict
  ): item_hardware_fastener_washer_mutation_response

  # insert a single row into the table: "item.hardware_fastener_washer"
  insert_item_hardware_fastener_washer_one(
    # the row to be inserted
    object: item_hardware_fastener_washer_insert_input!

    # on conflict condition
    on_conflict: item_hardware_fastener_washer_on_conflict
  ): item_hardware_fastener_washer

  # insert a single row into the table: "item"
  insert_item_one(
    # the row to be inserted
    object: item_insert_input!

    # on conflict condition
    on_conflict: item_on_conflict
  ): item

  # insert data into the table: "label"
  insert_label(
    # the rows to be inserted
    objects: [label_insert_input!]!

    # on conflict condition
    on_conflict: label_on_conflict
  ): label_mutation_response

  # insert data into the table: "label_item_map"
  insert_label_item_map(
    # the rows to be inserted
    objects: [label_item_map_insert_input!]!

    # on conflict condition
    on_conflict: label_item_map_on_conflict
  ): label_item_map_mutation_response

  # insert a single row into the table: "label_item_map"
  insert_label_item_map_one(
    # the row to be inserted
    object: label_item_map_insert_input!

    # on conflict condition
    on_conflict: label_item_map_on_conflict
  ): label_item_map

  # insert a single row into the table: "label"
  insert_label_one(
    # the row to be inserted
    object: label_insert_input!

    # on conflict condition
    on_conflict: label_on_conflict
  ): label

  # insert data into the table: "label_template_map"
  insert_label_template_map(
    # the rows to be inserted
    objects: [label_template_map_insert_input!]!

    # on conflict condition
    on_conflict: label_template_map_on_conflict
  ): label_template_map_mutation_response

  # insert a single row into the table: "label_template_map"
  insert_label_template_map_one(
    # the row to be inserted
    object: label_template_map_insert_input!

    # on conflict condition
    on_conflict: label_template_map_on_conflict
  ): label_template_map

  # insert data into the table: "manufacturer"
  insert_manufacturer(
    # the rows to be inserted
    objects: [manufacturer_insert_input!]!

    # on conflict condition
    on_conflict: manufacturer_on_conflict
  ): manufacturer_mutation_response

  # insert data into the table: "manufacturer_item"
  insert_manufacturer_item(
    # the rows to be inserted
    objects: [manufacturer_item_insert_input!]!

    # on conflict condition
    on_conflict: manufacturer_item_on_conflict
  ): manufacturer_item_mutation_response

  # insert a single row into the table: "manufacturer_item"
  insert_manufacturer_item_one(
    # the row to be inserted
    object: manufacturer_item_insert_input!

    # on conflict condition
    on_conflict: manufacturer_item_on_conflict
  ): manufacturer_item

  # insert a single row into the table: "manufacturer"
  insert_manufacturer_one(
    # the row to be inserted
    object: manufacturer_insert_input!

    # on conflict condition
    on_conflict: manufacturer_on_conflict
  ): manufacturer

  # insert data into the table: "order"
  insert_order(
    # the rows to be inserted
    objects: [order_insert_input!]!

    # on conflict condition
    on_conflict: order_on_conflict
  ): order_mutation_response

  # insert data into the table: "order_item"
  insert_order_item(
    # the rows to be inserted
    objects: [order_item_insert_input!]!

    # on conflict condition
    on_conflict: order_item_on_conflict
  ): order_item_mutation_response

  # insert a single row into the table: "order_item"
  insert_order_item_one(
    # the row to be inserted
    object: order_item_insert_input!

    # on conflict condition
    on_conflict: order_item_on_conflict
  ): order_item

  # insert a single row into the table: "order"
  insert_order_one(
    # the row to be inserted
    object: order_insert_input!

    # on conflict condition
    on_conflict: order_on_conflict
  ): order

  # insert data into the table: "payment_method"
  insert_payment_method(
    # the rows to be inserted
    objects: [payment_method_insert_input!]!

    # on conflict condition
    on_conflict: payment_method_on_conflict
  ): payment_method_mutation_response

  # insert a single row into the table: "payment_method"
  insert_payment_method_one(
    # the row to be inserted
    object: payment_method_insert_input!

    # on conflict condition
    on_conflict: payment_method_on_conflict
  ): payment_method

  # insert data into the table: "property.item_hardware_fastener_bolt_strength"
  insert_property_item_hardware_fastener_bolt_strength(
    # the rows to be inserted
    objects: [property_item_hardware_fastener_bolt_strength_insert_input!]!

    # on conflict condition
    on_conflict: property_item_hardware_fastener_bolt_strength_on_conflict
  ): property_item_hardware_fastener_bolt_strength_mutation_response

  # insert a single row into the table: "property.item_hardware_fastener_bolt_strength"
  insert_property_item_hardware_fastener_bolt_strength_one(
    # the row to be inserted
    object: property_item_hardware_fastener_bolt_strength_insert_input!

    # on conflict condition
    on_conflict: property_item_hardware_fastener_bolt_strength_on_conflict
  ): property_item_hardware_fastener_bolt_strength

  # insert data into the table: "property_item_hardware_fastener_screw_machine.diameter"
  insert_property_item_hardware_fastener_screw_machine_diameter(
    # the rows to be inserted
    objects: [property_item_hardware_fastener_screw_machine_diameter_insert_input!]!

    # on conflict condition
    on_conflict: property_item_hardware_fastener_screw_machine_diameter_on_conflict
  ): property_item_hardware_fastener_screw_machine_diameter_mutation_response

  # insert a single row into the table: "property_item_hardware_fastener_screw_machine.diameter"
  insert_property_item_hardware_fastener_screw_machine_diameter_one(
    # the row to be inserted
    object: property_item_hardware_fastener_screw_machine_diameter_insert_input!

    # on conflict condition
    on_conflict: property_item_hardware_fastener_screw_machine_diameter_on_conflict
  ): property_item_hardware_fastener_screw_machine_diameter

  # insert data into the table: "search_data"
  insert_search_data(
    # the rows to be inserted
    objects: [search_data_insert_input!]!

    # on conflict condition
    on_conflict: search_data_on_conflict
  ): search_data_mutation_response

  # insert a single row into the table: "search_data"
  insert_search_data_one(
    # the row to be inserted
    object: search_data_insert_input!

    # on conflict condition
    on_conflict: search_data_on_conflict
  ): search_data

  # insert data into the table: "shipment"
  insert_shipment(
    # the rows to be inserted
    objects: [shipment_insert_input!]!

    # on conflict condition
    on_conflict: shipment_on_conflict
  ): shipment_mutation_response

  # insert a single row into the table: "shipment"
  insert_shipment_one(
    # the row to be inserted
    object: shipment_insert_input!

    # on conflict condition
    on_conflict: shipment_on_conflict
  ): shipment

  # insert data into the table: "stock"
  insert_stock(
    # the rows to be inserted
    objects: [stock_insert_input!]!

    # on conflict condition
    on_conflict: stock_on_conflict
  ): stock_mutation_response

  # insert a single row into the table: "stock"
  insert_stock_one(
    # the row to be inserted
    object: stock_insert_input!

    # on conflict condition
    on_conflict: stock_on_conflict
  ): stock

  # insert data into the table: "storage"
  insert_storage(
    # the rows to be inserted
    objects: [storage_insert_input!]!

    # on conflict condition
    on_conflict: storage_on_conflict
  ): storage_mutation_response

  # insert a single row into the table: "storage"
  insert_storage_one(
    # the row to be inserted
    object: storage_insert_input!

    # on conflict condition
    on_conflict: storage_on_conflict
  ): storage

  # insert data into the table: "tag"
  insert_tag(
    # the rows to be inserted
    objects: [tag_insert_input!]!

    # on conflict condition
    on_conflict: tag_on_conflict
  ): tag_mutation_response

  # insert a single row into the table: "tag"
  insert_tag_one(
    # the row to be inserted
    object: tag_insert_input!

    # on conflict condition
    on_conflict: tag_on_conflict
  ): tag

  # insert data into the table: "vendor"
  insert_vendor(
    # the rows to be inserted
    objects: [vendor_insert_input!]!

    # on conflict condition
    on_conflict: vendor_on_conflict
  ): vendor_mutation_response

  # insert data into the table: "vendor_item"
  insert_vendor_item(
    # the rows to be inserted
    objects: [vendor_item_insert_input!]!

    # on conflict condition
    on_conflict: vendor_item_on_conflict
  ): vendor_item_mutation_response

  # insert a single row into the table: "vendor_item"
  insert_vendor_item_one(
    # the row to be inserted
    object: vendor_item_insert_input!

    # on conflict condition
    on_conflict: vendor_item_on_conflict
  ): vendor_item

  # insert a single row into the table: "vendor"
  insert_vendor_one(
    # the row to be inserted
    object: vendor_insert_input!

    # on conflict condition
    on_conflict: vendor_on_conflict
  ): vendor

  # Send a label to be printed
  # Image Buffer / Raster data arranged as [page][column][pixels] of uint8 to the printer
  putLabelMonochromeBuffer(imageBuffer: [[[uint8]]]!): OperationResult

  # update data of the table: "enum_item_cable.connector"
  update_enum_item_cable_connector(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_cable_connector_set_input

    # filter the rows which have to be updated
    where: enum_item_cable_connector_bool_exp!
  ): enum_item_cable_connector_mutation_response

  # update single row of the table: "enum_item_cable.connector"
  update_enum_item_cable_connector_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_cable_connector_set_input
    pk_columns: enum_item_cable_connector_pk_columns_input!
  ): enum_item_cable_connector

  # update data of the table: "enum.item_class"
  update_enum_item_class(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_class_set_input

    # filter the rows which have to be updated
    where: enum_item_class_bool_exp!
  ): enum_item_class_mutation_response

  # update single row of the table: "enum.item_class"
  update_enum_item_class_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_class_set_input
    pk_columns: enum_item_class_pk_columns_input!
  ): enum_item_class

  # update data of the table: "enum_item.handedness"
  update_enum_item_handedness(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_handedness_set_input

    # filter the rows which have to be updated
    where: enum_item_handedness_bool_exp!
  ): enum_item_handedness_mutation_response

  # update single row of the table: "enum_item.handedness"
  update_enum_item_handedness_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_handedness_set_input
    pk_columns: enum_item_handedness_pk_columns_input!
  ): enum_item_handedness

  # update data of the table: "enum_item_hardware_fastener.drive"
  update_enum_item_hardware_fastener_drive(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_drive_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_drive_bool_exp!
  ): enum_item_hardware_fastener_drive_mutation_response

  # update single row of the table: "enum_item_hardware_fastener.drive"
  update_enum_item_hardware_fastener_drive_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_drive_set_input
    pk_columns: enum_item_hardware_fastener_drive_pk_columns_input!
  ): enum_item_hardware_fastener_drive

  # update data of the table: "enum_item_hardware_fastener.material"
  update_enum_item_hardware_fastener_material(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_material_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_material_bool_exp!
  ): enum_item_hardware_fastener_material_mutation_response

  # update single row of the table: "enum_item_hardware_fastener.material"
  update_enum_item_hardware_fastener_material_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_material_set_input
    pk_columns: enum_item_hardware_fastener_material_pk_columns_input!
  ): enum_item_hardware_fastener_material

  # update data of the table: "enum_item_hardware_fastener_nut.form"
  update_enum_item_hardware_fastener_nut_form(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_nut_form_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_nut_form_bool_exp!
  ): enum_item_hardware_fastener_nut_form_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_nut.form"
  update_enum_item_hardware_fastener_nut_form_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_nut_form_set_input
    pk_columns: enum_item_hardware_fastener_nut_form_pk_columns_input!
  ): enum_item_hardware_fastener_nut_form

  # update data of the table: "enum_item_hardware_fastener_nut.strength"
  update_enum_item_hardware_fastener_nut_strength(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_nut_strength_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_nut_strength_bool_exp!
  ): enum_item_hardware_fastener_nut_strength_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_nut.strength"
  update_enum_item_hardware_fastener_nut_strength_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_nut_strength_set_input
    pk_columns: enum_item_hardware_fastener_nut_strength_pk_columns_input!
  ): enum_item_hardware_fastener_nut_strength

  # update data of the table: "enum_item_hardware_fastener_nut.thread_fit"
  update_enum_item_hardware_fastener_nut_thread_fit(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_nut_thread_fit_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_nut_thread_fit_bool_exp!
  ): enum_item_hardware_fastener_nut_thread_fit_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_nut.thread_fit"
  update_enum_item_hardware_fastener_nut_thread_fit_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_nut_thread_fit_set_input
    pk_columns: enum_item_hardware_fastener_nut_thread_fit_pk_columns_input!
  ): enum_item_hardware_fastener_nut_thread_fit

  # update data of the table: "enum_item_hardware_fastener_screw.hardness"
  update_enum_item_hardware_fastener_screw_hardness(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_hardness_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_screw_hardness_bool_exp!
  ): enum_item_hardware_fastener_screw_hardness_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_screw.hardness"
  update_enum_item_hardware_fastener_screw_hardness_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_hardness_set_input
    pk_columns: enum_item_hardware_fastener_screw_hardness_pk_columns_input!
  ): enum_item_hardware_fastener_screw_hardness

  # update data of the table: "enum_item_hardware_fastener_screw.head"
  update_enum_item_hardware_fastener_screw_head(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_head_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_screw_head_bool_exp!
  ): enum_item_hardware_fastener_screw_head_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_screw.head"
  update_enum_item_hardware_fastener_screw_head_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_head_set_input
    pk_columns: enum_item_hardware_fastener_screw_head_pk_columns_input!
  ): enum_item_hardware_fastener_screw_head

  # update data of the table: "enum_item_hardware_fastener_screw_machine.point"
  update_enum_item_hardware_fastener_screw_machine_point(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_machine_point_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_screw_machine_point_bool_exp!
  ): enum_item_hardware_fastener_screw_machine_point_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_screw_machine.point"
  update_enum_item_hardware_fastener_screw_machine_point_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_machine_point_set_input
    pk_columns: enum_item_hardware_fastener_screw_machine_point_pk_columns_input!
  ): enum_item_hardware_fastener_screw_machine_point

  # update data of the table: "enum_item_hardware_fastener_screw_machine.strength"
  update_enum_item_hardware_fastener_screw_machine_strength(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_machine_strength_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_screw_machine_strength_bool_exp!
  ): enum_item_hardware_fastener_screw_machine_strength_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_screw_machine.strength"
  update_enum_item_hardware_fastener_screw_machine_strength_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_machine_strength_set_input
    pk_columns: enum_item_hardware_fastener_screw_machine_strength_pk_columns_input!
  ): enum_item_hardware_fastener_screw_machine_strength

  # update data of the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  update_enum_item_hardware_fastener_screw_machine_thread_fit(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_machine_thread_fit_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp!
  ): enum_item_hardware_fastener_screw_machine_thread_fit_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  update_enum_item_hardware_fastener_screw_machine_thread_fit_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_screw_machine_thread_fit_set_input
    pk_columns: enum_item_hardware_fastener_screw_machine_thread_fit_pk_columns_input!
  ): enum_item_hardware_fastener_screw_machine_thread_fit

  # update data of the table: "enum_item_hardware_fastener.standoff_shape"
  update_enum_item_hardware_fastener_standoff_shape(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_standoff_shape_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_standoff_shape_bool_exp!
  ): enum_item_hardware_fastener_standoff_shape_mutation_response

  # update single row of the table: "enum_item_hardware_fastener.standoff_shape"
  update_enum_item_hardware_fastener_standoff_shape_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_standoff_shape_set_input
    pk_columns: enum_item_hardware_fastener_standoff_shape_pk_columns_input!
  ): enum_item_hardware_fastener_standoff_shape

  # update data of the table: "enum_item_hardware_fastener.thread_label"
  update_enum_item_hardware_fastener_thread_label(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_thread_label_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_thread_label_bool_exp!
  ): enum_item_hardware_fastener_thread_label_mutation_response

  # update single row of the table: "enum_item_hardware_fastener.thread_label"
  update_enum_item_hardware_fastener_thread_label_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_thread_label_set_input
    pk_columns: enum_item_hardware_fastener_thread_label_pk_columns_input!
  ): enum_item_hardware_fastener_thread_label

  # update data of the table: "enum_item_hardware_fastener.thread_standard"
  update_enum_item_hardware_fastener_thread_standard(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_thread_standard_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_thread_standard_bool_exp!
  ): enum_item_hardware_fastener_thread_standard_mutation_response

  # update single row of the table: "enum_item_hardware_fastener.thread_standard"
  update_enum_item_hardware_fastener_thread_standard_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_thread_standard_set_input
    pk_columns: enum_item_hardware_fastener_thread_standard_pk_columns_input!
  ): enum_item_hardware_fastener_thread_standard

  # update data of the table: "enum_item_hardware_fastener_washer.form"
  update_enum_item_hardware_fastener_washer_form(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_washer_form_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_washer_form_bool_exp!
  ): enum_item_hardware_fastener_washer_form_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_washer.form"
  update_enum_item_hardware_fastener_washer_form_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_washer_form_set_input
    pk_columns: enum_item_hardware_fastener_washer_form_pk_columns_input!
  ): enum_item_hardware_fastener_washer_form

  # update data of the table: "enum_item_hardware_fastener_washer.mechanism"
  update_enum_item_hardware_fastener_washer_mechanism(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_washer_mechanism_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_washer_mechanism_bool_exp!
  ): enum_item_hardware_fastener_washer_mechanism_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_washer.mechanism"
  update_enum_item_hardware_fastener_washer_mechanism_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_washer_mechanism_set_input
    pk_columns: enum_item_hardware_fastener_washer_mechanism_pk_columns_input!
  ): enum_item_hardware_fastener_washer_mechanism

  # update data of the table: "enum_item_hardware_fastener_washer.pattern"
  update_enum_item_hardware_fastener_washer_pattern(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_washer_pattern_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_fastener_washer_pattern_bool_exp!
  ): enum_item_hardware_fastener_washer_pattern_mutation_response

  # update single row of the table: "enum_item_hardware_fastener_washer.pattern"
  update_enum_item_hardware_fastener_washer_pattern_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_fastener_washer_pattern_set_input
    pk_columns: enum_item_hardware_fastener_washer_pattern_pk_columns_input!
  ): enum_item_hardware_fastener_washer_pattern

  # update data of the table: "enum_item_hardware.finish"
  update_enum_item_hardware_finish(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_finish_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_finish_bool_exp!
  ): enum_item_hardware_finish_mutation_response

  # update single row of the table: "enum_item_hardware.finish"
  update_enum_item_hardware_finish_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_finish_set_input
    pk_columns: enum_item_hardware_finish_pk_columns_input!
  ): enum_item_hardware_finish

  # update data of the table: "enum_item_hardware.use_material"
  update_enum_item_hardware_use_material(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_use_material_set_input

    # filter the rows which have to be updated
    where: enum_item_hardware_use_material_bool_exp!
  ): enum_item_hardware_use_material_mutation_response

  # update single row of the table: "enum_item_hardware.use_material"
  update_enum_item_hardware_use_material_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_hardware_use_material_set_input
    pk_columns: enum_item_hardware_use_material_pk_columns_input!
  ): enum_item_hardware_use_material

  # update data of the table: "enum_item_tool.drill_bit_finish"
  update_enum_item_tool_drill_bit_finish(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_finish_set_input

    # filter the rows which have to be updated
    where: enum_item_tool_drill_bit_finish_bool_exp!
  ): enum_item_tool_drill_bit_finish_mutation_response

  # update single row of the table: "enum_item_tool.drill_bit_finish"
  update_enum_item_tool_drill_bit_finish_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_finish_set_input
    pk_columns: enum_item_tool_drill_bit_finish_pk_columns_input!
  ): enum_item_tool_drill_bit_finish

  # update data of the table: "enum_item_tool.drill_bit_length_class"
  update_enum_item_tool_drill_bit_length_class(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_length_class_set_input

    # filter the rows which have to be updated
    where: enum_item_tool_drill_bit_length_class_bool_exp!
  ): enum_item_tool_drill_bit_length_class_mutation_response

  # update single row of the table: "enum_item_tool.drill_bit_length_class"
  update_enum_item_tool_drill_bit_length_class_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_length_class_set_input
    pk_columns: enum_item_tool_drill_bit_length_class_pk_columns_input!
  ): enum_item_tool_drill_bit_length_class

  # update data of the table: "enum_item_tool.drill_bit_material"
  update_enum_item_tool_drill_bit_material(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_material_set_input

    # filter the rows which have to be updated
    where: enum_item_tool_drill_bit_material_bool_exp!
  ): enum_item_tool_drill_bit_material_mutation_response

  # update single row of the table: "enum_item_tool.drill_bit_material"
  update_enum_item_tool_drill_bit_material_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_material_set_input
    pk_columns: enum_item_tool_drill_bit_material_pk_columns_input!
  ): enum_item_tool_drill_bit_material

  # update data of the table: "enum_item_tool.drill_bit_point"
  update_enum_item_tool_drill_bit_point(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_point_set_input

    # filter the rows which have to be updated
    where: enum_item_tool_drill_bit_point_bool_exp!
  ): enum_item_tool_drill_bit_point_mutation_response

  # update single row of the table: "enum_item_tool.drill_bit_point"
  update_enum_item_tool_drill_bit_point_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_point_set_input
    pk_columns: enum_item_tool_drill_bit_point_pk_columns_input!
  ): enum_item_tool_drill_bit_point

  # update data of the table: "enum_item_tool.drill_bit_shank"
  update_enum_item_tool_drill_bit_shank(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_shank_set_input

    # filter the rows which have to be updated
    where: enum_item_tool_drill_bit_shank_bool_exp!
  ): enum_item_tool_drill_bit_shank_mutation_response

  # update single row of the table: "enum_item_tool.drill_bit_shank"
  update_enum_item_tool_drill_bit_shank_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_shank_set_input
    pk_columns: enum_item_tool_drill_bit_shank_pk_columns_input!
  ): enum_item_tool_drill_bit_shank

  # update data of the table: "enum_item_tool.drill_bit_style"
  update_enum_item_tool_drill_bit_style(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_style_set_input

    # filter the rows which have to be updated
    where: enum_item_tool_drill_bit_style_bool_exp!
  ): enum_item_tool_drill_bit_style_mutation_response

  # update single row of the table: "enum_item_tool.drill_bit_style"
  update_enum_item_tool_drill_bit_style_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_item_tool_drill_bit_style_set_input
    pk_columns: enum_item_tool_drill_bit_style_pk_columns_input!
  ): enum_item_tool_drill_bit_style

  # update data of the table: "enum.mapped_class"
  update_enum_mapped_class(
    # sets the columns of the filtered rows to the given values
    _set: enum_mapped_class_set_input

    # filter the rows which have to be updated
    where: enum_mapped_class_bool_exp!
  ): enum_mapped_class_mutation_response

  # update single row of the table: "enum.mapped_class"
  update_enum_mapped_class_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_mapped_class_set_input
    pk_columns: enum_mapped_class_pk_columns_input!
  ): enum_mapped_class

  # update data of the table: "enum.payment_method_type"
  update_enum_payment_method_type(
    # sets the columns of the filtered rows to the given values
    _set: enum_payment_method_type_set_input

    # filter the rows which have to be updated
    where: enum_payment_method_type_bool_exp!
  ): enum_payment_method_type_mutation_response

  # update single row of the table: "enum.payment_method_type"
  update_enum_payment_method_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_payment_method_type_set_input
    pk_columns: enum_payment_method_type_pk_columns_input!
  ): enum_payment_method_type

  # update data of the table: "enum.space_type"
  update_enum_space_type(
    # sets the columns of the filtered rows to the given values
    _set: enum_space_type_set_input

    # filter the rows which have to be updated
    where: enum_space_type_bool_exp!
  ): enum_space_type_mutation_response

  # update single row of the table: "enum.space_type"
  update_enum_space_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_space_type_set_input
    pk_columns: enum_space_type_pk_columns_input!
  ): enum_space_type

  # update data of the table: "enum.stock_event_type"
  update_enum_stock_event_type(
    # sets the columns of the filtered rows to the given values
    _set: enum_stock_event_type_set_input

    # filter the rows which have to be updated
    where: enum_stock_event_type_bool_exp!
  ): enum_stock_event_type_mutation_response

  # update single row of the table: "enum.stock_event_type"
  update_enum_stock_event_type_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_stock_event_type_set_input
    pk_columns: enum_stock_event_type_pk_columns_input!
  ): enum_stock_event_type

  # update data of the table: "enum.unit"
  update_enum_unit(
    # sets the columns of the filtered rows to the given values
    _set: enum_unit_set_input

    # filter the rows which have to be updated
    where: enum_unit_bool_exp!
  ): enum_unit_mutation_response

  # update single row of the table: "enum.unit"
  update_enum_unit_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: enum_unit_set_input
    pk_columns: enum_unit_pk_columns_input!
  ): enum_unit

  # update data of the table: "icon"
  update_icon(
    # sets the columns of the filtered rows to the given values
    _set: icon_set_input

    # filter the rows which have to be updated
    where: icon_bool_exp!
  ): icon_mutation_response

  # update single row of the table: "icon"
  update_icon_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: icon_set_input
    pk_columns: icon_pk_columns_input!
  ): icon

  # update data of the table: "icon_item_category_map"
  update_icon_item_category_map(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: icon_item_category_map_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: icon_item_category_map_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: icon_item_category_map_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: icon_item_category_map_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: icon_item_category_map_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: icon_item_category_map_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: icon_item_category_map_set_input

    # filter the rows which have to be updated
    where: icon_item_category_map_bool_exp!
  ): icon_item_category_map_mutation_response

  # update single row of the table: "icon_item_category_map"
  update_icon_item_category_map_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: icon_item_category_map_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: icon_item_category_map_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: icon_item_category_map_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: icon_item_category_map_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: icon_item_category_map_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: icon_item_category_map_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: icon_item_category_map_set_input
    pk_columns: icon_item_category_map_pk_columns_input!
  ): icon_item_category_map

  # update data of the table: "icon_item_map"
  update_icon_item_map(
    # increments the integer columns with given value of the filtered values
    _inc: icon_item_map_inc_input

    # sets the columns of the filtered rows to the given values
    _set: icon_item_map_set_input

    # filter the rows which have to be updated
    where: icon_item_map_bool_exp!
  ): icon_item_map_mutation_response

  # update single row of the table: "icon_item_map"
  update_icon_item_map_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: icon_item_map_inc_input

    # sets the columns of the filtered rows to the given values
    _set: icon_item_map_set_input
    pk_columns: icon_item_map_pk_columns_input!
  ): icon_item_map

  # update data of the table: "icon_label_map"
  update_icon_label_map(
    # sets the columns of the filtered rows to the given values
    _set: icon_label_map_set_input

    # filter the rows which have to be updated
    where: icon_label_map_bool_exp!
  ): icon_label_map_mutation_response

  # update single row of the table: "icon_label_map"
  update_icon_label_map_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: icon_label_map_set_input
    pk_columns: icon_label_map_pk_columns_input!
  ): icon_label_map

  # update data of the table: "item"
  update_item(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_set_input

    # filter the rows which have to be updated
    where: item_bool_exp!
  ): item_mutation_response

  # update data of the table: "item.bundle"
  update_item_bundle(
    # increments the integer columns with given value of the filtered values
    _inc: item_bundle_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_bundle_set_input

    # filter the rows which have to be updated
    where: item_bundle_bool_exp!
  ): item_bundle_mutation_response

  # update single row of the table: "item.bundle"
  update_item_bundle_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_bundle_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_bundle_set_input
    pk_columns: item_bundle_pk_columns_input!
  ): item_bundle

  # update data of the table: "item.bundle_map"
  update_item_bundle_map(
    # increments the integer columns with given value of the filtered values
    _inc: item_bundle_map_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_bundle_map_set_input

    # filter the rows which have to be updated
    where: item_bundle_map_bool_exp!
  ): item_bundle_map_mutation_response

  # update single row of the table: "item.bundle_map"
  update_item_bundle_map_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_bundle_map_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_bundle_map_set_input
    pk_columns: item_bundle_map_pk_columns_input!
  ): item_bundle_map

  # update single row of the table: "item"
  update_item_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_set_input
    pk_columns: item_pk_columns_input!
  ): item

  # update data of the table: "item.cable_conductive"
  update_item_cable_conductive(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_cable_conductive_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_cable_conductive_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_cable_conductive_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_cable_conductive_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_cable_conductive_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_cable_conductive_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_cable_conductive_set_input

    # filter the rows which have to be updated
    where: item_cable_conductive_bool_exp!
  ): item_cable_conductive_mutation_response

  # update single row of the table: "item.cable_conductive"
  update_item_cable_conductive_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_cable_conductive_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_cable_conductive_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_cable_conductive_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_cable_conductive_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_cable_conductive_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_cable_conductive_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_cable_conductive_set_input
    pk_columns: item_cable_conductive_pk_columns_input!
  ): item_cable_conductive

  # update data of the table: "item.hardware_drill_bit"
  update_item_hardware_drill_bit(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_hardware_drill_bit_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_hardware_drill_bit_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_hardware_drill_bit_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_hardware_drill_bit_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_drill_bit_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_hardware_drill_bit_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_drill_bit_set_input

    # filter the rows which have to be updated
    where: item_hardware_drill_bit_bool_exp!
  ): item_hardware_drill_bit_mutation_response

  # update single row of the table: "item.hardware_drill_bit"
  update_item_hardware_drill_bit_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_hardware_drill_bit_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_hardware_drill_bit_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_hardware_drill_bit_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_hardware_drill_bit_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_drill_bit_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_hardware_drill_bit_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_drill_bit_set_input
    pk_columns: item_hardware_drill_bit_pk_columns_input!
  ): item_hardware_drill_bit

  # update data of the table: "item.hardware_fastener_insert"
  update_item_hardware_fastener_insert(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_insert_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_insert_set_input

    # filter the rows which have to be updated
    where: item_hardware_fastener_insert_bool_exp!
  ): item_hardware_fastener_insert_mutation_response

  # update single row of the table: "item.hardware_fastener_insert"
  update_item_hardware_fastener_insert_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_insert_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_insert_set_input
    pk_columns: item_hardware_fastener_insert_pk_columns_input!
  ): item_hardware_fastener_insert

  # update data of the table: "item.hardware_fastener_nut"
  update_item_hardware_fastener_nut(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_nut_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_nut_set_input

    # filter the rows which have to be updated
    where: item_hardware_fastener_nut_bool_exp!
  ): item_hardware_fastener_nut_mutation_response

  # update single row of the table: "item.hardware_fastener_nut"
  update_item_hardware_fastener_nut_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_nut_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_nut_set_input
    pk_columns: item_hardware_fastener_nut_pk_columns_input!
  ): item_hardware_fastener_nut

  # update data of the table: "item.hardware_fastener_screw"
  update_item_hardware_fastener_screw(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_screw_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_screw_set_input

    # filter the rows which have to be updated
    where: item_hardware_fastener_screw_bool_exp!
  ): item_hardware_fastener_screw_mutation_response

  # update single row of the table: "item.hardware_fastener_screw"
  update_item_hardware_fastener_screw_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_screw_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_screw_set_input
    pk_columns: item_hardware_fastener_screw_pk_columns_input!
  ): item_hardware_fastener_screw

  # update data of the table: "item.hardware_fastener_screw_machine"
  update_item_hardware_fastener_screw_machine(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_hardware_fastener_screw_machine_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_hardware_fastener_screw_machine_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_hardware_fastener_screw_machine_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_hardware_fastener_screw_machine_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_screw_machine_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_hardware_fastener_screw_machine_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_screw_machine_set_input

    # filter the rows which have to be updated
    where: item_hardware_fastener_screw_machine_bool_exp!
  ): item_hardware_fastener_screw_machine_mutation_response

  # update single row of the table: "item.hardware_fastener_screw_machine"
  update_item_hardware_fastener_screw_machine_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: item_hardware_fastener_screw_machine_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: item_hardware_fastener_screw_machine_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: item_hardware_fastener_screw_machine_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: item_hardware_fastener_screw_machine_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_screw_machine_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: item_hardware_fastener_screw_machine_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_screw_machine_set_input
    pk_columns: item_hardware_fastener_screw_machine_pk_columns_input!
  ): item_hardware_fastener_screw_machine

  # update data of the table: "item.hardware_fastener_standoff"
  update_item_hardware_fastener_standoff(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_standoff_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_standoff_set_input

    # filter the rows which have to be updated
    where: item_hardware_fastener_standoff_bool_exp!
  ): item_hardware_fastener_standoff_mutation_response

  # update single row of the table: "item.hardware_fastener_standoff"
  update_item_hardware_fastener_standoff_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_standoff_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_standoff_set_input
    pk_columns: item_hardware_fastener_standoff_pk_columns_input!
  ): item_hardware_fastener_standoff

  # update data of the table: "item.hardware_fastener_washer"
  update_item_hardware_fastener_washer(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_washer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_washer_set_input

    # filter the rows which have to be updated
    where: item_hardware_fastener_washer_bool_exp!
  ): item_hardware_fastener_washer_mutation_response

  # update single row of the table: "item.hardware_fastener_washer"
  update_item_hardware_fastener_washer_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: item_hardware_fastener_washer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: item_hardware_fastener_washer_set_input
    pk_columns: item_hardware_fastener_washer_pk_columns_input!
  ): item_hardware_fastener_washer

  # update data of the table: "label"
  update_label(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: label_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: label_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: label_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: label_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: label_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: label_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: label_set_input

    # filter the rows which have to be updated
    where: label_bool_exp!
  ): label_mutation_response

  # update single row of the table: "label"
  update_label_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: label_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: label_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: label_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: label_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: label_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: label_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: label_set_input
    pk_columns: label_pk_columns_input!
  ): label

  # update data of the table: "label_item_map"
  update_label_item_map(
    # increments the integer columns with given value of the filtered values
    _inc: label_item_map_inc_input

    # sets the columns of the filtered rows to the given values
    _set: label_item_map_set_input

    # filter the rows which have to be updated
    where: label_item_map_bool_exp!
  ): label_item_map_mutation_response

  # update single row of the table: "label_item_map"
  update_label_item_map_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: label_item_map_inc_input

    # sets the columns of the filtered rows to the given values
    _set: label_item_map_set_input
    pk_columns: label_item_map_pk_columns_input!
  ): label_item_map

  # update data of the table: "label_template_map"
  update_label_template_map(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: label_template_map_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: label_template_map_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: label_template_map_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: label_template_map_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: label_template_map_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: label_template_map_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: label_template_map_set_input

    # filter the rows which have to be updated
    where: label_template_map_bool_exp!
  ): label_template_map_mutation_response

  # update single row of the table: "label_template_map"
  update_label_template_map_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: label_template_map_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: label_template_map_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: label_template_map_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: label_template_map_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: label_template_map_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: label_template_map_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: label_template_map_set_input
    pk_columns: label_template_map_pk_columns_input!
  ): label_template_map

  # update data of the table: "manufacturer"
  update_manufacturer(
    # increments the integer columns with given value of the filtered values
    _inc: manufacturer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: manufacturer_set_input

    # filter the rows which have to be updated
    where: manufacturer_bool_exp!
  ): manufacturer_mutation_response

  # update single row of the table: "manufacturer"
  update_manufacturer_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: manufacturer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: manufacturer_set_input
    pk_columns: manufacturer_pk_columns_input!
  ): manufacturer

  # update data of the table: "manufacturer_item"
  update_manufacturer_item(
    # increments the integer columns with given value of the filtered values
    _inc: manufacturer_item_inc_input

    # sets the columns of the filtered rows to the given values
    _set: manufacturer_item_set_input

    # filter the rows which have to be updated
    where: manufacturer_item_bool_exp!
  ): manufacturer_item_mutation_response

  # update single row of the table: "manufacturer_item"
  update_manufacturer_item_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: manufacturer_item_inc_input

    # sets the columns of the filtered rows to the given values
    _set: manufacturer_item_set_input
    pk_columns: manufacturer_item_pk_columns_input!
  ): manufacturer_item

  # update data of the table: "order"
  update_order(
    # increments the integer columns with given value of the filtered values
    _inc: order_inc_input

    # sets the columns of the filtered rows to the given values
    _set: order_set_input

    # filter the rows which have to be updated
    where: order_bool_exp!
  ): order_mutation_response

  # update single row of the table: "order"
  update_order_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: order_inc_input

    # sets the columns of the filtered rows to the given values
    _set: order_set_input
    pk_columns: order_pk_columns_input!
  ): order

  # update data of the table: "order_item"
  update_order_item(
    # increments the integer columns with given value of the filtered values
    _inc: order_item_inc_input

    # sets the columns of the filtered rows to the given values
    _set: order_item_set_input

    # filter the rows which have to be updated
    where: order_item_bool_exp!
  ): order_item_mutation_response

  # update single row of the table: "order_item"
  update_order_item_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: order_item_inc_input

    # sets the columns of the filtered rows to the given values
    _set: order_item_set_input
    pk_columns: order_item_pk_columns_input!
  ): order_item

  # update data of the table: "payment_method"
  update_payment_method(
    # increments the integer columns with given value of the filtered values
    _inc: payment_method_inc_input

    # sets the columns of the filtered rows to the given values
    _set: payment_method_set_input

    # filter the rows which have to be updated
    where: payment_method_bool_exp!
  ): payment_method_mutation_response

  # update single row of the table: "payment_method"
  update_payment_method_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: payment_method_inc_input

    # sets the columns of the filtered rows to the given values
    _set: payment_method_set_input
    pk_columns: payment_method_pk_columns_input!
  ): payment_method

  # update data of the table: "property.item_hardware_fastener_bolt_strength"
  update_property_item_hardware_fastener_bolt_strength(
    # increments the integer columns with given value of the filtered values
    _inc: property_item_hardware_fastener_bolt_strength_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_item_hardware_fastener_bolt_strength_set_input

    # filter the rows which have to be updated
    where: property_item_hardware_fastener_bolt_strength_bool_exp!
  ): property_item_hardware_fastener_bolt_strength_mutation_response

  # update single row of the table: "property.item_hardware_fastener_bolt_strength"
  update_property_item_hardware_fastener_bolt_strength_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_item_hardware_fastener_bolt_strength_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_item_hardware_fastener_bolt_strength_set_input
    pk_columns: property_item_hardware_fastener_bolt_strength_pk_columns_input!
  ): property_item_hardware_fastener_bolt_strength

  # update data of the table: "property_item_hardware_fastener_screw_machine.diameter"
  update_property_item_hardware_fastener_screw_machine_diameter(
    # increments the integer columns with given value of the filtered values
    _inc: property_item_hardware_fastener_screw_machine_diameter_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_item_hardware_fastener_screw_machine_diameter_set_input

    # filter the rows which have to be updated
    where: property_item_hardware_fastener_screw_machine_diameter_bool_exp!
  ): property_item_hardware_fastener_screw_machine_diameter_mutation_response

  # update single row of the table: "property_item_hardware_fastener_screw_machine.diameter"
  update_property_item_hardware_fastener_screw_machine_diameter_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_item_hardware_fastener_screw_machine_diameter_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_item_hardware_fastener_screw_machine_diameter_set_input
    pk_columns: property_item_hardware_fastener_screw_machine_diameter_pk_columns_input!
  ): property_item_hardware_fastener_screw_machine_diameter

  # update data of the table: "search_data"
  update_search_data(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: search_data_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: search_data_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: search_data_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: search_data_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: search_data_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: search_data_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: search_data_set_input

    # filter the rows which have to be updated
    where: search_data_bool_exp!
  ): search_data_mutation_response

  # update single row of the table: "search_data"
  update_search_data_by_pk(
    # append existing jsonb value of filtered columns with new jsonb value
    _append: search_data_append_input

    # delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    _delete_at_path: search_data_delete_at_path_input

    # delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    _delete_elem: search_data_delete_elem_input

    # delete key/value pair or string element. key/value pairs are matched based on their key value
    _delete_key: search_data_delete_key_input

    # increments the integer columns with given value of the filtered values
    _inc: search_data_inc_input

    # prepend existing jsonb value of filtered columns with new jsonb value
    _prepend: search_data_prepend_input

    # sets the columns of the filtered rows to the given values
    _set: search_data_set_input
    pk_columns: search_data_pk_columns_input!
  ): search_data

  # update data of the table: "shipment"
  update_shipment(
    # increments the integer columns with given value of the filtered values
    _inc: shipment_inc_input

    # sets the columns of the filtered rows to the given values
    _set: shipment_set_input

    # filter the rows which have to be updated
    where: shipment_bool_exp!
  ): shipment_mutation_response

  # update single row of the table: "shipment"
  update_shipment_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: shipment_inc_input

    # sets the columns of the filtered rows to the given values
    _set: shipment_set_input
    pk_columns: shipment_pk_columns_input!
  ): shipment

  # update data of the table: "stock"
  update_stock(
    # increments the integer columns with given value of the filtered values
    _inc: stock_inc_input

    # sets the columns of the filtered rows to the given values
    _set: stock_set_input

    # filter the rows which have to be updated
    where: stock_bool_exp!
  ): stock_mutation_response

  # update single row of the table: "stock"
  update_stock_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: stock_inc_input

    # sets the columns of the filtered rows to the given values
    _set: stock_set_input
    pk_columns: stock_pk_columns_input!
  ): stock

  # update data of the table: "storage"
  update_storage(
    # increments the integer columns with given value of the filtered values
    _inc: storage_inc_input

    # sets the columns of the filtered rows to the given values
    _set: storage_set_input

    # filter the rows which have to be updated
    where: storage_bool_exp!
  ): storage_mutation_response

  # update single row of the table: "storage"
  update_storage_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: storage_inc_input

    # sets the columns of the filtered rows to the given values
    _set: storage_set_input
    pk_columns: storage_pk_columns_input!
  ): storage

  # update data of the table: "tag"
  update_tag(
    # increments the integer columns with given value of the filtered values
    _inc: tag_inc_input

    # sets the columns of the filtered rows to the given values
    _set: tag_set_input

    # filter the rows which have to be updated
    where: tag_bool_exp!
  ): tag_mutation_response

  # update single row of the table: "tag"
  update_tag_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: tag_inc_input

    # sets the columns of the filtered rows to the given values
    _set: tag_set_input
    pk_columns: tag_pk_columns_input!
  ): tag

  # update data of the table: "vendor"
  update_vendor(
    # increments the integer columns with given value of the filtered values
    _inc: vendor_inc_input

    # sets the columns of the filtered rows to the given values
    _set: vendor_set_input

    # filter the rows which have to be updated
    where: vendor_bool_exp!
  ): vendor_mutation_response

  # update single row of the table: "vendor"
  update_vendor_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: vendor_inc_input

    # sets the columns of the filtered rows to the given values
    _set: vendor_set_input
    pk_columns: vendor_pk_columns_input!
  ): vendor

  # update data of the table: "vendor_item"
  update_vendor_item(
    # increments the integer columns with given value of the filtered values
    _inc: vendor_item_inc_input

    # sets the columns of the filtered rows to the given values
    _set: vendor_item_set_input

    # filter the rows which have to be updated
    where: vendor_item_bool_exp!
  ): vendor_item_mutation_response

  # update single row of the table: "vendor_item"
  update_vendor_item_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: vendor_item_inc_input

    # sets the columns of the filtered rows to the given values
    _set: vendor_item_set_input
    pk_columns: vendor_item_pk_columns_input!
  ): vendor_item
  uploadFiles(files: [Upload]!): [File]!
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# columns and relationships of "order"
type order {
  fulfilled_date: date
  id: Int!
  items_cost: numeric

  # An array relationship
  order_items(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): [order_item!]!

  # An aggregated array relationship
  order_items_aggregate(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): order_item_aggregate!

  # An object relationship
  payment_method: payment_method
  payment_method_id: Int
  placed_date: date!
  pon: String

  # An array relationship
  shipments(
    # distinct select on columns
    distinct_on: [shipment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [shipment_order_by!]

    # filter the rows returned
    where: shipment_bool_exp
  ): [shipment!]!

  # An aggregated array relationship
  shipments_aggregate(
    # distinct select on columns
    distinct_on: [shipment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [shipment_order_by!]

    # filter the rows returned
    where: shipment_bool_exp
  ): shipment_aggregate!
  tax_cost: numeric
  total_cost: numeric
  url: String

  # An object relationship
  vendor: vendor!
  vendor_id: Int!
  vendor_order_id: String!
}

# aggregated selection of "order"
type order_aggregate {
  aggregate: order_aggregate_fields
  nodes: [order!]!
}

# aggregate fields of "order"
type order_aggregate_fields {
  avg: order_avg_fields
  count(columns: [order_select_column!], distinct: Boolean): Int
  max: order_max_fields
  min: order_min_fields
  stddev: order_stddev_fields
  stddev_pop: order_stddev_pop_fields
  stddev_samp: order_stddev_samp_fields
  sum: order_sum_fields
  var_pop: order_var_pop_fields
  var_samp: order_var_samp_fields
  variance: order_variance_fields
}

# order by aggregate values of table "order"
input order_aggregate_order_by {
  avg: order_avg_order_by
  count: order_by
  max: order_max_order_by
  min: order_min_order_by
  stddev: order_stddev_order_by
  stddev_pop: order_stddev_pop_order_by
  stddev_samp: order_stddev_samp_order_by
  sum: order_sum_order_by
  var_pop: order_var_pop_order_by
  var_samp: order_var_samp_order_by
  variance: order_variance_order_by
}

# input type for inserting array relation for remote table "order"
input order_arr_rel_insert_input {
  data: [order_insert_input!]!
  on_conflict: order_on_conflict
}

# aggregate avg on columns
type order_avg_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by avg() on columns of table "order"
input order_avg_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# Boolean expression to filter rows from the table "order". All fields are combined with a logical 'AND'.
input order_bool_exp {
  _and: [order_bool_exp]
  _not: order_bool_exp
  _or: [order_bool_exp]
  fulfilled_date: date_comparison_exp
  id: Int_comparison_exp
  items_cost: numeric_comparison_exp
  order_items: order_item_bool_exp
  payment_method: payment_method_bool_exp
  payment_method_id: Int_comparison_exp
  placed_date: date_comparison_exp
  pon: String_comparison_exp
  shipments: shipment_bool_exp
  tax_cost: numeric_comparison_exp
  total_cost: numeric_comparison_exp
  url: String_comparison_exp
  vendor: vendor_bool_exp
  vendor_id: Int_comparison_exp
  vendor_order_id: String_comparison_exp
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# unique or primary key constraints on table "order"
enum order_constraint {
  # unique or primary key constraint
  order_pkey
}

# input type for incrementing integer column in table "order"
input order_inc_input {
  id: Int
  items_cost: numeric
  payment_method_id: Int
  tax_cost: numeric
  total_cost: numeric
  vendor_id: Int
}

# input type for inserting data into table "order"
input order_insert_input {
  fulfilled_date: date
  id: Int
  items_cost: numeric
  order_items: order_item_arr_rel_insert_input
  payment_method: payment_method_obj_rel_insert_input
  payment_method_id: Int
  placed_date: date
  pon: String
  shipments: shipment_arr_rel_insert_input
  tax_cost: numeric
  total_cost: numeric
  url: String
  vendor: vendor_obj_rel_insert_input
  vendor_id: Int
  vendor_order_id: String
}

# represents a single line item on an order
#
#
# columns and relationships of "order_item"
type order_item {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int!
  item_id: Int!

  # link to manufacturer item, which in turn links to item
  manufacturer_item_id: Int
  order_id: Int!
  quantity: numeric

  # individual items unique id (as provided by manufacturer)
  serial_no: String
  shipment_id: Int
  vendor_item_id: Int
}

# aggregated selection of "order_item"
type order_item_aggregate {
  aggregate: order_item_aggregate_fields
  nodes: [order_item!]!
}

# aggregate fields of "order_item"
type order_item_aggregate_fields {
  avg: order_item_avg_fields
  count(columns: [order_item_select_column!], distinct: Boolean): Int
  max: order_item_max_fields
  min: order_item_min_fields
  stddev: order_item_stddev_fields
  stddev_pop: order_item_stddev_pop_fields
  stddev_samp: order_item_stddev_samp_fields
  sum: order_item_sum_fields
  var_pop: order_item_var_pop_fields
  var_samp: order_item_var_samp_fields
  variance: order_item_variance_fields
}

# order by aggregate values of table "order_item"
input order_item_aggregate_order_by {
  avg: order_item_avg_order_by
  count: order_by
  max: order_item_max_order_by
  min: order_item_min_order_by
  stddev: order_item_stddev_order_by
  stddev_pop: order_item_stddev_pop_order_by
  stddev_samp: order_item_stddev_samp_order_by
  sum: order_item_sum_order_by
  var_pop: order_item_var_pop_order_by
  var_samp: order_item_var_samp_order_by
  variance: order_item_variance_order_by
}

# input type for inserting array relation for remote table "order_item"
input order_item_arr_rel_insert_input {
  data: [order_item_insert_input!]!
  on_conflict: order_item_on_conflict
}

# aggregate avg on columns
type order_item_avg_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by avg() on columns of table "order_item"
input order_item_avg_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# Boolean expression to filter rows from the table "order_item". All fields are combined with a logical 'AND'.
input order_item_bool_exp {
  _and: [order_item_bool_exp]
  _not: order_item_bool_exp
  _or: [order_item_bool_exp]
  cost_item: money_comparison_exp
  cost_tax: money_comparison_exp
  cost_total: money_comparison_exp
  id: Int_comparison_exp
  item_id: Int_comparison_exp
  manufacturer_item_id: Int_comparison_exp
  order_id: Int_comparison_exp
  quantity: numeric_comparison_exp
  serial_no: String_comparison_exp
  shipment_id: Int_comparison_exp
  vendor_item_id: Int_comparison_exp
}

# unique or primary key constraints on table "order_item"
enum order_item_constraint {
  # unique or primary key constraint
  order_item_id_item_id_key

  # unique or primary key constraint
  order_item_id_key

  # unique or primary key constraint
  order_item_id_quantity_key

  # unique or primary key constraint
  order_item_item_id_vendor_item_id_serial_no_key

  # unique or primary key constraint
  order_item_pkey

  # unique or primary key constraint
  order_item_vendor_item_id_order_id_serial_no_key
}

# input type for incrementing integer column in table "order_item"
input order_item_inc_input {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_id: Int
  quantity: numeric
  shipment_id: Int
  vendor_item_id: Int
}

# input type for inserting data into table "order_item"
input order_item_insert_input {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_id: Int
  quantity: numeric
  serial_no: String
  shipment_id: Int
  vendor_item_id: Int
}

# aggregate max on columns
type order_item_max_fields {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_id: Int
  quantity: numeric
  serial_no: String
  shipment_id: Int
  vendor_item_id: Int
}

# order by max() on columns of table "order_item"
input order_item_max_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  serial_no: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate min on columns
type order_item_min_fields {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_id: Int
  quantity: numeric
  serial_no: String
  shipment_id: Int
  vendor_item_id: Int
}

# order by min() on columns of table "order_item"
input order_item_min_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  serial_no: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# response of any mutation on the table "order_item"
type order_item_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [order_item!]!
}

# input type for inserting object relation for remote table "order_item"
input order_item_obj_rel_insert_input {
  data: order_item_insert_input!
  on_conflict: order_item_on_conflict
}

# on conflict condition type for table "order_item"
input order_item_on_conflict {
  constraint: order_item_constraint!
  update_columns: [order_item_update_column!]!
  where: order_item_bool_exp
}

# ordering options when selecting data from "order_item"
input order_item_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  serial_no: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# primary key columns input for table: "order_item"
input order_item_pk_columns_input {
  id: Int!
}

# select columns of table "order_item"
enum order_item_select_column {
  # column name
  cost_item

  # column name
  cost_tax

  # column name
  cost_total

  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_item_id

  # column name
  order_id

  # column name
  quantity

  # column name
  serial_no

  # column name
  shipment_id

  # column name
  vendor_item_id
}

# input type for updating data in table "order_item"
input order_item_set_input {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_id: Int
  quantity: numeric
  serial_no: String
  shipment_id: Int
  vendor_item_id: Int
}

# aggregate stddev on columns
type order_item_stddev_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by stddev() on columns of table "order_item"
input order_item_stddev_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate stddev_pop on columns
type order_item_stddev_pop_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by stddev_pop() on columns of table "order_item"
input order_item_stddev_pop_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate stddev_samp on columns
type order_item_stddev_samp_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by stddev_samp() on columns of table "order_item"
input order_item_stddev_samp_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate sum on columns
type order_item_sum_fields {
  cost_item: money
  cost_tax: money
  cost_total: money
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_id: Int
  quantity: numeric
  shipment_id: Int
  vendor_item_id: Int
}

# order by sum() on columns of table "order_item"
input order_item_sum_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# update columns of table "order_item"
enum order_item_update_column {
  # column name
  cost_item

  # column name
  cost_tax

  # column name
  cost_total

  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_item_id

  # column name
  order_id

  # column name
  quantity

  # column name
  serial_no

  # column name
  shipment_id

  # column name
  vendor_item_id
}

# aggregate var_pop on columns
type order_item_var_pop_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by var_pop() on columns of table "order_item"
input order_item_var_pop_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate var_samp on columns
type order_item_var_samp_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by var_samp() on columns of table "order_item"
input order_item_var_samp_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate variance on columns
type order_item_variance_fields {
  cost_item: Float
  cost_tax: Float
  cost_total: Float
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_id: Float
  quantity: Float
  shipment_id: Float
  vendor_item_id: Float
}

# order by variance() on columns of table "order_item"
input order_item_variance_order_by {
  cost_item: order_by
  cost_tax: order_by
  cost_total: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_id: order_by
  quantity: order_by
  shipment_id: order_by
  vendor_item_id: order_by
}

# aggregate max on columns
type order_max_fields {
  fulfilled_date: date
  id: Int
  items_cost: numeric
  payment_method_id: Int
  placed_date: date
  pon: String
  tax_cost: numeric
  total_cost: numeric
  url: String
  vendor_id: Int
  vendor_order_id: String
}

# order by max() on columns of table "order"
input order_max_order_by {
  fulfilled_date: order_by
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  placed_date: order_by
  pon: order_by
  tax_cost: order_by
  total_cost: order_by
  url: order_by
  vendor_id: order_by
  vendor_order_id: order_by
}

# aggregate min on columns
type order_min_fields {
  fulfilled_date: date
  id: Int
  items_cost: numeric
  payment_method_id: Int
  placed_date: date
  pon: String
  tax_cost: numeric
  total_cost: numeric
  url: String
  vendor_id: Int
  vendor_order_id: String
}

# order by min() on columns of table "order"
input order_min_order_by {
  fulfilled_date: order_by
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  placed_date: order_by
  pon: order_by
  tax_cost: order_by
  total_cost: order_by
  url: order_by
  vendor_id: order_by
  vendor_order_id: order_by
}

# response of any mutation on the table "order"
type order_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [order!]!
}

# input type for inserting object relation for remote table "order"
input order_obj_rel_insert_input {
  data: order_insert_input!
  on_conflict: order_on_conflict
}

# on conflict condition type for table "order"
input order_on_conflict {
  constraint: order_constraint!
  update_columns: [order_update_column!]!
  where: order_bool_exp
}

# ordering options when selecting data from "order"
input order_order_by {
  fulfilled_date: order_by
  id: order_by
  items_cost: order_by
  order_items_aggregate: order_item_aggregate_order_by
  payment_method: payment_method_order_by
  payment_method_id: order_by
  placed_date: order_by
  pon: order_by
  shipments_aggregate: shipment_aggregate_order_by
  tax_cost: order_by
  total_cost: order_by
  url: order_by
  vendor: vendor_order_by
  vendor_id: order_by
  vendor_order_id: order_by
}

# primary key columns input for table: "order"
input order_pk_columns_input {
  id: Int!
}

# select columns of table "order"
enum order_select_column {
  # column name
  fulfilled_date

  # column name
  id

  # column name
  items_cost

  # column name
  payment_method_id

  # column name
  placed_date

  # column name
  pon

  # column name
  tax_cost

  # column name
  total_cost

  # column name
  url

  # column name
  vendor_id

  # column name
  vendor_order_id
}

# input type for updating data in table "order"
input order_set_input {
  fulfilled_date: date
  id: Int
  items_cost: numeric
  payment_method_id: Int
  placed_date: date
  pon: String
  tax_cost: numeric
  total_cost: numeric
  url: String
  vendor_id: Int
  vendor_order_id: String
}

# aggregate stddev on columns
type order_stddev_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by stddev() on columns of table "order"
input order_stddev_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# aggregate stddev_pop on columns
type order_stddev_pop_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by stddev_pop() on columns of table "order"
input order_stddev_pop_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# aggregate stddev_samp on columns
type order_stddev_samp_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by stddev_samp() on columns of table "order"
input order_stddev_samp_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# aggregate sum on columns
type order_sum_fields {
  id: Int
  items_cost: numeric
  payment_method_id: Int
  tax_cost: numeric
  total_cost: numeric
  vendor_id: Int
}

# order by sum() on columns of table "order"
input order_sum_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# update columns of table "order"
enum order_update_column {
  # column name
  fulfilled_date

  # column name
  id

  # column name
  items_cost

  # column name
  payment_method_id

  # column name
  placed_date

  # column name
  pon

  # column name
  tax_cost

  # column name
  total_cost

  # column name
  url

  # column name
  vendor_id

  # column name
  vendor_order_id
}

# aggregate var_pop on columns
type order_var_pop_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by var_pop() on columns of table "order"
input order_var_pop_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# aggregate var_samp on columns
type order_var_samp_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by var_samp() on columns of table "order"
input order_var_samp_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# aggregate variance on columns
type order_variance_fields {
  id: Float
  items_cost: Float
  payment_method_id: Float
  tax_cost: Float
  total_cost: Float
  vendor_id: Float
}

# order by variance() on columns of table "order"
input order_variance_order_by {
  id: order_by
  items_cost: order_by
  payment_method_id: order_by
  tax_cost: order_by
  total_cost: order_by
  vendor_id: order_by
}

# columns and relationships of "payment_method"
type payment_method {
  class: enum_payment_method_type_enum!
  id: Int!
  name: String!
}

# aggregated selection of "payment_method"
type payment_method_aggregate {
  aggregate: payment_method_aggregate_fields
  nodes: [payment_method!]!
}

# aggregate fields of "payment_method"
type payment_method_aggregate_fields {
  avg: payment_method_avg_fields
  count(columns: [payment_method_select_column!], distinct: Boolean): Int
  max: payment_method_max_fields
  min: payment_method_min_fields
  stddev: payment_method_stddev_fields
  stddev_pop: payment_method_stddev_pop_fields
  stddev_samp: payment_method_stddev_samp_fields
  sum: payment_method_sum_fields
  var_pop: payment_method_var_pop_fields
  var_samp: payment_method_var_samp_fields
  variance: payment_method_variance_fields
}

# order by aggregate values of table "payment_method"
input payment_method_aggregate_order_by {
  avg: payment_method_avg_order_by
  count: order_by
  max: payment_method_max_order_by
  min: payment_method_min_order_by
  stddev: payment_method_stddev_order_by
  stddev_pop: payment_method_stddev_pop_order_by
  stddev_samp: payment_method_stddev_samp_order_by
  sum: payment_method_sum_order_by
  var_pop: payment_method_var_pop_order_by
  var_samp: payment_method_var_samp_order_by
  variance: payment_method_variance_order_by
}

# input type for inserting array relation for remote table "payment_method"
input payment_method_arr_rel_insert_input {
  data: [payment_method_insert_input!]!
  on_conflict: payment_method_on_conflict
}

# aggregate avg on columns
type payment_method_avg_fields {
  id: Float
}

# order by avg() on columns of table "payment_method"
input payment_method_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "payment_method". All fields are combined with a logical 'AND'.
input payment_method_bool_exp {
  _and: [payment_method_bool_exp]
  _not: payment_method_bool_exp
  _or: [payment_method_bool_exp]
  class: enum_payment_method_type_enum_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

# unique or primary key constraints on table "payment_method"
enum payment_method_constraint {
  # unique or primary key constraint
  payment_method_pkey
}

# input type for incrementing integer column in table "payment_method"
input payment_method_inc_input {
  id: Int
}

# input type for inserting data into table "payment_method"
input payment_method_insert_input {
  class: enum_payment_method_type_enum
  id: Int
  name: String
}

# aggregate max on columns
type payment_method_max_fields {
  id: Int
  name: String
}

# order by max() on columns of table "payment_method"
input payment_method_max_order_by {
  id: order_by
  name: order_by
}

# aggregate min on columns
type payment_method_min_fields {
  id: Int
  name: String
}

# order by min() on columns of table "payment_method"
input payment_method_min_order_by {
  id: order_by
  name: order_by
}

# response of any mutation on the table "payment_method"
type payment_method_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [payment_method!]!
}

# input type for inserting object relation for remote table "payment_method"
input payment_method_obj_rel_insert_input {
  data: payment_method_insert_input!
  on_conflict: payment_method_on_conflict
}

# on conflict condition type for table "payment_method"
input payment_method_on_conflict {
  constraint: payment_method_constraint!
  update_columns: [payment_method_update_column!]!
  where: payment_method_bool_exp
}

# ordering options when selecting data from "payment_method"
input payment_method_order_by {
  class: order_by
  id: order_by
  name: order_by
}

# primary key columns input for table: "payment_method"
input payment_method_pk_columns_input {
  id: Int!
}

# select columns of table "payment_method"
enum payment_method_select_column {
  # column name
  class

  # column name
  id

  # column name
  name
}

# input type for updating data in table "payment_method"
input payment_method_set_input {
  class: enum_payment_method_type_enum
  id: Int
  name: String
}

# aggregate stddev on columns
type payment_method_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "payment_method"
input payment_method_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type payment_method_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "payment_method"
input payment_method_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type payment_method_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "payment_method"
input payment_method_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type payment_method_sum_fields {
  id: Int
}

# order by sum() on columns of table "payment_method"
input payment_method_sum_order_by {
  id: order_by
}

# update columns of table "payment_method"
enum payment_method_update_column {
  # column name
  class

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type payment_method_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "payment_method"
input payment_method_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type payment_method_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "payment_method"
input payment_method_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type payment_method_variance_fields {
  id: Float
}

# order by variance() on columns of table "payment_method"
input payment_method_variance_order_by {
  id: order_by
}

# columns and relationships of "property.item_hardware_fastener_bolt_strength"
type property_item_hardware_fastener_bolt_strength {
  diameter: numeric!
  max_tightening_torque: numeric!
  proof_load: numeric!
  strength_grade: String!
  thread_pitch: numeric!
}

# aggregated selection of "property.item_hardware_fastener_bolt_strength"
type property_item_hardware_fastener_bolt_strength_aggregate {
  aggregate: property_item_hardware_fastener_bolt_strength_aggregate_fields
  nodes: [property_item_hardware_fastener_bolt_strength!]!
}

# aggregate fields of "property.item_hardware_fastener_bolt_strength"
type property_item_hardware_fastener_bolt_strength_aggregate_fields {
  avg: property_item_hardware_fastener_bolt_strength_avg_fields
  count(columns: [property_item_hardware_fastener_bolt_strength_select_column!], distinct: Boolean): Int
  max: property_item_hardware_fastener_bolt_strength_max_fields
  min: property_item_hardware_fastener_bolt_strength_min_fields
  stddev: property_item_hardware_fastener_bolt_strength_stddev_fields
  stddev_pop: property_item_hardware_fastener_bolt_strength_stddev_pop_fields
  stddev_samp: property_item_hardware_fastener_bolt_strength_stddev_samp_fields
  sum: property_item_hardware_fastener_bolt_strength_sum_fields
  var_pop: property_item_hardware_fastener_bolt_strength_var_pop_fields
  var_samp: property_item_hardware_fastener_bolt_strength_var_samp_fields
  variance: property_item_hardware_fastener_bolt_strength_variance_fields
}

# order by aggregate values of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_aggregate_order_by {
  avg: property_item_hardware_fastener_bolt_strength_avg_order_by
  count: order_by
  max: property_item_hardware_fastener_bolt_strength_max_order_by
  min: property_item_hardware_fastener_bolt_strength_min_order_by
  stddev: property_item_hardware_fastener_bolt_strength_stddev_order_by
  stddev_pop: property_item_hardware_fastener_bolt_strength_stddev_pop_order_by
  stddev_samp: property_item_hardware_fastener_bolt_strength_stddev_samp_order_by
  sum: property_item_hardware_fastener_bolt_strength_sum_order_by
  var_pop: property_item_hardware_fastener_bolt_strength_var_pop_order_by
  var_samp: property_item_hardware_fastener_bolt_strength_var_samp_order_by
  variance: property_item_hardware_fastener_bolt_strength_variance_order_by
}

# input type for inserting array relation for remote table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_arr_rel_insert_input {
  data: [property_item_hardware_fastener_bolt_strength_insert_input!]!
  on_conflict: property_item_hardware_fastener_bolt_strength_on_conflict
}

# aggregate avg on columns
type property_item_hardware_fastener_bolt_strength_avg_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by avg() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_avg_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# Boolean expression to filter rows from the table "property.item_hardware_fastener_bolt_strength". All fields are combined with a logical 'AND'.
input property_item_hardware_fastener_bolt_strength_bool_exp {
  _and: [property_item_hardware_fastener_bolt_strength_bool_exp]
  _not: property_item_hardware_fastener_bolt_strength_bool_exp
  _or: [property_item_hardware_fastener_bolt_strength_bool_exp]
  diameter: numeric_comparison_exp
  max_tightening_torque: numeric_comparison_exp
  proof_load: numeric_comparison_exp
  strength_grade: String_comparison_exp
  thread_pitch: numeric_comparison_exp
}

# unique or primary key constraints on table "property.item_hardware_fastener_bolt_strength"
enum property_item_hardware_fastener_bolt_strength_constraint {
  # unique or primary key constraint
  item_hardware_fastener_bolt_strength_pkey
}

# input type for incrementing integer column in table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_inc_input {
  diameter: numeric
  max_tightening_torque: numeric
  proof_load: numeric
  thread_pitch: numeric
}

# input type for inserting data into table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_insert_input {
  diameter: numeric
  max_tightening_torque: numeric
  proof_load: numeric
  strength_grade: String
  thread_pitch: numeric
}

# aggregate max on columns
type property_item_hardware_fastener_bolt_strength_max_fields {
  diameter: numeric
  max_tightening_torque: numeric
  proof_load: numeric
  strength_grade: String
  thread_pitch: numeric
}

# order by max() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_max_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  strength_grade: order_by
  thread_pitch: order_by
}

# aggregate min on columns
type property_item_hardware_fastener_bolt_strength_min_fields {
  diameter: numeric
  max_tightening_torque: numeric
  proof_load: numeric
  strength_grade: String
  thread_pitch: numeric
}

# order by min() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_min_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  strength_grade: order_by
  thread_pitch: order_by
}

# response of any mutation on the table "property.item_hardware_fastener_bolt_strength"
type property_item_hardware_fastener_bolt_strength_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_item_hardware_fastener_bolt_strength!]!
}

# input type for inserting object relation for remote table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_obj_rel_insert_input {
  data: property_item_hardware_fastener_bolt_strength_insert_input!
  on_conflict: property_item_hardware_fastener_bolt_strength_on_conflict
}

# on conflict condition type for table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_on_conflict {
  constraint: property_item_hardware_fastener_bolt_strength_constraint!
  update_columns: [property_item_hardware_fastener_bolt_strength_update_column!]!
  where: property_item_hardware_fastener_bolt_strength_bool_exp
}

# ordering options when selecting data from "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  strength_grade: order_by
  thread_pitch: order_by
}

# primary key columns input for table: "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_pk_columns_input {
  diameter: numeric!
  strength_grade: String!
  thread_pitch: numeric!
}

# select columns of table "property.item_hardware_fastener_bolt_strength"
enum property_item_hardware_fastener_bolt_strength_select_column {
  # column name
  diameter

  # column name
  max_tightening_torque

  # column name
  proof_load

  # column name
  strength_grade

  # column name
  thread_pitch
}

# input type for updating data in table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_set_input {
  diameter: numeric
  max_tightening_torque: numeric
  proof_load: numeric
  strength_grade: String
  thread_pitch: numeric
}

# aggregate stddev on columns
type property_item_hardware_fastener_bolt_strength_stddev_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by stddev() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_stddev_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# aggregate stddev_pop on columns
type property_item_hardware_fastener_bolt_strength_stddev_pop_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by stddev_pop() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_stddev_pop_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# aggregate stddev_samp on columns
type property_item_hardware_fastener_bolt_strength_stddev_samp_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by stddev_samp() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_stddev_samp_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# aggregate sum on columns
type property_item_hardware_fastener_bolt_strength_sum_fields {
  diameter: numeric
  max_tightening_torque: numeric
  proof_load: numeric
  thread_pitch: numeric
}

# order by sum() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_sum_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# update columns of table "property.item_hardware_fastener_bolt_strength"
enum property_item_hardware_fastener_bolt_strength_update_column {
  # column name
  diameter

  # column name
  max_tightening_torque

  # column name
  proof_load

  # column name
  strength_grade

  # column name
  thread_pitch
}

# aggregate var_pop on columns
type property_item_hardware_fastener_bolt_strength_var_pop_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by var_pop() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_var_pop_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# aggregate var_samp on columns
type property_item_hardware_fastener_bolt_strength_var_samp_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by var_samp() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_var_samp_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# aggregate variance on columns
type property_item_hardware_fastener_bolt_strength_variance_fields {
  diameter: Float
  max_tightening_torque: Float
  proof_load: Float
  thread_pitch: Float
}

# order by variance() on columns of table "property.item_hardware_fastener_bolt_strength"
input property_item_hardware_fastener_bolt_strength_variance_order_by {
  diameter: order_by
  max_tightening_torque: order_by
  proof_load: order_by
  thread_pitch: order_by
}

# Lookup table for items with the same diameter, pitch, and fit
#
#
# columns and relationships of "property_item_hardware_fastener_screw_machine.diameter"
type property_item_hardware_fastener_screw_machine_diameter {
  diameter_label: String!
  diameter_major: numeric!
  diameter_pitch_label: String!
  fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum!
  pitch: numeric!
  pitch_mm: numeric!
  standard: enum_item_hardware_fastener_thread_standard_enum!
  tap_drill_size: numeric
  thread_label: enum_item_hardware_fastener_thread_label_enum
  unit: enum_unit_enum!
}

# aggregated selection of "property_item_hardware_fastener_screw_machine.diameter"
type property_item_hardware_fastener_screw_machine_diameter_aggregate {
  aggregate: property_item_hardware_fastener_screw_machine_diameter_aggregate_fields
  nodes: [property_item_hardware_fastener_screw_machine_diameter!]!
}

# aggregate fields of "property_item_hardware_fastener_screw_machine.diameter"
type property_item_hardware_fastener_screw_machine_diameter_aggregate_fields {
  avg: property_item_hardware_fastener_screw_machine_diameter_avg_fields
  count(columns: [property_item_hardware_fastener_screw_machine_diameter_select_column!], distinct: Boolean): Int
  max: property_item_hardware_fastener_screw_machine_diameter_max_fields
  min: property_item_hardware_fastener_screw_machine_diameter_min_fields
  stddev: property_item_hardware_fastener_screw_machine_diameter_stddev_fields
  stddev_pop: property_item_hardware_fastener_screw_machine_diameter_stddev_pop_fields
  stddev_samp: property_item_hardware_fastener_screw_machine_diameter_stddev_samp_fields
  sum: property_item_hardware_fastener_screw_machine_diameter_sum_fields
  var_pop: property_item_hardware_fastener_screw_machine_diameter_var_pop_fields
  var_samp: property_item_hardware_fastener_screw_machine_diameter_var_samp_fields
  variance: property_item_hardware_fastener_screw_machine_diameter_variance_fields
}

# order by aggregate values of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_aggregate_order_by {
  avg: property_item_hardware_fastener_screw_machine_diameter_avg_order_by
  count: order_by
  max: property_item_hardware_fastener_screw_machine_diameter_max_order_by
  min: property_item_hardware_fastener_screw_machine_diameter_min_order_by
  stddev: property_item_hardware_fastener_screw_machine_diameter_stddev_order_by
  stddev_pop: property_item_hardware_fastener_screw_machine_diameter_stddev_pop_order_by
  stddev_samp: property_item_hardware_fastener_screw_machine_diameter_stddev_samp_order_by
  sum: property_item_hardware_fastener_screw_machine_diameter_sum_order_by
  var_pop: property_item_hardware_fastener_screw_machine_diameter_var_pop_order_by
  var_samp: property_item_hardware_fastener_screw_machine_diameter_var_samp_order_by
  variance: property_item_hardware_fastener_screw_machine_diameter_variance_order_by
}

# input type for inserting array relation for remote table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_arr_rel_insert_input {
  data: [property_item_hardware_fastener_screw_machine_diameter_insert_input!]!
  on_conflict: property_item_hardware_fastener_screw_machine_diameter_on_conflict
}

# aggregate avg on columns
type property_item_hardware_fastener_screw_machine_diameter_avg_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by avg() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_avg_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# Boolean expression to filter rows from the table "property_item_hardware_fastener_screw_machine.diameter". All fields are combined with a logical 'AND'.
input property_item_hardware_fastener_screw_machine_diameter_bool_exp {
  _and: [property_item_hardware_fastener_screw_machine_diameter_bool_exp]
  _not: property_item_hardware_fastener_screw_machine_diameter_bool_exp
  _or: [property_item_hardware_fastener_screw_machine_diameter_bool_exp]
  diameter_label: String_comparison_exp
  diameter_major: numeric_comparison_exp
  diameter_pitch_label: String_comparison_exp
  fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum_comparison_exp
  pitch: numeric_comparison_exp
  pitch_mm: numeric_comparison_exp
  standard: enum_item_hardware_fastener_thread_standard_enum_comparison_exp
  tap_drill_size: numeric_comparison_exp
  thread_label: enum_item_hardware_fastener_thread_label_enum_comparison_exp
  unit: enum_unit_enum_comparison_exp
}

# unique or primary key constraints on table "property_item_hardware_fastener_screw_machine.diameter"
enum property_item_hardware_fastener_screw_machine_diameter_constraint {
  # unique or primary key constraint
  diameter_pkey
}

# input type for incrementing integer column in table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_inc_input {
  diameter_major: numeric
  pitch: numeric
  pitch_mm: numeric
  tap_drill_size: numeric
}

# input type for inserting data into table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_insert_input {
  diameter_label: String
  diameter_major: numeric
  diameter_pitch_label: String
  fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  pitch: numeric
  pitch_mm: numeric
  standard: enum_item_hardware_fastener_thread_standard_enum
  tap_drill_size: numeric
  thread_label: enum_item_hardware_fastener_thread_label_enum
  unit: enum_unit_enum
}

# aggregate max on columns
type property_item_hardware_fastener_screw_machine_diameter_max_fields {
  diameter_label: String
  diameter_major: numeric
  diameter_pitch_label: String
  pitch: numeric
  pitch_mm: numeric
  tap_drill_size: numeric
}

# order by max() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_max_order_by {
  diameter_label: order_by
  diameter_major: order_by
  diameter_pitch_label: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# aggregate min on columns
type property_item_hardware_fastener_screw_machine_diameter_min_fields {
  diameter_label: String
  diameter_major: numeric
  diameter_pitch_label: String
  pitch: numeric
  pitch_mm: numeric
  tap_drill_size: numeric
}

# order by min() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_min_order_by {
  diameter_label: order_by
  diameter_major: order_by
  diameter_pitch_label: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# response of any mutation on the table "property_item_hardware_fastener_screw_machine.diameter"
type property_item_hardware_fastener_screw_machine_diameter_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_item_hardware_fastener_screw_machine_diameter!]!
}

# input type for inserting object relation for remote table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_obj_rel_insert_input {
  data: property_item_hardware_fastener_screw_machine_diameter_insert_input!
  on_conflict: property_item_hardware_fastener_screw_machine_diameter_on_conflict
}

# on conflict condition type for table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_on_conflict {
  constraint: property_item_hardware_fastener_screw_machine_diameter_constraint!
  update_columns: [property_item_hardware_fastener_screw_machine_diameter_update_column!]!
  where: property_item_hardware_fastener_screw_machine_diameter_bool_exp
}

# ordering options when selecting data from "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_order_by {
  diameter_label: order_by
  diameter_major: order_by
  diameter_pitch_label: order_by
  fit: order_by
  pitch: order_by
  pitch_mm: order_by
  standard: order_by
  tap_drill_size: order_by
  thread_label: order_by
  unit: order_by
}

# primary key columns input for table: "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_pk_columns_input {
  diameter_major: numeric!
  fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum!
  pitch: numeric!
}

# select columns of table "property_item_hardware_fastener_screw_machine.diameter"
enum property_item_hardware_fastener_screw_machine_diameter_select_column {
  # column name
  diameter_label

  # column name
  diameter_major

  # column name
  diameter_pitch_label

  # column name
  fit

  # column name
  pitch

  # column name
  pitch_mm

  # column name
  standard

  # column name
  tap_drill_size

  # column name
  thread_label

  # column name
  unit
}

# input type for updating data in table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_set_input {
  diameter_label: String
  diameter_major: numeric
  diameter_pitch_label: String
  fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum
  pitch: numeric
  pitch_mm: numeric
  standard: enum_item_hardware_fastener_thread_standard_enum
  tap_drill_size: numeric
  thread_label: enum_item_hardware_fastener_thread_label_enum
  unit: enum_unit_enum
}

# aggregate stddev on columns
type property_item_hardware_fastener_screw_machine_diameter_stddev_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by stddev() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_stddev_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# aggregate stddev_pop on columns
type property_item_hardware_fastener_screw_machine_diameter_stddev_pop_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by stddev_pop() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_stddev_pop_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# aggregate stddev_samp on columns
type property_item_hardware_fastener_screw_machine_diameter_stddev_samp_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by stddev_samp() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_stddev_samp_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# aggregate sum on columns
type property_item_hardware_fastener_screw_machine_diameter_sum_fields {
  diameter_major: numeric
  pitch: numeric
  pitch_mm: numeric
  tap_drill_size: numeric
}

# order by sum() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_sum_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# update columns of table "property_item_hardware_fastener_screw_machine.diameter"
enum property_item_hardware_fastener_screw_machine_diameter_update_column {
  # column name
  diameter_label

  # column name
  diameter_major

  # column name
  diameter_pitch_label

  # column name
  fit

  # column name
  pitch

  # column name
  pitch_mm

  # column name
  standard

  # column name
  tap_drill_size

  # column name
  thread_label

  # column name
  unit
}

# aggregate var_pop on columns
type property_item_hardware_fastener_screw_machine_diameter_var_pop_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by var_pop() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_var_pop_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# aggregate var_samp on columns
type property_item_hardware_fastener_screw_machine_diameter_var_samp_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by var_samp() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_var_samp_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# aggregate variance on columns
type property_item_hardware_fastener_screw_machine_diameter_variance_fields {
  diameter_major: Float
  pitch: Float
  pitch_mm: Float
  tap_drill_size: Float
}

# order by variance() on columns of table "property_item_hardware_fastener_screw_machine.diameter"
input property_item_hardware_fastener_screw_machine_diameter_variance_order_by {
  diameter_major: order_by
  pitch: order_by
  pitch_mm: order_by
  tap_drill_size: order_by
}

# query root
type query_root {
  # Retrieve Printer and Label status and properties
  PrinterStatus: PrinterStatus

  # fetch data from the table: "enum_item_cable.connector"
  enum_item_cable_connector(
    # distinct select on columns
    distinct_on: [enum_item_cable_connector_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_cable_connector_order_by!]

    # filter the rows returned
    where: enum_item_cable_connector_bool_exp
  ): [enum_item_cable_connector!]!

  # fetch aggregated fields from the table: "enum_item_cable.connector"
  enum_item_cable_connector_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_cable_connector_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_cable_connector_order_by!]

    # filter the rows returned
    where: enum_item_cable_connector_bool_exp
  ): enum_item_cable_connector_aggregate!

  # fetch data from the table: "enum_item_cable.connector" using primary key columns
  enum_item_cable_connector_by_pk(id: String!): enum_item_cable_connector

  # fetch data from the table: "enum.item_class"
  enum_item_class(
    # distinct select on columns
    distinct_on: [enum_item_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_class_order_by!]

    # filter the rows returned
    where: enum_item_class_bool_exp
  ): [enum_item_class!]!

  # fetch aggregated fields from the table: "enum.item_class"
  enum_item_class_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_class_order_by!]

    # filter the rows returned
    where: enum_item_class_bool_exp
  ): enum_item_class_aggregate!

  # fetch data from the table: "enum.item_class" using primary key columns
  enum_item_class_by_pk(id: String!): enum_item_class

  # fetch data from the table: "enum_item.handedness"
  enum_item_handedness(
    # distinct select on columns
    distinct_on: [enum_item_handedness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_handedness_order_by!]

    # filter the rows returned
    where: enum_item_handedness_bool_exp
  ): [enum_item_handedness!]!

  # fetch aggregated fields from the table: "enum_item.handedness"
  enum_item_handedness_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_handedness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_handedness_order_by!]

    # filter the rows returned
    where: enum_item_handedness_bool_exp
  ): enum_item_handedness_aggregate!

  # fetch data from the table: "enum_item.handedness" using primary key columns
  enum_item_handedness_by_pk(id: String!): enum_item_handedness

  # fetch data from the table: "enum_item_hardware_fastener.drive"
  enum_item_hardware_fastener_drive(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_drive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_drive_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_drive_bool_exp
  ): [enum_item_hardware_fastener_drive!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.drive"
  enum_item_hardware_fastener_drive_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_drive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_drive_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_drive_bool_exp
  ): enum_item_hardware_fastener_drive_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.drive" using primary key columns
  enum_item_hardware_fastener_drive_by_pk(id: String!): enum_item_hardware_fastener_drive

  # fetch data from the table: "enum_item_hardware_fastener.material"
  enum_item_hardware_fastener_material(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_material_bool_exp
  ): [enum_item_hardware_fastener_material!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.material"
  enum_item_hardware_fastener_material_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_material_bool_exp
  ): enum_item_hardware_fastener_material_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.material" using primary key columns
  enum_item_hardware_fastener_material_by_pk(id: String!): enum_item_hardware_fastener_material

  # fetch data from the table: "enum_item_hardware_fastener_nut.form"
  enum_item_hardware_fastener_nut_form(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_form_bool_exp
  ): [enum_item_hardware_fastener_nut_form!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_nut.form"
  enum_item_hardware_fastener_nut_form_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_form_bool_exp
  ): enum_item_hardware_fastener_nut_form_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_nut.form" using primary key columns
  enum_item_hardware_fastener_nut_form_by_pk(id: String!): enum_item_hardware_fastener_nut_form

  # fetch data from the table: "enum_item_hardware_fastener_nut.strength"
  enum_item_hardware_fastener_nut_strength(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_strength_bool_exp
  ): [enum_item_hardware_fastener_nut_strength!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_nut.strength"
  enum_item_hardware_fastener_nut_strength_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_strength_bool_exp
  ): enum_item_hardware_fastener_nut_strength_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_nut.strength" using primary key columns
  enum_item_hardware_fastener_nut_strength_by_pk(id: String!): enum_item_hardware_fastener_nut_strength

  # fetch data from the table: "enum_item_hardware_fastener_nut.thread_fit"
  enum_item_hardware_fastener_nut_thread_fit(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_thread_fit_bool_exp
  ): [enum_item_hardware_fastener_nut_thread_fit!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_nut.thread_fit"
  enum_item_hardware_fastener_nut_thread_fit_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_thread_fit_bool_exp
  ): enum_item_hardware_fastener_nut_thread_fit_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_nut.thread_fit" using primary key columns
  enum_item_hardware_fastener_nut_thread_fit_by_pk(id: String!): enum_item_hardware_fastener_nut_thread_fit

  # fetch data from the table: "enum_item_hardware_fastener_screw.hardness"
  enum_item_hardware_fastener_screw_hardness(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_hardness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_hardness_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_hardness_bool_exp
  ): [enum_item_hardware_fastener_screw_hardness!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw.hardness"
  enum_item_hardware_fastener_screw_hardness_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_hardness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_hardness_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_hardness_bool_exp
  ): enum_item_hardware_fastener_screw_hardness_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw.hardness" using primary key columns
  enum_item_hardware_fastener_screw_hardness_by_pk(id: String!): enum_item_hardware_fastener_screw_hardness

  # fetch data from the table: "enum_item_hardware_fastener_screw.head"
  enum_item_hardware_fastener_screw_head(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_head_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_head_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_head_bool_exp
  ): [enum_item_hardware_fastener_screw_head!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw.head"
  enum_item_hardware_fastener_screw_head_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_head_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_head_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_head_bool_exp
  ): enum_item_hardware_fastener_screw_head_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw.head" using primary key columns
  enum_item_hardware_fastener_screw_head_by_pk(id: String!): enum_item_hardware_fastener_screw_head

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.point"
  enum_item_hardware_fastener_screw_machine_point(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_point_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_point_bool_exp
  ): [enum_item_hardware_fastener_screw_machine_point!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw_machine.point"
  enum_item_hardware_fastener_screw_machine_point_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_point_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_point_bool_exp
  ): enum_item_hardware_fastener_screw_machine_point_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.point" using primary key columns
  enum_item_hardware_fastener_screw_machine_point_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_point

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.strength"
  enum_item_hardware_fastener_screw_machine_strength(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_strength_bool_exp
  ): [enum_item_hardware_fastener_screw_machine_strength!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw_machine.strength"
  enum_item_hardware_fastener_screw_machine_strength_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_strength_bool_exp
  ): enum_item_hardware_fastener_screw_machine_strength_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.strength" using primary key columns
  enum_item_hardware_fastener_screw_machine_strength_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_strength

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  enum_item_hardware_fastener_screw_machine_thread_fit(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp
  ): [enum_item_hardware_fastener_screw_machine_thread_fit!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  enum_item_hardware_fastener_screw_machine_thread_fit_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp
  ): enum_item_hardware_fastener_screw_machine_thread_fit_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.thread_fit" using primary key columns
  enum_item_hardware_fastener_screw_machine_thread_fit_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_thread_fit

  # fetch data from the table: "enum_item_hardware_fastener.standoff_shape"
  enum_item_hardware_fastener_standoff_shape(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_standoff_shape_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_standoff_shape_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_standoff_shape_bool_exp
  ): [enum_item_hardware_fastener_standoff_shape!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.standoff_shape"
  enum_item_hardware_fastener_standoff_shape_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_standoff_shape_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_standoff_shape_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_standoff_shape_bool_exp
  ): enum_item_hardware_fastener_standoff_shape_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.standoff_shape" using primary key columns
  enum_item_hardware_fastener_standoff_shape_by_pk(id: String!): enum_item_hardware_fastener_standoff_shape

  # fetch data from the table: "enum_item_hardware_fastener.thread_label"
  enum_item_hardware_fastener_thread_label(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_label_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_label_bool_exp
  ): [enum_item_hardware_fastener_thread_label!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.thread_label"
  enum_item_hardware_fastener_thread_label_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_label_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_label_bool_exp
  ): enum_item_hardware_fastener_thread_label_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.thread_label" using primary key columns
  enum_item_hardware_fastener_thread_label_by_pk(id: String!): enum_item_hardware_fastener_thread_label

  # fetch data from the table: "enum_item_hardware_fastener.thread_standard"
  enum_item_hardware_fastener_thread_standard(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_standard_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_standard_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_standard_bool_exp
  ): [enum_item_hardware_fastener_thread_standard!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.thread_standard"
  enum_item_hardware_fastener_thread_standard_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_standard_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_standard_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_standard_bool_exp
  ): enum_item_hardware_fastener_thread_standard_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.thread_standard" using primary key columns
  enum_item_hardware_fastener_thread_standard_by_pk(id: String!): enum_item_hardware_fastener_thread_standard

  # fetch data from the table: "enum_item_hardware_fastener_washer.form"
  enum_item_hardware_fastener_washer_form(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_form_bool_exp
  ): [enum_item_hardware_fastener_washer_form!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_washer.form"
  enum_item_hardware_fastener_washer_form_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_form_bool_exp
  ): enum_item_hardware_fastener_washer_form_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_washer.form" using primary key columns
  enum_item_hardware_fastener_washer_form_by_pk(id: String!): enum_item_hardware_fastener_washer_form

  # fetch data from the table: "enum_item_hardware_fastener_washer.mechanism"
  enum_item_hardware_fastener_washer_mechanism(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_mechanism_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_mechanism_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_mechanism_bool_exp
  ): [enum_item_hardware_fastener_washer_mechanism!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_washer.mechanism"
  enum_item_hardware_fastener_washer_mechanism_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_mechanism_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_mechanism_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_mechanism_bool_exp
  ): enum_item_hardware_fastener_washer_mechanism_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_washer.mechanism" using primary key columns
  enum_item_hardware_fastener_washer_mechanism_by_pk(id: String!): enum_item_hardware_fastener_washer_mechanism

  # fetch data from the table: "enum_item_hardware_fastener_washer.pattern"
  enum_item_hardware_fastener_washer_pattern(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_pattern_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_pattern_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_pattern_bool_exp
  ): [enum_item_hardware_fastener_washer_pattern!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_washer.pattern"
  enum_item_hardware_fastener_washer_pattern_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_pattern_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_pattern_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_pattern_bool_exp
  ): enum_item_hardware_fastener_washer_pattern_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_washer.pattern" using primary key columns
  enum_item_hardware_fastener_washer_pattern_by_pk(id: String!): enum_item_hardware_fastener_washer_pattern

  # fetch data from the table: "enum_item_hardware.finish"
  enum_item_hardware_finish(
    # distinct select on columns
    distinct_on: [enum_item_hardware_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_finish_order_by!]

    # filter the rows returned
    where: enum_item_hardware_finish_bool_exp
  ): [enum_item_hardware_finish!]!

  # fetch aggregated fields from the table: "enum_item_hardware.finish"
  enum_item_hardware_finish_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_finish_order_by!]

    # filter the rows returned
    where: enum_item_hardware_finish_bool_exp
  ): enum_item_hardware_finish_aggregate!

  # fetch data from the table: "enum_item_hardware.finish" using primary key columns
  enum_item_hardware_finish_by_pk(id: String!): enum_item_hardware_finish

  # fetch data from the table: "enum_item_hardware.use_material"
  enum_item_hardware_use_material(
    # distinct select on columns
    distinct_on: [enum_item_hardware_use_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_use_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_use_material_bool_exp
  ): [enum_item_hardware_use_material!]!

  # fetch aggregated fields from the table: "enum_item_hardware.use_material"
  enum_item_hardware_use_material_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_use_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_use_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_use_material_bool_exp
  ): enum_item_hardware_use_material_aggregate!

  # fetch data from the table: "enum_item_hardware.use_material" using primary key columns
  enum_item_hardware_use_material_by_pk(id: String!): enum_item_hardware_use_material

  # fetch data from the table: "enum_item_tool.drill_bit_finish"
  enum_item_tool_drill_bit_finish(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_finish_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_finish_bool_exp
  ): [enum_item_tool_drill_bit_finish!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_finish"
  enum_item_tool_drill_bit_finish_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_finish_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_finish_bool_exp
  ): enum_item_tool_drill_bit_finish_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_finish" using primary key columns
  enum_item_tool_drill_bit_finish_by_pk(id: String!): enum_item_tool_drill_bit_finish

  # fetch data from the table: "enum_item_tool.drill_bit_length_class"
  enum_item_tool_drill_bit_length_class(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_length_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_length_class_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_length_class_bool_exp
  ): [enum_item_tool_drill_bit_length_class!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_length_class"
  enum_item_tool_drill_bit_length_class_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_length_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_length_class_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_length_class_bool_exp
  ): enum_item_tool_drill_bit_length_class_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_length_class" using primary key columns
  enum_item_tool_drill_bit_length_class_by_pk(id: String!): enum_item_tool_drill_bit_length_class

  # fetch data from the table: "enum_item_tool.drill_bit_material"
  enum_item_tool_drill_bit_material(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_material_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_material_bool_exp
  ): [enum_item_tool_drill_bit_material!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_material"
  enum_item_tool_drill_bit_material_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_material_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_material_bool_exp
  ): enum_item_tool_drill_bit_material_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_material" using primary key columns
  enum_item_tool_drill_bit_material_by_pk(id: String!): enum_item_tool_drill_bit_material

  # fetch data from the table: "enum_item_tool.drill_bit_point"
  enum_item_tool_drill_bit_point(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_point_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_point_bool_exp
  ): [enum_item_tool_drill_bit_point!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_point"
  enum_item_tool_drill_bit_point_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_point_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_point_bool_exp
  ): enum_item_tool_drill_bit_point_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_point" using primary key columns
  enum_item_tool_drill_bit_point_by_pk(id: String!): enum_item_tool_drill_bit_point

  # fetch data from the table: "enum_item_tool.drill_bit_shank"
  enum_item_tool_drill_bit_shank(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_shank_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_shank_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_shank_bool_exp
  ): [enum_item_tool_drill_bit_shank!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_shank"
  enum_item_tool_drill_bit_shank_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_shank_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_shank_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_shank_bool_exp
  ): enum_item_tool_drill_bit_shank_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_shank" using primary key columns
  enum_item_tool_drill_bit_shank_by_pk(id: String!): enum_item_tool_drill_bit_shank

  # fetch data from the table: "enum_item_tool.drill_bit_style"
  enum_item_tool_drill_bit_style(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_style_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_style_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_style_bool_exp
  ): [enum_item_tool_drill_bit_style!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_style"
  enum_item_tool_drill_bit_style_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_style_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_style_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_style_bool_exp
  ): enum_item_tool_drill_bit_style_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_style" using primary key columns
  enum_item_tool_drill_bit_style_by_pk(id: String!): enum_item_tool_drill_bit_style

  # fetch data from the table: "enum.mapped_class"
  enum_mapped_class(
    # distinct select on columns
    distinct_on: [enum_mapped_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_mapped_class_order_by!]

    # filter the rows returned
    where: enum_mapped_class_bool_exp
  ): [enum_mapped_class!]!

  # fetch aggregated fields from the table: "enum.mapped_class"
  enum_mapped_class_aggregate(
    # distinct select on columns
    distinct_on: [enum_mapped_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_mapped_class_order_by!]

    # filter the rows returned
    where: enum_mapped_class_bool_exp
  ): enum_mapped_class_aggregate!

  # fetch data from the table: "enum.mapped_class" using primary key columns
  enum_mapped_class_by_pk(id: String!): enum_mapped_class

  # fetch data from the table: "enum.payment_method_type"
  enum_payment_method_type(
    # distinct select on columns
    distinct_on: [enum_payment_method_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_payment_method_type_order_by!]

    # filter the rows returned
    where: enum_payment_method_type_bool_exp
  ): [enum_payment_method_type!]!

  # fetch aggregated fields from the table: "enum.payment_method_type"
  enum_payment_method_type_aggregate(
    # distinct select on columns
    distinct_on: [enum_payment_method_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_payment_method_type_order_by!]

    # filter the rows returned
    where: enum_payment_method_type_bool_exp
  ): enum_payment_method_type_aggregate!

  # fetch data from the table: "enum.payment_method_type" using primary key columns
  enum_payment_method_type_by_pk(id: String!): enum_payment_method_type

  # fetch data from the table: "enum.space_type"
  enum_space_type(
    # distinct select on columns
    distinct_on: [enum_space_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_space_type_order_by!]

    # filter the rows returned
    where: enum_space_type_bool_exp
  ): [enum_space_type!]!

  # fetch aggregated fields from the table: "enum.space_type"
  enum_space_type_aggregate(
    # distinct select on columns
    distinct_on: [enum_space_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_space_type_order_by!]

    # filter the rows returned
    where: enum_space_type_bool_exp
  ): enum_space_type_aggregate!

  # fetch data from the table: "enum.space_type" using primary key columns
  enum_space_type_by_pk(id: String!): enum_space_type

  # fetch data from the table: "enum.stock_event_type"
  enum_stock_event_type(
    # distinct select on columns
    distinct_on: [enum_stock_event_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_stock_event_type_order_by!]

    # filter the rows returned
    where: enum_stock_event_type_bool_exp
  ): [enum_stock_event_type!]!

  # fetch aggregated fields from the table: "enum.stock_event_type"
  enum_stock_event_type_aggregate(
    # distinct select on columns
    distinct_on: [enum_stock_event_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_stock_event_type_order_by!]

    # filter the rows returned
    where: enum_stock_event_type_bool_exp
  ): enum_stock_event_type_aggregate!

  # fetch data from the table: "enum.stock_event_type" using primary key columns
  enum_stock_event_type_by_pk(id: String!): enum_stock_event_type

  # fetch data from the table: "enum.unit"
  enum_unit(
    # distinct select on columns
    distinct_on: [enum_unit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_unit_order_by!]

    # filter the rows returned
    where: enum_unit_bool_exp
  ): [enum_unit!]!

  # fetch aggregated fields from the table: "enum.unit"
  enum_unit_aggregate(
    # distinct select on columns
    distinct_on: [enum_unit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_unit_order_by!]

    # filter the rows returned
    where: enum_unit_bool_exp
  ): enum_unit_aggregate!

  # fetch data from the table: "enum.unit" using primary key columns
  enum_unit_by_pk(id: String!): enum_unit
  files: [File]

  # fetch data from the table: "icon"
  icon(
    # distinct select on columns
    distinct_on: [icon_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_order_by!]

    # filter the rows returned
    where: icon_bool_exp
  ): [icon!]!

  # fetch aggregated fields from the table: "icon"
  icon_aggregate(
    # distinct select on columns
    distinct_on: [icon_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_order_by!]

    # filter the rows returned
    where: icon_bool_exp
  ): icon_aggregate!

  # fetch data from the table: "icon" using primary key columns
  icon_by_pk(id: uuid!): icon

  # fetch data from the table: "icon_item_category_map"
  icon_item_category_map(
    # distinct select on columns
    distinct_on: [icon_item_category_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_category_map_order_by!]

    # filter the rows returned
    where: icon_item_category_map_bool_exp
  ): [icon_item_category_map!]!

  # fetch aggregated fields from the table: "icon_item_category_map"
  icon_item_category_map_aggregate(
    # distinct select on columns
    distinct_on: [icon_item_category_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_category_map_order_by!]

    # filter the rows returned
    where: icon_item_category_map_bool_exp
  ): icon_item_category_map_aggregate!

  # fetch data from the table: "icon_item_category_map" using primary key columns
  icon_item_category_map_by_pk(category: enum_item_class_enum!, icon_id: uuid!, sequence: smallint!): icon_item_category_map

  # fetch data from the table: "icon_item_map"
  icon_item_map(
    # distinct select on columns
    distinct_on: [icon_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_map_order_by!]

    # filter the rows returned
    where: icon_item_map_bool_exp
  ): [icon_item_map!]!

  # fetch aggregated fields from the table: "icon_item_map"
  icon_item_map_aggregate(
    # distinct select on columns
    distinct_on: [icon_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_map_order_by!]

    # filter the rows returned
    where: icon_item_map_bool_exp
  ): icon_item_map_aggregate!

  # fetch data from the table: "icon_item_map" using primary key columns
  icon_item_map_by_pk(icon_id: uuid!, item_id: Int!): icon_item_map

  # fetch data from the table: "icon_label_map"
  icon_label_map(
    # distinct select on columns
    distinct_on: [icon_label_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_label_map_order_by!]

    # filter the rows returned
    where: icon_label_map_bool_exp
  ): [icon_label_map!]!

  # fetch aggregated fields from the table: "icon_label_map"
  icon_label_map_aggregate(
    # distinct select on columns
    distinct_on: [icon_label_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_label_map_order_by!]

    # filter the rows returned
    where: icon_label_map_bool_exp
  ): icon_label_map_aggregate!

  # fetch data from the table: "icon_label_map" using primary key columns
  icon_label_map_by_pk(icon_id: uuid!, label_id: uuid!): icon_label_map

  # fetch data from the table: "item"
  item(
    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): [item!]!

  # fetch aggregated fields from the table: "item"
  item_aggregate(
    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): item_aggregate!

  # fetch data from the table: "item.bundle"
  item_bundle(
    # distinct select on columns
    distinct_on: [item_bundle_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_order_by!]

    # filter the rows returned
    where: item_bundle_bool_exp
  ): [item_bundle!]!

  # fetch aggregated fields from the table: "item.bundle"
  item_bundle_aggregate(
    # distinct select on columns
    distinct_on: [item_bundle_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_order_by!]

    # filter the rows returned
    where: item_bundle_bool_exp
  ): item_bundle_aggregate!

  # fetch data from the table: "item.bundle" using primary key columns
  item_bundle_by_pk(id: Int!): item_bundle

  # fetch data from the table: "item.bundle_map"
  item_bundle_map(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): [item_bundle_map!]!

  # fetch aggregated fields from the table: "item.bundle_map"
  item_bundle_map_aggregate(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): item_bundle_map_aggregate!

  # fetch data from the table: "item.bundle_map" using primary key columns
  item_bundle_map_by_pk(item_bundle_id: Int!, item_member_id: Int!): item_bundle_map

  # fetch data from the table: "item" using primary key columns
  item_by_pk(id: Int!): item

  # fetch data from the table: "item.cable_conductive"
  item_cable_conductive(
    # distinct select on columns
    distinct_on: [item_cable_conductive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_cable_conductive_order_by!]

    # filter the rows returned
    where: item_cable_conductive_bool_exp
  ): [item_cable_conductive!]!

  # fetch aggregated fields from the table: "item.cable_conductive"
  item_cable_conductive_aggregate(
    # distinct select on columns
    distinct_on: [item_cable_conductive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_cable_conductive_order_by!]

    # filter the rows returned
    where: item_cable_conductive_bool_exp
  ): item_cable_conductive_aggregate!

  # fetch data from the table: "item.cable_conductive" using primary key columns
  item_cable_conductive_by_pk(id: Int!): item_cable_conductive

  # fetch data from the table: "item.hardware_drill_bit"
  item_hardware_drill_bit(
    # distinct select on columns
    distinct_on: [item_hardware_drill_bit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_drill_bit_order_by!]

    # filter the rows returned
    where: item_hardware_drill_bit_bool_exp
  ): [item_hardware_drill_bit!]!

  # fetch aggregated fields from the table: "item.hardware_drill_bit"
  item_hardware_drill_bit_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_drill_bit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_drill_bit_order_by!]

    # filter the rows returned
    where: item_hardware_drill_bit_bool_exp
  ): item_hardware_drill_bit_aggregate!

  # fetch data from the table: "item.hardware_drill_bit" using primary key columns
  item_hardware_drill_bit_by_pk(id: Int!): item_hardware_drill_bit

  # fetch data from the table: "item.hardware_fastener_insert"
  item_hardware_fastener_insert(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_insert_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_insert_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_insert_bool_exp
  ): [item_hardware_fastener_insert!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_insert"
  item_hardware_fastener_insert_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_insert_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_insert_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_insert_bool_exp
  ): item_hardware_fastener_insert_aggregate!

  # fetch data from the table: "item.hardware_fastener_insert" using primary key columns
  item_hardware_fastener_insert_by_pk(id: Int!): item_hardware_fastener_insert

  # fetch data from the table: "item.hardware_fastener_nut"
  item_hardware_fastener_nut(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_nut_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_nut_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_nut_bool_exp
  ): [item_hardware_fastener_nut!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_nut"
  item_hardware_fastener_nut_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_nut_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_nut_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_nut_bool_exp
  ): item_hardware_fastener_nut_aggregate!

  # fetch data from the table: "item.hardware_fastener_nut" using primary key columns
  item_hardware_fastener_nut_by_pk(id: Int!): item_hardware_fastener_nut

  # fetch data from the table: "item.hardware_fastener_screw"
  item_hardware_fastener_screw(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_bool_exp
  ): [item_hardware_fastener_screw!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_screw"
  item_hardware_fastener_screw_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_bool_exp
  ): item_hardware_fastener_screw_aggregate!

  # fetch data from the table: "item.hardware_fastener_screw" using primary key columns
  item_hardware_fastener_screw_by_pk(id: Int!): item_hardware_fastener_screw

  # fetch data from the table: "item.hardware_fastener_screw_machine"
  item_hardware_fastener_screw_machine(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_machine_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_machine_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_machine_bool_exp
  ): [item_hardware_fastener_screw_machine!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_screw_machine"
  item_hardware_fastener_screw_machine_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_machine_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_machine_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_machine_bool_exp
  ): item_hardware_fastener_screw_machine_aggregate!

  # fetch data from the table: "item.hardware_fastener_screw_machine" using primary key columns
  item_hardware_fastener_screw_machine_by_pk(id: Int!): item_hardware_fastener_screw_machine

  # fetch data from the table: "item.hardware_fastener_standoff"
  item_hardware_fastener_standoff(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_standoff_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_standoff_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_standoff_bool_exp
  ): [item_hardware_fastener_standoff!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_standoff"
  item_hardware_fastener_standoff_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_standoff_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_standoff_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_standoff_bool_exp
  ): item_hardware_fastener_standoff_aggregate!

  # fetch data from the table: "item.hardware_fastener_standoff" using primary key columns
  item_hardware_fastener_standoff_by_pk(id: Int!): item_hardware_fastener_standoff

  # fetch data from the table: "item.hardware_fastener_washer"
  item_hardware_fastener_washer(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_washer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_washer_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_washer_bool_exp
  ): [item_hardware_fastener_washer!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_washer"
  item_hardware_fastener_washer_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_washer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_washer_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_washer_bool_exp
  ): item_hardware_fastener_washer_aggregate!

  # fetch data from the table: "item.hardware_fastener_washer" using primary key columns
  item_hardware_fastener_washer_by_pk(id: Int!): item_hardware_fastener_washer

  # fetch data from the table: "item_variant"
  item_variant(
    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): [item_variant!]!

  # fetch aggregated fields from the table: "item_variant"
  item_variant_aggregate(
    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): item_variant_aggregate!

  # fetch data from the table: "label"
  label(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): [label!]!

  # fetch aggregated fields from the table: "label"
  label_aggregate(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): label_aggregate!

  # fetch data from the table: "label" using primary key columns
  label_by_pk(id: uuid!): label

  # fetch data from the table: "label_item_map"
  label_item_map(
    # distinct select on columns
    distinct_on: [label_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_item_map_order_by!]

    # filter the rows returned
    where: label_item_map_bool_exp
  ): [label_item_map!]!

  # fetch aggregated fields from the table: "label_item_map"
  label_item_map_aggregate(
    # distinct select on columns
    distinct_on: [label_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_item_map_order_by!]

    # filter the rows returned
    where: label_item_map_bool_exp
  ): label_item_map_aggregate!

  # fetch data from the table: "label_item_map" using primary key columns
  label_item_map_by_pk(item_id: Int!, label_id: uuid!): label_item_map

  # fetch data from the table: "label_template_map"
  label_template_map(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): [label_template_map!]!

  # fetch aggregated fields from the table: "label_template_map"
  label_template_map_aggregate(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): label_template_map_aggregate!

  # fetch data from the table: "label_template_map" using primary key columns
  label_template_map_by_pk(item_class: String!, label_id: uuid!, sequence: smallint!): label_template_map

  # fetch data from the table: "manufacturer"
  manufacturer(
    # distinct select on columns
    distinct_on: [manufacturer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_order_by!]

    # filter the rows returned
    where: manufacturer_bool_exp
  ): [manufacturer!]!

  # fetch aggregated fields from the table: "manufacturer"
  manufacturer_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_order_by!]

    # filter the rows returned
    where: manufacturer_bool_exp
  ): manufacturer_aggregate!

  # fetch data from the table: "manufacturer" using primary key columns
  manufacturer_by_pk(id: Int!): manufacturer

  # fetch data from the table: "manufacturer_item"
  manufacturer_item(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): [manufacturer_item!]!

  # fetch aggregated fields from the table: "manufacturer_item"
  manufacturer_item_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): manufacturer_item_aggregate!

  # fetch data from the table: "manufacturer_item" using primary key columns
  manufacturer_item_by_pk(id: Int!): manufacturer_item

  # fetch data from the table: "order"
  order(
    # distinct select on columns
    distinct_on: [order_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_order_by!]

    # filter the rows returned
    where: order_bool_exp
  ): [order!]!

  # fetch aggregated fields from the table: "order"
  order_aggregate(
    # distinct select on columns
    distinct_on: [order_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_order_by!]

    # filter the rows returned
    where: order_bool_exp
  ): order_aggregate!

  # fetch data from the table: "order" using primary key columns
  order_by_pk(id: Int!): order

  # fetch data from the table: "order_item"
  order_item(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): [order_item!]!

  # fetch aggregated fields from the table: "order_item"
  order_item_aggregate(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): order_item_aggregate!

  # fetch data from the table: "order_item" using primary key columns
  order_item_by_pk(id: Int!): order_item

  # fetch data from the table: "payment_method"
  payment_method(
    # distinct select on columns
    distinct_on: [payment_method_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [payment_method_order_by!]

    # filter the rows returned
    where: payment_method_bool_exp
  ): [payment_method!]!

  # fetch aggregated fields from the table: "payment_method"
  payment_method_aggregate(
    # distinct select on columns
    distinct_on: [payment_method_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [payment_method_order_by!]

    # filter the rows returned
    where: payment_method_bool_exp
  ): payment_method_aggregate!

  # fetch data from the table: "payment_method" using primary key columns
  payment_method_by_pk(id: Int!): payment_method

  # fetch data from the table: "property.item_hardware_fastener_bolt_strength"
  property_item_hardware_fastener_bolt_strength(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_bolt_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_bolt_strength_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_bolt_strength_bool_exp
  ): [property_item_hardware_fastener_bolt_strength!]!

  # fetch aggregated fields from the table: "property.item_hardware_fastener_bolt_strength"
  property_item_hardware_fastener_bolt_strength_aggregate(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_bolt_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_bolt_strength_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_bolt_strength_bool_exp
  ): property_item_hardware_fastener_bolt_strength_aggregate!

  # fetch data from the table: "property.item_hardware_fastener_bolt_strength" using primary key columns
  property_item_hardware_fastener_bolt_strength_by_pk(diameter: numeric!, strength_grade: String!, thread_pitch: numeric!): property_item_hardware_fastener_bolt_strength

  # fetch data from the table: "property_item_hardware_fastener_screw_machine.diameter"
  property_item_hardware_fastener_screw_machine_diameter(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_screw_machine_diameter_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_screw_machine_diameter_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_screw_machine_diameter_bool_exp
  ): [property_item_hardware_fastener_screw_machine_diameter!]!

  # fetch aggregated fields from the table: "property_item_hardware_fastener_screw_machine.diameter"
  property_item_hardware_fastener_screw_machine_diameter_aggregate(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_screw_machine_diameter_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_screw_machine_diameter_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_screw_machine_diameter_bool_exp
  ): property_item_hardware_fastener_screw_machine_diameter_aggregate!

  # fetch data from the table: "property_item_hardware_fastener_screw_machine.diameter" using primary key columns
  property_item_hardware_fastener_screw_machine_diameter_by_pk(diameter_major: numeric!, fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum!, pitch: numeric!): property_item_hardware_fastener_screw_machine_diameter

  # execute function "search" which returns "search_data"
  search(
    # input parameters for function "search"
    args: search_args!

    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): [search_data!]!

  # execute function "search" and query aggregates on result of table type "search_data"
  search_aggregate(
    # input parameters for function "search"
    args: search_args!

    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): search_data_aggregate!

  # fetch data from the table: "search_data"
  search_data(
    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): [search_data!]!

  # fetch aggregated fields from the table: "search_data"
  search_data_aggregate(
    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): search_data_aggregate!

  # fetch data from the table: "search_data" using primary key columns
  search_data_by_pk(id: bigint!): search_data

  # execute function "search_item" which returns "item"
  search_item(
    # input parameters for function "search_item"
    args: search_item_args!

    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): [item!]!

  # execute function "search_item" and query aggregates on result of table type "item"
  search_item_aggregate(
    # input parameters for function "search_item"
    args: search_item_args!

    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): item_aggregate!

  # execute function "search_item_variant" which returns "item_variant"
  search_item_variant(
    # input parameters for function "search_item_variant"
    args: search_item_variant_args!

    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): [item_variant!]!

  # execute function "search_item_variant" and query aggregates on result of table type "item_variant"
  search_item_variant_aggregate(
    # input parameters for function "search_item_variant"
    args: search_item_variant_args!

    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): item_variant_aggregate!

  # fetch data from the table: "shipment"
  shipment(
    # distinct select on columns
    distinct_on: [shipment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [shipment_order_by!]

    # filter the rows returned
    where: shipment_bool_exp
  ): [shipment!]!

  # fetch aggregated fields from the table: "shipment"
  shipment_aggregate(
    # distinct select on columns
    distinct_on: [shipment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [shipment_order_by!]

    # filter the rows returned
    where: shipment_bool_exp
  ): shipment_aggregate!

  # fetch data from the table: "shipment" using primary key columns
  shipment_by_pk(id: Int!): shipment

  # fetch data from the table: "stock"
  stock(
    # distinct select on columns
    distinct_on: [stock_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stock_order_by!]

    # filter the rows returned
    where: stock_bool_exp
  ): [stock!]!

  # fetch aggregated fields from the table: "stock"
  stock_aggregate(
    # distinct select on columns
    distinct_on: [stock_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stock_order_by!]

    # filter the rows returned
    where: stock_bool_exp
  ): stock_aggregate!

  # fetch data from the table: "stock" using primary key columns
  stock_by_pk(id: Int!): stock

  # fetch data from the table: "storage"
  storage(
    # distinct select on columns
    distinct_on: [storage_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [storage_order_by!]

    # filter the rows returned
    where: storage_bool_exp
  ): [storage!]!

  # fetch aggregated fields from the table: "storage"
  storage_aggregate(
    # distinct select on columns
    distinct_on: [storage_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [storage_order_by!]

    # filter the rows returned
    where: storage_bool_exp
  ): storage_aggregate!

  # fetch data from the table: "storage" using primary key columns
  storage_by_pk(id: Int!): storage

  # fetch data from the table: "tag"
  tag(
    # distinct select on columns
    distinct_on: [tag_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tag_order_by!]

    # filter the rows returned
    where: tag_bool_exp
  ): [tag!]!

  # fetch aggregated fields from the table: "tag"
  tag_aggregate(
    # distinct select on columns
    distinct_on: [tag_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tag_order_by!]

    # filter the rows returned
    where: tag_bool_exp
  ): tag_aggregate!

  # fetch data from the table: "tag" using primary key columns
  tag_by_pk(text: String!): tag

  # fetch data from the table: "vendor"
  vendor(
    # distinct select on columns
    distinct_on: [vendor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_order_by!]

    # filter the rows returned
    where: vendor_bool_exp
  ): [vendor!]!

  # fetch aggregated fields from the table: "vendor"
  vendor_aggregate(
    # distinct select on columns
    distinct_on: [vendor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_order_by!]

    # filter the rows returned
    where: vendor_bool_exp
  ): vendor_aggregate!

  # fetch data from the table: "vendor" using primary key columns
  vendor_by_pk(id: Int!): vendor

  # fetch data from the table: "vendor_item"
  vendor_item(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): [vendor_item!]!

  # fetch aggregated fields from the table: "vendor_item"
  vendor_item_aggregate(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): vendor_item_aggregate!

  # fetch data from the table: "vendor_item" using primary key columns
  vendor_item_by_pk(id: Int!): vendor_item
}

input search_args {
  query_text: String
  return_limit: Int
}

# columns and relationships of "search_data"
type search_data {
  class: enum_mapped_class_enum!
  id: bigint!
  metadata(
    # JSON select path
    path: String
  ): jsonb
  search_vector: tsvector

  # Searchable text
  text: String
}

# aggregated selection of "search_data"
type search_data_aggregate {
  aggregate: search_data_aggregate_fields
  nodes: [search_data!]!
}

# aggregate fields of "search_data"
type search_data_aggregate_fields {
  avg: search_data_avg_fields
  count(columns: [search_data_select_column!], distinct: Boolean): Int
  max: search_data_max_fields
  min: search_data_min_fields
  stddev: search_data_stddev_fields
  stddev_pop: search_data_stddev_pop_fields
  stddev_samp: search_data_stddev_samp_fields
  sum: search_data_sum_fields
  var_pop: search_data_var_pop_fields
  var_samp: search_data_var_samp_fields
  variance: search_data_variance_fields
}

# order by aggregate values of table "search_data"
input search_data_aggregate_order_by {
  avg: search_data_avg_order_by
  count: order_by
  max: search_data_max_order_by
  min: search_data_min_order_by
  stddev: search_data_stddev_order_by
  stddev_pop: search_data_stddev_pop_order_by
  stddev_samp: search_data_stddev_samp_order_by
  sum: search_data_sum_order_by
  var_pop: search_data_var_pop_order_by
  var_samp: search_data_var_samp_order_by
  variance: search_data_variance_order_by
}

# append existing jsonb value of filtered columns with new jsonb value
input search_data_append_input {
  metadata: jsonb
}

# input type for inserting array relation for remote table "search_data"
input search_data_arr_rel_insert_input {
  data: [search_data_insert_input!]!
  on_conflict: search_data_on_conflict
}

# aggregate avg on columns
type search_data_avg_fields {
  id: Float
}

# order by avg() on columns of table "search_data"
input search_data_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "search_data". All fields are combined with a logical 'AND'.
input search_data_bool_exp {
  _and: [search_data_bool_exp]
  _not: search_data_bool_exp
  _or: [search_data_bool_exp]
  class: enum_mapped_class_enum_comparison_exp
  id: bigint_comparison_exp
  metadata: jsonb_comparison_exp
  search_vector: tsvector_comparison_exp
  text: String_comparison_exp
}

# unique or primary key constraints on table "search_data"
enum search_data_constraint {
  # unique or primary key constraint
  search_pkey
}

# delete the field or element with specified path (for JSON arrays, negative integers count from the end)
input search_data_delete_at_path_input {
  metadata: [String]
}

# delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
input search_data_delete_elem_input {
  metadata: Int
}

# delete key/value pair or string element. key/value pairs are matched based on their key value
input search_data_delete_key_input {
  metadata: String
}

# input type for incrementing integer column in table "search_data"
input search_data_inc_input {
  id: bigint
}

# input type for inserting data into table "search_data"
input search_data_insert_input {
  class: enum_mapped_class_enum
  id: bigint
  metadata: jsonb
  search_vector: tsvector
  text: String
}

# aggregate max on columns
type search_data_max_fields {
  id: bigint
  text: String
}

# order by max() on columns of table "search_data"
input search_data_max_order_by {
  id: order_by
  text: order_by
}

# aggregate min on columns
type search_data_min_fields {
  id: bigint
  text: String
}

# order by min() on columns of table "search_data"
input search_data_min_order_by {
  id: order_by
  text: order_by
}

# response of any mutation on the table "search_data"
type search_data_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [search_data!]!
}

# input type for inserting object relation for remote table "search_data"
input search_data_obj_rel_insert_input {
  data: search_data_insert_input!
  on_conflict: search_data_on_conflict
}

# on conflict condition type for table "search_data"
input search_data_on_conflict {
  constraint: search_data_constraint!
  update_columns: [search_data_update_column!]!
  where: search_data_bool_exp
}

# ordering options when selecting data from "search_data"
input search_data_order_by {
  class: order_by
  id: order_by
  metadata: order_by
  search_vector: order_by
  text: order_by
}

# primary key columns input for table: "search_data"
input search_data_pk_columns_input {
  id: bigint!
}

# prepend existing jsonb value of filtered columns with new jsonb value
input search_data_prepend_input {
  metadata: jsonb
}

# select columns of table "search_data"
enum search_data_select_column {
  # column name
  class

  # column name
  id

  # column name
  metadata

  # column name
  search_vector

  # column name
  text
}

# input type for updating data in table "search_data"
input search_data_set_input {
  class: enum_mapped_class_enum
  id: bigint
  metadata: jsonb
  search_vector: tsvector
  text: String
}

# aggregate stddev on columns
type search_data_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "search_data"
input search_data_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type search_data_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "search_data"
input search_data_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type search_data_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "search_data"
input search_data_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type search_data_sum_fields {
  id: bigint
}

# order by sum() on columns of table "search_data"
input search_data_sum_order_by {
  id: order_by
}

# update columns of table "search_data"
enum search_data_update_column {
  # column name
  class

  # column name
  id

  # column name
  metadata

  # column name
  search_vector

  # column name
  text
}

# aggregate var_pop on columns
type search_data_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "search_data"
input search_data_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type search_data_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "search_data"
input search_data_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type search_data_variance_fields {
  id: Float
}

# order by variance() on columns of table "search_data"
input search_data_variance_order_by {
  id: order_by
}

input search_item_args {
  query_text: String
  return_limit: Int
}

input search_item_variant_args {
  query_text: String
  return_limit: Int
}

# shipment or invoices, multiple allowed per order
#
#
# columns and relationships of "shipment"
type shipment {
  id: Int!

  # An object relationship
  order: order
  order_id: Int
  received_date: date!
  shipped_date: date
  shipping_carrier: String!
  tracking_id: String
  vendor_invoice_id: String
}

# aggregated selection of "shipment"
type shipment_aggregate {
  aggregate: shipment_aggregate_fields
  nodes: [shipment!]!
}

# aggregate fields of "shipment"
type shipment_aggregate_fields {
  avg: shipment_avg_fields
  count(columns: [shipment_select_column!], distinct: Boolean): Int
  max: shipment_max_fields
  min: shipment_min_fields
  stddev: shipment_stddev_fields
  stddev_pop: shipment_stddev_pop_fields
  stddev_samp: shipment_stddev_samp_fields
  sum: shipment_sum_fields
  var_pop: shipment_var_pop_fields
  var_samp: shipment_var_samp_fields
  variance: shipment_variance_fields
}

# order by aggregate values of table "shipment"
input shipment_aggregate_order_by {
  avg: shipment_avg_order_by
  count: order_by
  max: shipment_max_order_by
  min: shipment_min_order_by
  stddev: shipment_stddev_order_by
  stddev_pop: shipment_stddev_pop_order_by
  stddev_samp: shipment_stddev_samp_order_by
  sum: shipment_sum_order_by
  var_pop: shipment_var_pop_order_by
  var_samp: shipment_var_samp_order_by
  variance: shipment_variance_order_by
}

# input type for inserting array relation for remote table "shipment"
input shipment_arr_rel_insert_input {
  data: [shipment_insert_input!]!
  on_conflict: shipment_on_conflict
}

# aggregate avg on columns
type shipment_avg_fields {
  id: Float
  order_id: Float
}

# order by avg() on columns of table "shipment"
input shipment_avg_order_by {
  id: order_by
  order_id: order_by
}

# Boolean expression to filter rows from the table "shipment". All fields are combined with a logical 'AND'.
input shipment_bool_exp {
  _and: [shipment_bool_exp]
  _not: shipment_bool_exp
  _or: [shipment_bool_exp]
  id: Int_comparison_exp
  order: order_bool_exp
  order_id: Int_comparison_exp
  received_date: date_comparison_exp
  shipped_date: date_comparison_exp
  shipping_carrier: String_comparison_exp
  tracking_id: String_comparison_exp
  vendor_invoice_id: String_comparison_exp
}

# unique or primary key constraints on table "shipment"
enum shipment_constraint {
  # unique or primary key constraint
  shipment_pkey
}

# input type for incrementing integer column in table "shipment"
input shipment_inc_input {
  id: Int
  order_id: Int
}

# input type for inserting data into table "shipment"
input shipment_insert_input {
  id: Int
  order: order_obj_rel_insert_input
  order_id: Int
  received_date: date
  shipped_date: date
  shipping_carrier: String
  tracking_id: String
  vendor_invoice_id: String
}

# aggregate max on columns
type shipment_max_fields {
  id: Int
  order_id: Int
  received_date: date
  shipped_date: date
  shipping_carrier: String
  tracking_id: String
  vendor_invoice_id: String
}

# order by max() on columns of table "shipment"
input shipment_max_order_by {
  id: order_by
  order_id: order_by
  received_date: order_by
  shipped_date: order_by
  shipping_carrier: order_by
  tracking_id: order_by
  vendor_invoice_id: order_by
}

# aggregate min on columns
type shipment_min_fields {
  id: Int
  order_id: Int
  received_date: date
  shipped_date: date
  shipping_carrier: String
  tracking_id: String
  vendor_invoice_id: String
}

# order by min() on columns of table "shipment"
input shipment_min_order_by {
  id: order_by
  order_id: order_by
  received_date: order_by
  shipped_date: order_by
  shipping_carrier: order_by
  tracking_id: order_by
  vendor_invoice_id: order_by
}

# response of any mutation on the table "shipment"
type shipment_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [shipment!]!
}

# input type for inserting object relation for remote table "shipment"
input shipment_obj_rel_insert_input {
  data: shipment_insert_input!
  on_conflict: shipment_on_conflict
}

# on conflict condition type for table "shipment"
input shipment_on_conflict {
  constraint: shipment_constraint!
  update_columns: [shipment_update_column!]!
  where: shipment_bool_exp
}

# ordering options when selecting data from "shipment"
input shipment_order_by {
  id: order_by
  order: order_order_by
  order_id: order_by
  received_date: order_by
  shipped_date: order_by
  shipping_carrier: order_by
  tracking_id: order_by
  vendor_invoice_id: order_by
}

# primary key columns input for table: "shipment"
input shipment_pk_columns_input {
  id: Int!
}

# select columns of table "shipment"
enum shipment_select_column {
  # column name
  id

  # column name
  order_id

  # column name
  received_date

  # column name
  shipped_date

  # column name
  shipping_carrier

  # column name
  tracking_id

  # column name
  vendor_invoice_id
}

# input type for updating data in table "shipment"
input shipment_set_input {
  id: Int
  order_id: Int
  received_date: date
  shipped_date: date
  shipping_carrier: String
  tracking_id: String
  vendor_invoice_id: String
}

# aggregate stddev on columns
type shipment_stddev_fields {
  id: Float
  order_id: Float
}

# order by stddev() on columns of table "shipment"
input shipment_stddev_order_by {
  id: order_by
  order_id: order_by
}

# aggregate stddev_pop on columns
type shipment_stddev_pop_fields {
  id: Float
  order_id: Float
}

# order by stddev_pop() on columns of table "shipment"
input shipment_stddev_pop_order_by {
  id: order_by
  order_id: order_by
}

# aggregate stddev_samp on columns
type shipment_stddev_samp_fields {
  id: Float
  order_id: Float
}

# order by stddev_samp() on columns of table "shipment"
input shipment_stddev_samp_order_by {
  id: order_by
  order_id: order_by
}

# aggregate sum on columns
type shipment_sum_fields {
  id: Int
  order_id: Int
}

# order by sum() on columns of table "shipment"
input shipment_sum_order_by {
  id: order_by
  order_id: order_by
}

# update columns of table "shipment"
enum shipment_update_column {
  # column name
  id

  # column name
  order_id

  # column name
  received_date

  # column name
  shipped_date

  # column name
  shipping_carrier

  # column name
  tracking_id

  # column name
  vendor_invoice_id
}

# aggregate var_pop on columns
type shipment_var_pop_fields {
  id: Float
  order_id: Float
}

# order by var_pop() on columns of table "shipment"
input shipment_var_pop_order_by {
  id: order_by
  order_id: order_by
}

# aggregate var_samp on columns
type shipment_var_samp_fields {
  id: Float
  order_id: Float
}

# order by var_samp() on columns of table "shipment"
input shipment_var_samp_order_by {
  id: order_by
  order_id: order_by
}

# aggregate variance on columns
type shipment_variance_fields {
  id: Float
  order_id: Float
}

# order by variance() on columns of table "shipment"
input shipment_variance_order_by {
  id: order_by
  order_id: order_by
}

scalar smallint

# expression to compare columns of type smallint. All fields are combined with logical 'AND'.
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# track acquisition and consumption of inventory items
#
#
# columns and relationships of "stock"
type stock {
  date: timestamptz!
  event_type: enum_stock_event_type_enum!
  id: Int!
  item_id: Int!
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int!
  tag_id: Int
  vendor_item_id: Int
}

# aggregated selection of "stock"
type stock_aggregate {
  aggregate: stock_aggregate_fields
  nodes: [stock!]!
}

# aggregate fields of "stock"
type stock_aggregate_fields {
  avg: stock_avg_fields
  count(columns: [stock_select_column!], distinct: Boolean): Int
  max: stock_max_fields
  min: stock_min_fields
  stddev: stock_stddev_fields
  stddev_pop: stock_stddev_pop_fields
  stddev_samp: stock_stddev_samp_fields
  sum: stock_sum_fields
  var_pop: stock_var_pop_fields
  var_samp: stock_var_samp_fields
  variance: stock_variance_fields
}

# order by aggregate values of table "stock"
input stock_aggregate_order_by {
  avg: stock_avg_order_by
  count: order_by
  max: stock_max_order_by
  min: stock_min_order_by
  stddev: stock_stddev_order_by
  stddev_pop: stock_stddev_pop_order_by
  stddev_samp: stock_stddev_samp_order_by
  sum: stock_sum_order_by
  var_pop: stock_var_pop_order_by
  var_samp: stock_var_samp_order_by
  variance: stock_variance_order_by
}

# input type for inserting array relation for remote table "stock"
input stock_arr_rel_insert_input {
  data: [stock_insert_input!]!
  on_conflict: stock_on_conflict
}

# aggregate avg on columns
type stock_avg_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by avg() on columns of table "stock"
input stock_avg_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# Boolean expression to filter rows from the table "stock". All fields are combined with a logical 'AND'.
input stock_bool_exp {
  _and: [stock_bool_exp]
  _not: stock_bool_exp
  _or: [stock_bool_exp]
  date: timestamptz_comparison_exp
  event_type: enum_stock_event_type_enum_comparison_exp
  id: Int_comparison_exp
  item_id: Int_comparison_exp
  manufacturer_item_id: Int_comparison_exp
  order_item_id: Int_comparison_exp
  quantity: Int_comparison_exp
  tag_id: Int_comparison_exp
  vendor_item_id: Int_comparison_exp
}

# unique or primary key constraints on table "stock"
enum stock_constraint {
  # unique or primary key constraint
  stock_pkey
}

# input type for incrementing integer column in table "stock"
input stock_inc_input {
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int
  tag_id: Int
  vendor_item_id: Int
}

# input type for inserting data into table "stock"
input stock_insert_input {
  date: timestamptz
  event_type: enum_stock_event_type_enum
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int
  tag_id: Int
  vendor_item_id: Int
}

# aggregate max on columns
type stock_max_fields {
  date: timestamptz
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int
  tag_id: Int
  vendor_item_id: Int
}

# order by max() on columns of table "stock"
input stock_max_order_by {
  date: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# aggregate min on columns
type stock_min_fields {
  date: timestamptz
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int
  tag_id: Int
  vendor_item_id: Int
}

# order by min() on columns of table "stock"
input stock_min_order_by {
  date: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# response of any mutation on the table "stock"
type stock_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [stock!]!
}

# input type for inserting object relation for remote table "stock"
input stock_obj_rel_insert_input {
  data: stock_insert_input!
  on_conflict: stock_on_conflict
}

# on conflict condition type for table "stock"
input stock_on_conflict {
  constraint: stock_constraint!
  update_columns: [stock_update_column!]!
  where: stock_bool_exp
}

# ordering options when selecting data from "stock"
input stock_order_by {
  date: order_by
  event_type: order_by
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# primary key columns input for table: "stock"
input stock_pk_columns_input {
  id: Int!
}

# select columns of table "stock"
enum stock_select_column {
  # column name
  date

  # column name
  event_type

  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_item_id

  # column name
  order_item_id

  # column name
  quantity

  # column name
  tag_id

  # column name
  vendor_item_id
}

# input type for updating data in table "stock"
input stock_set_input {
  date: timestamptz
  event_type: enum_stock_event_type_enum
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int
  tag_id: Int
  vendor_item_id: Int
}

# aggregate stddev on columns
type stock_stddev_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by stddev() on columns of table "stock"
input stock_stddev_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# aggregate stddev_pop on columns
type stock_stddev_pop_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by stddev_pop() on columns of table "stock"
input stock_stddev_pop_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# aggregate stddev_samp on columns
type stock_stddev_samp_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by stddev_samp() on columns of table "stock"
input stock_stddev_samp_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# aggregate sum on columns
type stock_sum_fields {
  id: Int
  item_id: Int
  manufacturer_item_id: Int
  order_item_id: Int
  quantity: Int
  tag_id: Int
  vendor_item_id: Int
}

# order by sum() on columns of table "stock"
input stock_sum_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# update columns of table "stock"
enum stock_update_column {
  # column name
  date

  # column name
  event_type

  # column name
  id

  # column name
  item_id

  # column name
  manufacturer_item_id

  # column name
  order_item_id

  # column name
  quantity

  # column name
  tag_id

  # column name
  vendor_item_id
}

# aggregate var_pop on columns
type stock_var_pop_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by var_pop() on columns of table "stock"
input stock_var_pop_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# aggregate var_samp on columns
type stock_var_samp_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by var_samp() on columns of table "stock"
input stock_var_samp_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# aggregate variance on columns
type stock_variance_fields {
  id: Float
  item_id: Float
  manufacturer_item_id: Float
  order_item_id: Float
  quantity: Float
  tag_id: Float
  vendor_item_id: Float
}

# order by variance() on columns of table "stock"
input stock_variance_order_by {
  id: order_by
  item_id: order_by
  manufacturer_item_id: order_by
  order_item_id: order_by
  quantity: order_by
  tag_id: order_by
  vendor_item_id: order_by
}

# columns and relationships of "storage"
type storage {
  abbreviation: String!
  description: String
  id: Int!
  name: String!
  parent_id: Int
  space_type: enum_space_type_enum!
}

# aggregated selection of "storage"
type storage_aggregate {
  aggregate: storage_aggregate_fields
  nodes: [storage!]!
}

# aggregate fields of "storage"
type storage_aggregate_fields {
  avg: storage_avg_fields
  count(columns: [storage_select_column!], distinct: Boolean): Int
  max: storage_max_fields
  min: storage_min_fields
  stddev: storage_stddev_fields
  stddev_pop: storage_stddev_pop_fields
  stddev_samp: storage_stddev_samp_fields
  sum: storage_sum_fields
  var_pop: storage_var_pop_fields
  var_samp: storage_var_samp_fields
  variance: storage_variance_fields
}

# order by aggregate values of table "storage"
input storage_aggregate_order_by {
  avg: storage_avg_order_by
  count: order_by
  max: storage_max_order_by
  min: storage_min_order_by
  stddev: storage_stddev_order_by
  stddev_pop: storage_stddev_pop_order_by
  stddev_samp: storage_stddev_samp_order_by
  sum: storage_sum_order_by
  var_pop: storage_var_pop_order_by
  var_samp: storage_var_samp_order_by
  variance: storage_variance_order_by
}

# input type for inserting array relation for remote table "storage"
input storage_arr_rel_insert_input {
  data: [storage_insert_input!]!
  on_conflict: storage_on_conflict
}

# aggregate avg on columns
type storage_avg_fields {
  id: Float
  parent_id: Float
}

# order by avg() on columns of table "storage"
input storage_avg_order_by {
  id: order_by
  parent_id: order_by
}

# Boolean expression to filter rows from the table "storage". All fields are combined with a logical 'AND'.
input storage_bool_exp {
  _and: [storage_bool_exp]
  _not: storage_bool_exp
  _or: [storage_bool_exp]
  abbreviation: String_comparison_exp
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  parent_id: Int_comparison_exp
  space_type: enum_space_type_enum_comparison_exp
}

# unique or primary key constraints on table "storage"
enum storage_constraint {
  # unique or primary key constraint
  storage_parent_name_key

  # unique or primary key constraint
  storage_pkey
}

# input type for incrementing integer column in table "storage"
input storage_inc_input {
  id: Int
  parent_id: Int
}

# input type for inserting data into table "storage"
input storage_insert_input {
  abbreviation: String
  description: String
  id: Int
  name: String
  parent_id: Int
  space_type: enum_space_type_enum
}

# aggregate max on columns
type storage_max_fields {
  abbreviation: String
  description: String
  id: Int
  name: String
  parent_id: Int
}

# order by max() on columns of table "storage"
input storage_max_order_by {
  abbreviation: order_by
  description: order_by
  id: order_by
  name: order_by
  parent_id: order_by
}

# aggregate min on columns
type storage_min_fields {
  abbreviation: String
  description: String
  id: Int
  name: String
  parent_id: Int
}

# order by min() on columns of table "storage"
input storage_min_order_by {
  abbreviation: order_by
  description: order_by
  id: order_by
  name: order_by
  parent_id: order_by
}

# response of any mutation on the table "storage"
type storage_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [storage!]!
}

# input type for inserting object relation for remote table "storage"
input storage_obj_rel_insert_input {
  data: storage_insert_input!
  on_conflict: storage_on_conflict
}

# on conflict condition type for table "storage"
input storage_on_conflict {
  constraint: storage_constraint!
  update_columns: [storage_update_column!]!
  where: storage_bool_exp
}

# ordering options when selecting data from "storage"
input storage_order_by {
  abbreviation: order_by
  description: order_by
  id: order_by
  name: order_by
  parent_id: order_by
  space_type: order_by
}

# primary key columns input for table: "storage"
input storage_pk_columns_input {
  id: Int!
}

# select columns of table "storage"
enum storage_select_column {
  # column name
  abbreviation

  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  parent_id

  # column name
  space_type
}

# input type for updating data in table "storage"
input storage_set_input {
  abbreviation: String
  description: String
  id: Int
  name: String
  parent_id: Int
  space_type: enum_space_type_enum
}

# aggregate stddev on columns
type storage_stddev_fields {
  id: Float
  parent_id: Float
}

# order by stddev() on columns of table "storage"
input storage_stddev_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate stddev_pop on columns
type storage_stddev_pop_fields {
  id: Float
  parent_id: Float
}

# order by stddev_pop() on columns of table "storage"
input storage_stddev_pop_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate stddev_samp on columns
type storage_stddev_samp_fields {
  id: Float
  parent_id: Float
}

# order by stddev_samp() on columns of table "storage"
input storage_stddev_samp_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate sum on columns
type storage_sum_fields {
  id: Int
  parent_id: Int
}

# order by sum() on columns of table "storage"
input storage_sum_order_by {
  id: order_by
  parent_id: order_by
}

# update columns of table "storage"
enum storage_update_column {
  # column name
  abbreviation

  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  parent_id

  # column name
  space_type
}

# aggregate var_pop on columns
type storage_var_pop_fields {
  id: Float
  parent_id: Float
}

# order by var_pop() on columns of table "storage"
input storage_var_pop_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate var_samp on columns
type storage_var_samp_fields {
  id: Float
  parent_id: Float
}

# order by var_samp() on columns of table "storage"
input storage_var_samp_order_by {
  id: order_by
  parent_id: order_by
}

# aggregate variance on columns
type storage_variance_fields {
  id: Float
  parent_id: Float
}

# order by variance() on columns of table "storage"
input storage_variance_order_by {
  id: order_by
  parent_id: order_by
}

# subscription root
type subscription_root {
  # fetch data from the table: "enum_item_cable.connector"
  enum_item_cable_connector(
    # distinct select on columns
    distinct_on: [enum_item_cable_connector_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_cable_connector_order_by!]

    # filter the rows returned
    where: enum_item_cable_connector_bool_exp
  ): [enum_item_cable_connector!]!

  # fetch aggregated fields from the table: "enum_item_cable.connector"
  enum_item_cable_connector_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_cable_connector_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_cable_connector_order_by!]

    # filter the rows returned
    where: enum_item_cable_connector_bool_exp
  ): enum_item_cable_connector_aggregate!

  # fetch data from the table: "enum_item_cable.connector" using primary key columns
  enum_item_cable_connector_by_pk(id: String!): enum_item_cable_connector

  # fetch data from the table: "enum.item_class"
  enum_item_class(
    # distinct select on columns
    distinct_on: [enum_item_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_class_order_by!]

    # filter the rows returned
    where: enum_item_class_bool_exp
  ): [enum_item_class!]!

  # fetch aggregated fields from the table: "enum.item_class"
  enum_item_class_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_class_order_by!]

    # filter the rows returned
    where: enum_item_class_bool_exp
  ): enum_item_class_aggregate!

  # fetch data from the table: "enum.item_class" using primary key columns
  enum_item_class_by_pk(id: String!): enum_item_class

  # fetch data from the table: "enum_item.handedness"
  enum_item_handedness(
    # distinct select on columns
    distinct_on: [enum_item_handedness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_handedness_order_by!]

    # filter the rows returned
    where: enum_item_handedness_bool_exp
  ): [enum_item_handedness!]!

  # fetch aggregated fields from the table: "enum_item.handedness"
  enum_item_handedness_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_handedness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_handedness_order_by!]

    # filter the rows returned
    where: enum_item_handedness_bool_exp
  ): enum_item_handedness_aggregate!

  # fetch data from the table: "enum_item.handedness" using primary key columns
  enum_item_handedness_by_pk(id: String!): enum_item_handedness

  # fetch data from the table: "enum_item_hardware_fastener.drive"
  enum_item_hardware_fastener_drive(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_drive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_drive_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_drive_bool_exp
  ): [enum_item_hardware_fastener_drive!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.drive"
  enum_item_hardware_fastener_drive_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_drive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_drive_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_drive_bool_exp
  ): enum_item_hardware_fastener_drive_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.drive" using primary key columns
  enum_item_hardware_fastener_drive_by_pk(id: String!): enum_item_hardware_fastener_drive

  # fetch data from the table: "enum_item_hardware_fastener.material"
  enum_item_hardware_fastener_material(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_material_bool_exp
  ): [enum_item_hardware_fastener_material!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.material"
  enum_item_hardware_fastener_material_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_material_bool_exp
  ): enum_item_hardware_fastener_material_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.material" using primary key columns
  enum_item_hardware_fastener_material_by_pk(id: String!): enum_item_hardware_fastener_material

  # fetch data from the table: "enum_item_hardware_fastener_nut.form"
  enum_item_hardware_fastener_nut_form(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_form_bool_exp
  ): [enum_item_hardware_fastener_nut_form!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_nut.form"
  enum_item_hardware_fastener_nut_form_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_form_bool_exp
  ): enum_item_hardware_fastener_nut_form_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_nut.form" using primary key columns
  enum_item_hardware_fastener_nut_form_by_pk(id: String!): enum_item_hardware_fastener_nut_form

  # fetch data from the table: "enum_item_hardware_fastener_nut.strength"
  enum_item_hardware_fastener_nut_strength(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_strength_bool_exp
  ): [enum_item_hardware_fastener_nut_strength!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_nut.strength"
  enum_item_hardware_fastener_nut_strength_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_strength_bool_exp
  ): enum_item_hardware_fastener_nut_strength_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_nut.strength" using primary key columns
  enum_item_hardware_fastener_nut_strength_by_pk(id: String!): enum_item_hardware_fastener_nut_strength

  # fetch data from the table: "enum_item_hardware_fastener_nut.thread_fit"
  enum_item_hardware_fastener_nut_thread_fit(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_thread_fit_bool_exp
  ): [enum_item_hardware_fastener_nut_thread_fit!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_nut.thread_fit"
  enum_item_hardware_fastener_nut_thread_fit_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_nut_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_nut_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_nut_thread_fit_bool_exp
  ): enum_item_hardware_fastener_nut_thread_fit_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_nut.thread_fit" using primary key columns
  enum_item_hardware_fastener_nut_thread_fit_by_pk(id: String!): enum_item_hardware_fastener_nut_thread_fit

  # fetch data from the table: "enum_item_hardware_fastener_screw.hardness"
  enum_item_hardware_fastener_screw_hardness(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_hardness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_hardness_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_hardness_bool_exp
  ): [enum_item_hardware_fastener_screw_hardness!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw.hardness"
  enum_item_hardware_fastener_screw_hardness_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_hardness_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_hardness_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_hardness_bool_exp
  ): enum_item_hardware_fastener_screw_hardness_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw.hardness" using primary key columns
  enum_item_hardware_fastener_screw_hardness_by_pk(id: String!): enum_item_hardware_fastener_screw_hardness

  # fetch data from the table: "enum_item_hardware_fastener_screw.head"
  enum_item_hardware_fastener_screw_head(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_head_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_head_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_head_bool_exp
  ): [enum_item_hardware_fastener_screw_head!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw.head"
  enum_item_hardware_fastener_screw_head_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_head_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_head_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_head_bool_exp
  ): enum_item_hardware_fastener_screw_head_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw.head" using primary key columns
  enum_item_hardware_fastener_screw_head_by_pk(id: String!): enum_item_hardware_fastener_screw_head

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.point"
  enum_item_hardware_fastener_screw_machine_point(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_point_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_point_bool_exp
  ): [enum_item_hardware_fastener_screw_machine_point!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw_machine.point"
  enum_item_hardware_fastener_screw_machine_point_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_point_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_point_bool_exp
  ): enum_item_hardware_fastener_screw_machine_point_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.point" using primary key columns
  enum_item_hardware_fastener_screw_machine_point_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_point

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.strength"
  enum_item_hardware_fastener_screw_machine_strength(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_strength_bool_exp
  ): [enum_item_hardware_fastener_screw_machine_strength!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw_machine.strength"
  enum_item_hardware_fastener_screw_machine_strength_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_strength_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_strength_bool_exp
  ): enum_item_hardware_fastener_screw_machine_strength_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.strength" using primary key columns
  enum_item_hardware_fastener_screw_machine_strength_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_strength

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  enum_item_hardware_fastener_screw_machine_thread_fit(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp
  ): [enum_item_hardware_fastener_screw_machine_thread_fit!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_screw_machine.thread_fit"
  enum_item_hardware_fastener_screw_machine_thread_fit_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_screw_machine_thread_fit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_screw_machine_thread_fit_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_screw_machine_thread_fit_bool_exp
  ): enum_item_hardware_fastener_screw_machine_thread_fit_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_screw_machine.thread_fit" using primary key columns
  enum_item_hardware_fastener_screw_machine_thread_fit_by_pk(id: String!): enum_item_hardware_fastener_screw_machine_thread_fit

  # fetch data from the table: "enum_item_hardware_fastener.standoff_shape"
  enum_item_hardware_fastener_standoff_shape(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_standoff_shape_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_standoff_shape_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_standoff_shape_bool_exp
  ): [enum_item_hardware_fastener_standoff_shape!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.standoff_shape"
  enum_item_hardware_fastener_standoff_shape_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_standoff_shape_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_standoff_shape_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_standoff_shape_bool_exp
  ): enum_item_hardware_fastener_standoff_shape_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.standoff_shape" using primary key columns
  enum_item_hardware_fastener_standoff_shape_by_pk(id: String!): enum_item_hardware_fastener_standoff_shape

  # fetch data from the table: "enum_item_hardware_fastener.thread_label"
  enum_item_hardware_fastener_thread_label(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_label_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_label_bool_exp
  ): [enum_item_hardware_fastener_thread_label!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.thread_label"
  enum_item_hardware_fastener_thread_label_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_label_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_label_bool_exp
  ): enum_item_hardware_fastener_thread_label_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.thread_label" using primary key columns
  enum_item_hardware_fastener_thread_label_by_pk(id: String!): enum_item_hardware_fastener_thread_label

  # fetch data from the table: "enum_item_hardware_fastener.thread_standard"
  enum_item_hardware_fastener_thread_standard(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_standard_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_standard_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_standard_bool_exp
  ): [enum_item_hardware_fastener_thread_standard!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener.thread_standard"
  enum_item_hardware_fastener_thread_standard_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_thread_standard_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_thread_standard_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_thread_standard_bool_exp
  ): enum_item_hardware_fastener_thread_standard_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener.thread_standard" using primary key columns
  enum_item_hardware_fastener_thread_standard_by_pk(id: String!): enum_item_hardware_fastener_thread_standard

  # fetch data from the table: "enum_item_hardware_fastener_washer.form"
  enum_item_hardware_fastener_washer_form(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_form_bool_exp
  ): [enum_item_hardware_fastener_washer_form!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_washer.form"
  enum_item_hardware_fastener_washer_form_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_form_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_form_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_form_bool_exp
  ): enum_item_hardware_fastener_washer_form_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_washer.form" using primary key columns
  enum_item_hardware_fastener_washer_form_by_pk(id: String!): enum_item_hardware_fastener_washer_form

  # fetch data from the table: "enum_item_hardware_fastener_washer.mechanism"
  enum_item_hardware_fastener_washer_mechanism(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_mechanism_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_mechanism_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_mechanism_bool_exp
  ): [enum_item_hardware_fastener_washer_mechanism!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_washer.mechanism"
  enum_item_hardware_fastener_washer_mechanism_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_mechanism_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_mechanism_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_mechanism_bool_exp
  ): enum_item_hardware_fastener_washer_mechanism_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_washer.mechanism" using primary key columns
  enum_item_hardware_fastener_washer_mechanism_by_pk(id: String!): enum_item_hardware_fastener_washer_mechanism

  # fetch data from the table: "enum_item_hardware_fastener_washer.pattern"
  enum_item_hardware_fastener_washer_pattern(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_pattern_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_pattern_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_pattern_bool_exp
  ): [enum_item_hardware_fastener_washer_pattern!]!

  # fetch aggregated fields from the table: "enum_item_hardware_fastener_washer.pattern"
  enum_item_hardware_fastener_washer_pattern_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_fastener_washer_pattern_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_fastener_washer_pattern_order_by!]

    # filter the rows returned
    where: enum_item_hardware_fastener_washer_pattern_bool_exp
  ): enum_item_hardware_fastener_washer_pattern_aggregate!

  # fetch data from the table: "enum_item_hardware_fastener_washer.pattern" using primary key columns
  enum_item_hardware_fastener_washer_pattern_by_pk(id: String!): enum_item_hardware_fastener_washer_pattern

  # fetch data from the table: "enum_item_hardware.finish"
  enum_item_hardware_finish(
    # distinct select on columns
    distinct_on: [enum_item_hardware_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_finish_order_by!]

    # filter the rows returned
    where: enum_item_hardware_finish_bool_exp
  ): [enum_item_hardware_finish!]!

  # fetch aggregated fields from the table: "enum_item_hardware.finish"
  enum_item_hardware_finish_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_finish_order_by!]

    # filter the rows returned
    where: enum_item_hardware_finish_bool_exp
  ): enum_item_hardware_finish_aggregate!

  # fetch data from the table: "enum_item_hardware.finish" using primary key columns
  enum_item_hardware_finish_by_pk(id: String!): enum_item_hardware_finish

  # fetch data from the table: "enum_item_hardware.use_material"
  enum_item_hardware_use_material(
    # distinct select on columns
    distinct_on: [enum_item_hardware_use_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_use_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_use_material_bool_exp
  ): [enum_item_hardware_use_material!]!

  # fetch aggregated fields from the table: "enum_item_hardware.use_material"
  enum_item_hardware_use_material_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_hardware_use_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_hardware_use_material_order_by!]

    # filter the rows returned
    where: enum_item_hardware_use_material_bool_exp
  ): enum_item_hardware_use_material_aggregate!

  # fetch data from the table: "enum_item_hardware.use_material" using primary key columns
  enum_item_hardware_use_material_by_pk(id: String!): enum_item_hardware_use_material

  # fetch data from the table: "enum_item_tool.drill_bit_finish"
  enum_item_tool_drill_bit_finish(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_finish_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_finish_bool_exp
  ): [enum_item_tool_drill_bit_finish!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_finish"
  enum_item_tool_drill_bit_finish_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_finish_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_finish_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_finish_bool_exp
  ): enum_item_tool_drill_bit_finish_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_finish" using primary key columns
  enum_item_tool_drill_bit_finish_by_pk(id: String!): enum_item_tool_drill_bit_finish

  # fetch data from the table: "enum_item_tool.drill_bit_length_class"
  enum_item_tool_drill_bit_length_class(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_length_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_length_class_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_length_class_bool_exp
  ): [enum_item_tool_drill_bit_length_class!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_length_class"
  enum_item_tool_drill_bit_length_class_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_length_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_length_class_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_length_class_bool_exp
  ): enum_item_tool_drill_bit_length_class_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_length_class" using primary key columns
  enum_item_tool_drill_bit_length_class_by_pk(id: String!): enum_item_tool_drill_bit_length_class

  # fetch data from the table: "enum_item_tool.drill_bit_material"
  enum_item_tool_drill_bit_material(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_material_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_material_bool_exp
  ): [enum_item_tool_drill_bit_material!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_material"
  enum_item_tool_drill_bit_material_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_material_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_material_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_material_bool_exp
  ): enum_item_tool_drill_bit_material_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_material" using primary key columns
  enum_item_tool_drill_bit_material_by_pk(id: String!): enum_item_tool_drill_bit_material

  # fetch data from the table: "enum_item_tool.drill_bit_point"
  enum_item_tool_drill_bit_point(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_point_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_point_bool_exp
  ): [enum_item_tool_drill_bit_point!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_point"
  enum_item_tool_drill_bit_point_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_point_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_point_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_point_bool_exp
  ): enum_item_tool_drill_bit_point_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_point" using primary key columns
  enum_item_tool_drill_bit_point_by_pk(id: String!): enum_item_tool_drill_bit_point

  # fetch data from the table: "enum_item_tool.drill_bit_shank"
  enum_item_tool_drill_bit_shank(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_shank_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_shank_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_shank_bool_exp
  ): [enum_item_tool_drill_bit_shank!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_shank"
  enum_item_tool_drill_bit_shank_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_shank_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_shank_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_shank_bool_exp
  ): enum_item_tool_drill_bit_shank_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_shank" using primary key columns
  enum_item_tool_drill_bit_shank_by_pk(id: String!): enum_item_tool_drill_bit_shank

  # fetch data from the table: "enum_item_tool.drill_bit_style"
  enum_item_tool_drill_bit_style(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_style_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_style_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_style_bool_exp
  ): [enum_item_tool_drill_bit_style!]!

  # fetch aggregated fields from the table: "enum_item_tool.drill_bit_style"
  enum_item_tool_drill_bit_style_aggregate(
    # distinct select on columns
    distinct_on: [enum_item_tool_drill_bit_style_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_item_tool_drill_bit_style_order_by!]

    # filter the rows returned
    where: enum_item_tool_drill_bit_style_bool_exp
  ): enum_item_tool_drill_bit_style_aggregate!

  # fetch data from the table: "enum_item_tool.drill_bit_style" using primary key columns
  enum_item_tool_drill_bit_style_by_pk(id: String!): enum_item_tool_drill_bit_style

  # fetch data from the table: "enum.mapped_class"
  enum_mapped_class(
    # distinct select on columns
    distinct_on: [enum_mapped_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_mapped_class_order_by!]

    # filter the rows returned
    where: enum_mapped_class_bool_exp
  ): [enum_mapped_class!]!

  # fetch aggregated fields from the table: "enum.mapped_class"
  enum_mapped_class_aggregate(
    # distinct select on columns
    distinct_on: [enum_mapped_class_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_mapped_class_order_by!]

    # filter the rows returned
    where: enum_mapped_class_bool_exp
  ): enum_mapped_class_aggregate!

  # fetch data from the table: "enum.mapped_class" using primary key columns
  enum_mapped_class_by_pk(id: String!): enum_mapped_class

  # fetch data from the table: "enum.payment_method_type"
  enum_payment_method_type(
    # distinct select on columns
    distinct_on: [enum_payment_method_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_payment_method_type_order_by!]

    # filter the rows returned
    where: enum_payment_method_type_bool_exp
  ): [enum_payment_method_type!]!

  # fetch aggregated fields from the table: "enum.payment_method_type"
  enum_payment_method_type_aggregate(
    # distinct select on columns
    distinct_on: [enum_payment_method_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_payment_method_type_order_by!]

    # filter the rows returned
    where: enum_payment_method_type_bool_exp
  ): enum_payment_method_type_aggregate!

  # fetch data from the table: "enum.payment_method_type" using primary key columns
  enum_payment_method_type_by_pk(id: String!): enum_payment_method_type

  # fetch data from the table: "enum.space_type"
  enum_space_type(
    # distinct select on columns
    distinct_on: [enum_space_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_space_type_order_by!]

    # filter the rows returned
    where: enum_space_type_bool_exp
  ): [enum_space_type!]!

  # fetch aggregated fields from the table: "enum.space_type"
  enum_space_type_aggregate(
    # distinct select on columns
    distinct_on: [enum_space_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_space_type_order_by!]

    # filter the rows returned
    where: enum_space_type_bool_exp
  ): enum_space_type_aggregate!

  # fetch data from the table: "enum.space_type" using primary key columns
  enum_space_type_by_pk(id: String!): enum_space_type

  # fetch data from the table: "enum.stock_event_type"
  enum_stock_event_type(
    # distinct select on columns
    distinct_on: [enum_stock_event_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_stock_event_type_order_by!]

    # filter the rows returned
    where: enum_stock_event_type_bool_exp
  ): [enum_stock_event_type!]!

  # fetch aggregated fields from the table: "enum.stock_event_type"
  enum_stock_event_type_aggregate(
    # distinct select on columns
    distinct_on: [enum_stock_event_type_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_stock_event_type_order_by!]

    # filter the rows returned
    where: enum_stock_event_type_bool_exp
  ): enum_stock_event_type_aggregate!

  # fetch data from the table: "enum.stock_event_type" using primary key columns
  enum_stock_event_type_by_pk(id: String!): enum_stock_event_type

  # fetch data from the table: "enum.unit"
  enum_unit(
    # distinct select on columns
    distinct_on: [enum_unit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_unit_order_by!]

    # filter the rows returned
    where: enum_unit_bool_exp
  ): [enum_unit!]!

  # fetch aggregated fields from the table: "enum.unit"
  enum_unit_aggregate(
    # distinct select on columns
    distinct_on: [enum_unit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enum_unit_order_by!]

    # filter the rows returned
    where: enum_unit_bool_exp
  ): enum_unit_aggregate!

  # fetch data from the table: "enum.unit" using primary key columns
  enum_unit_by_pk(id: String!): enum_unit

  # fetch data from the table: "icon"
  icon(
    # distinct select on columns
    distinct_on: [icon_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_order_by!]

    # filter the rows returned
    where: icon_bool_exp
  ): [icon!]!

  # fetch aggregated fields from the table: "icon"
  icon_aggregate(
    # distinct select on columns
    distinct_on: [icon_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_order_by!]

    # filter the rows returned
    where: icon_bool_exp
  ): icon_aggregate!

  # fetch data from the table: "icon" using primary key columns
  icon_by_pk(id: uuid!): icon

  # fetch data from the table: "icon_item_category_map"
  icon_item_category_map(
    # distinct select on columns
    distinct_on: [icon_item_category_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_category_map_order_by!]

    # filter the rows returned
    where: icon_item_category_map_bool_exp
  ): [icon_item_category_map!]!

  # fetch aggregated fields from the table: "icon_item_category_map"
  icon_item_category_map_aggregate(
    # distinct select on columns
    distinct_on: [icon_item_category_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_category_map_order_by!]

    # filter the rows returned
    where: icon_item_category_map_bool_exp
  ): icon_item_category_map_aggregate!

  # fetch data from the table: "icon_item_category_map" using primary key columns
  icon_item_category_map_by_pk(category: enum_item_class_enum!, icon_id: uuid!, sequence: smallint!): icon_item_category_map

  # fetch data from the table: "icon_item_map"
  icon_item_map(
    # distinct select on columns
    distinct_on: [icon_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_map_order_by!]

    # filter the rows returned
    where: icon_item_map_bool_exp
  ): [icon_item_map!]!

  # fetch aggregated fields from the table: "icon_item_map"
  icon_item_map_aggregate(
    # distinct select on columns
    distinct_on: [icon_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_item_map_order_by!]

    # filter the rows returned
    where: icon_item_map_bool_exp
  ): icon_item_map_aggregate!

  # fetch data from the table: "icon_item_map" using primary key columns
  icon_item_map_by_pk(icon_id: uuid!, item_id: Int!): icon_item_map

  # fetch data from the table: "icon_label_map"
  icon_label_map(
    # distinct select on columns
    distinct_on: [icon_label_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_label_map_order_by!]

    # filter the rows returned
    where: icon_label_map_bool_exp
  ): [icon_label_map!]!

  # fetch aggregated fields from the table: "icon_label_map"
  icon_label_map_aggregate(
    # distinct select on columns
    distinct_on: [icon_label_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [icon_label_map_order_by!]

    # filter the rows returned
    where: icon_label_map_bool_exp
  ): icon_label_map_aggregate!

  # fetch data from the table: "icon_label_map" using primary key columns
  icon_label_map_by_pk(icon_id: uuid!, label_id: uuid!): icon_label_map

  # fetch data from the table: "item"
  item(
    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): [item!]!

  # fetch aggregated fields from the table: "item"
  item_aggregate(
    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): item_aggregate!

  # fetch data from the table: "item.bundle"
  item_bundle(
    # distinct select on columns
    distinct_on: [item_bundle_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_order_by!]

    # filter the rows returned
    where: item_bundle_bool_exp
  ): [item_bundle!]!

  # fetch aggregated fields from the table: "item.bundle"
  item_bundle_aggregate(
    # distinct select on columns
    distinct_on: [item_bundle_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_order_by!]

    # filter the rows returned
    where: item_bundle_bool_exp
  ): item_bundle_aggregate!

  # fetch data from the table: "item.bundle" using primary key columns
  item_bundle_by_pk(id: Int!): item_bundle

  # fetch data from the table: "item.bundle_map"
  item_bundle_map(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): [item_bundle_map!]!

  # fetch aggregated fields from the table: "item.bundle_map"
  item_bundle_map_aggregate(
    # distinct select on columns
    distinct_on: [item_bundle_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_bundle_map_order_by!]

    # filter the rows returned
    where: item_bundle_map_bool_exp
  ): item_bundle_map_aggregate!

  # fetch data from the table: "item.bundle_map" using primary key columns
  item_bundle_map_by_pk(item_bundle_id: Int!, item_member_id: Int!): item_bundle_map

  # fetch data from the table: "item" using primary key columns
  item_by_pk(id: Int!): item

  # fetch data from the table: "item.cable_conductive"
  item_cable_conductive(
    # distinct select on columns
    distinct_on: [item_cable_conductive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_cable_conductive_order_by!]

    # filter the rows returned
    where: item_cable_conductive_bool_exp
  ): [item_cable_conductive!]!

  # fetch aggregated fields from the table: "item.cable_conductive"
  item_cable_conductive_aggregate(
    # distinct select on columns
    distinct_on: [item_cable_conductive_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_cable_conductive_order_by!]

    # filter the rows returned
    where: item_cable_conductive_bool_exp
  ): item_cable_conductive_aggregate!

  # fetch data from the table: "item.cable_conductive" using primary key columns
  item_cable_conductive_by_pk(id: Int!): item_cable_conductive

  # fetch data from the table: "item.hardware_drill_bit"
  item_hardware_drill_bit(
    # distinct select on columns
    distinct_on: [item_hardware_drill_bit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_drill_bit_order_by!]

    # filter the rows returned
    where: item_hardware_drill_bit_bool_exp
  ): [item_hardware_drill_bit!]!

  # fetch aggregated fields from the table: "item.hardware_drill_bit"
  item_hardware_drill_bit_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_drill_bit_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_drill_bit_order_by!]

    # filter the rows returned
    where: item_hardware_drill_bit_bool_exp
  ): item_hardware_drill_bit_aggregate!

  # fetch data from the table: "item.hardware_drill_bit" using primary key columns
  item_hardware_drill_bit_by_pk(id: Int!): item_hardware_drill_bit

  # fetch data from the table: "item.hardware_fastener_insert"
  item_hardware_fastener_insert(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_insert_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_insert_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_insert_bool_exp
  ): [item_hardware_fastener_insert!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_insert"
  item_hardware_fastener_insert_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_insert_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_insert_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_insert_bool_exp
  ): item_hardware_fastener_insert_aggregate!

  # fetch data from the table: "item.hardware_fastener_insert" using primary key columns
  item_hardware_fastener_insert_by_pk(id: Int!): item_hardware_fastener_insert

  # fetch data from the table: "item.hardware_fastener_nut"
  item_hardware_fastener_nut(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_nut_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_nut_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_nut_bool_exp
  ): [item_hardware_fastener_nut!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_nut"
  item_hardware_fastener_nut_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_nut_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_nut_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_nut_bool_exp
  ): item_hardware_fastener_nut_aggregate!

  # fetch data from the table: "item.hardware_fastener_nut" using primary key columns
  item_hardware_fastener_nut_by_pk(id: Int!): item_hardware_fastener_nut

  # fetch data from the table: "item.hardware_fastener_screw"
  item_hardware_fastener_screw(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_bool_exp
  ): [item_hardware_fastener_screw!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_screw"
  item_hardware_fastener_screw_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_bool_exp
  ): item_hardware_fastener_screw_aggregate!

  # fetch data from the table: "item.hardware_fastener_screw" using primary key columns
  item_hardware_fastener_screw_by_pk(id: Int!): item_hardware_fastener_screw

  # fetch data from the table: "item.hardware_fastener_screw_machine"
  item_hardware_fastener_screw_machine(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_machine_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_machine_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_machine_bool_exp
  ): [item_hardware_fastener_screw_machine!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_screw_machine"
  item_hardware_fastener_screw_machine_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_screw_machine_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_screw_machine_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_screw_machine_bool_exp
  ): item_hardware_fastener_screw_machine_aggregate!

  # fetch data from the table: "item.hardware_fastener_screw_machine" using primary key columns
  item_hardware_fastener_screw_machine_by_pk(id: Int!): item_hardware_fastener_screw_machine

  # fetch data from the table: "item.hardware_fastener_standoff"
  item_hardware_fastener_standoff(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_standoff_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_standoff_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_standoff_bool_exp
  ): [item_hardware_fastener_standoff!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_standoff"
  item_hardware_fastener_standoff_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_standoff_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_standoff_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_standoff_bool_exp
  ): item_hardware_fastener_standoff_aggregate!

  # fetch data from the table: "item.hardware_fastener_standoff" using primary key columns
  item_hardware_fastener_standoff_by_pk(id: Int!): item_hardware_fastener_standoff

  # fetch data from the table: "item.hardware_fastener_washer"
  item_hardware_fastener_washer(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_washer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_washer_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_washer_bool_exp
  ): [item_hardware_fastener_washer!]!

  # fetch aggregated fields from the table: "item.hardware_fastener_washer"
  item_hardware_fastener_washer_aggregate(
    # distinct select on columns
    distinct_on: [item_hardware_fastener_washer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_hardware_fastener_washer_order_by!]

    # filter the rows returned
    where: item_hardware_fastener_washer_bool_exp
  ): item_hardware_fastener_washer_aggregate!

  # fetch data from the table: "item.hardware_fastener_washer" using primary key columns
  item_hardware_fastener_washer_by_pk(id: Int!): item_hardware_fastener_washer

  # fetch data from the table: "item_variant"
  item_variant(
    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): [item_variant!]!

  # fetch aggregated fields from the table: "item_variant"
  item_variant_aggregate(
    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): item_variant_aggregate!

  # fetch data from the table: "label"
  label(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): [label!]!

  # fetch aggregated fields from the table: "label"
  label_aggregate(
    # distinct select on columns
    distinct_on: [label_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_order_by!]

    # filter the rows returned
    where: label_bool_exp
  ): label_aggregate!

  # fetch data from the table: "label" using primary key columns
  label_by_pk(id: uuid!): label

  # fetch data from the table: "label_item_map"
  label_item_map(
    # distinct select on columns
    distinct_on: [label_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_item_map_order_by!]

    # filter the rows returned
    where: label_item_map_bool_exp
  ): [label_item_map!]!

  # fetch aggregated fields from the table: "label_item_map"
  label_item_map_aggregate(
    # distinct select on columns
    distinct_on: [label_item_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_item_map_order_by!]

    # filter the rows returned
    where: label_item_map_bool_exp
  ): label_item_map_aggregate!

  # fetch data from the table: "label_item_map" using primary key columns
  label_item_map_by_pk(item_id: Int!, label_id: uuid!): label_item_map

  # fetch data from the table: "label_template_map"
  label_template_map(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): [label_template_map!]!

  # fetch aggregated fields from the table: "label_template_map"
  label_template_map_aggregate(
    # distinct select on columns
    distinct_on: [label_template_map_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [label_template_map_order_by!]

    # filter the rows returned
    where: label_template_map_bool_exp
  ): label_template_map_aggregate!

  # fetch data from the table: "label_template_map" using primary key columns
  label_template_map_by_pk(item_class: String!, label_id: uuid!, sequence: smallint!): label_template_map

  # fetch data from the table: "manufacturer"
  manufacturer(
    # distinct select on columns
    distinct_on: [manufacturer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_order_by!]

    # filter the rows returned
    where: manufacturer_bool_exp
  ): [manufacturer!]!

  # fetch aggregated fields from the table: "manufacturer"
  manufacturer_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_order_by!]

    # filter the rows returned
    where: manufacturer_bool_exp
  ): manufacturer_aggregate!

  # fetch data from the table: "manufacturer" using primary key columns
  manufacturer_by_pk(id: Int!): manufacturer

  # fetch data from the table: "manufacturer_item"
  manufacturer_item(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): [manufacturer_item!]!

  # fetch aggregated fields from the table: "manufacturer_item"
  manufacturer_item_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_item_order_by!]

    # filter the rows returned
    where: manufacturer_item_bool_exp
  ): manufacturer_item_aggregate!

  # fetch data from the table: "manufacturer_item" using primary key columns
  manufacturer_item_by_pk(id: Int!): manufacturer_item

  # fetch data from the table: "order"
  order(
    # distinct select on columns
    distinct_on: [order_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_order_by!]

    # filter the rows returned
    where: order_bool_exp
  ): [order!]!

  # fetch aggregated fields from the table: "order"
  order_aggregate(
    # distinct select on columns
    distinct_on: [order_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_order_by!]

    # filter the rows returned
    where: order_bool_exp
  ): order_aggregate!

  # fetch data from the table: "order" using primary key columns
  order_by_pk(id: Int!): order

  # fetch data from the table: "order_item"
  order_item(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): [order_item!]!

  # fetch aggregated fields from the table: "order_item"
  order_item_aggregate(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): order_item_aggregate!

  # fetch data from the table: "order_item" using primary key columns
  order_item_by_pk(id: Int!): order_item

  # fetch data from the table: "payment_method"
  payment_method(
    # distinct select on columns
    distinct_on: [payment_method_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [payment_method_order_by!]

    # filter the rows returned
    where: payment_method_bool_exp
  ): [payment_method!]!

  # fetch aggregated fields from the table: "payment_method"
  payment_method_aggregate(
    # distinct select on columns
    distinct_on: [payment_method_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [payment_method_order_by!]

    # filter the rows returned
    where: payment_method_bool_exp
  ): payment_method_aggregate!

  # fetch data from the table: "payment_method" using primary key columns
  payment_method_by_pk(id: Int!): payment_method

  # fetch data from the table: "property.item_hardware_fastener_bolt_strength"
  property_item_hardware_fastener_bolt_strength(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_bolt_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_bolt_strength_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_bolt_strength_bool_exp
  ): [property_item_hardware_fastener_bolt_strength!]!

  # fetch aggregated fields from the table: "property.item_hardware_fastener_bolt_strength"
  property_item_hardware_fastener_bolt_strength_aggregate(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_bolt_strength_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_bolt_strength_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_bolt_strength_bool_exp
  ): property_item_hardware_fastener_bolt_strength_aggregate!

  # fetch data from the table: "property.item_hardware_fastener_bolt_strength" using primary key columns
  property_item_hardware_fastener_bolt_strength_by_pk(diameter: numeric!, strength_grade: String!, thread_pitch: numeric!): property_item_hardware_fastener_bolt_strength

  # fetch data from the table: "property_item_hardware_fastener_screw_machine.diameter"
  property_item_hardware_fastener_screw_machine_diameter(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_screw_machine_diameter_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_screw_machine_diameter_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_screw_machine_diameter_bool_exp
  ): [property_item_hardware_fastener_screw_machine_diameter!]!

  # fetch aggregated fields from the table: "property_item_hardware_fastener_screw_machine.diameter"
  property_item_hardware_fastener_screw_machine_diameter_aggregate(
    # distinct select on columns
    distinct_on: [property_item_hardware_fastener_screw_machine_diameter_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_item_hardware_fastener_screw_machine_diameter_order_by!]

    # filter the rows returned
    where: property_item_hardware_fastener_screw_machine_diameter_bool_exp
  ): property_item_hardware_fastener_screw_machine_diameter_aggregate!

  # fetch data from the table: "property_item_hardware_fastener_screw_machine.diameter" using primary key columns
  property_item_hardware_fastener_screw_machine_diameter_by_pk(diameter_major: numeric!, fit: enum_item_hardware_fastener_screw_machine_thread_fit_enum!, pitch: numeric!): property_item_hardware_fastener_screw_machine_diameter

  # execute function "search" which returns "search_data"
  search(
    # input parameters for function "search"
    args: search_args!

    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): [search_data!]!

  # execute function "search" and query aggregates on result of table type "search_data"
  search_aggregate(
    # input parameters for function "search"
    args: search_args!

    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): search_data_aggregate!

  # fetch data from the table: "search_data"
  search_data(
    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): [search_data!]!

  # fetch aggregated fields from the table: "search_data"
  search_data_aggregate(
    # distinct select on columns
    distinct_on: [search_data_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [search_data_order_by!]

    # filter the rows returned
    where: search_data_bool_exp
  ): search_data_aggregate!

  # fetch data from the table: "search_data" using primary key columns
  search_data_by_pk(id: bigint!): search_data

  # execute function "search_item" which returns "item"
  search_item(
    # input parameters for function "search_item"
    args: search_item_args!

    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): [item!]!

  # execute function "search_item" and query aggregates on result of table type "item"
  search_item_aggregate(
    # input parameters for function "search_item"
    args: search_item_args!

    # distinct select on columns
    distinct_on: [item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_order_by!]

    # filter the rows returned
    where: item_bool_exp
  ): item_aggregate!

  # execute function "search_item_variant" which returns "item_variant"
  search_item_variant(
    # input parameters for function "search_item_variant"
    args: search_item_variant_args!

    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): [item_variant!]!

  # execute function "search_item_variant" and query aggregates on result of table type "item_variant"
  search_item_variant_aggregate(
    # input parameters for function "search_item_variant"
    args: search_item_variant_args!

    # distinct select on columns
    distinct_on: [item_variant_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [item_variant_order_by!]

    # filter the rows returned
    where: item_variant_bool_exp
  ): item_variant_aggregate!

  # fetch data from the table: "shipment"
  shipment(
    # distinct select on columns
    distinct_on: [shipment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [shipment_order_by!]

    # filter the rows returned
    where: shipment_bool_exp
  ): [shipment!]!

  # fetch aggregated fields from the table: "shipment"
  shipment_aggregate(
    # distinct select on columns
    distinct_on: [shipment_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [shipment_order_by!]

    # filter the rows returned
    where: shipment_bool_exp
  ): shipment_aggregate!

  # fetch data from the table: "shipment" using primary key columns
  shipment_by_pk(id: Int!): shipment

  # fetch data from the table: "stock"
  stock(
    # distinct select on columns
    distinct_on: [stock_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stock_order_by!]

    # filter the rows returned
    where: stock_bool_exp
  ): [stock!]!

  # fetch aggregated fields from the table: "stock"
  stock_aggregate(
    # distinct select on columns
    distinct_on: [stock_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stock_order_by!]

    # filter the rows returned
    where: stock_bool_exp
  ): stock_aggregate!

  # fetch data from the table: "stock" using primary key columns
  stock_by_pk(id: Int!): stock

  # fetch data from the table: "storage"
  storage(
    # distinct select on columns
    distinct_on: [storage_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [storage_order_by!]

    # filter the rows returned
    where: storage_bool_exp
  ): [storage!]!

  # fetch aggregated fields from the table: "storage"
  storage_aggregate(
    # distinct select on columns
    distinct_on: [storage_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [storage_order_by!]

    # filter the rows returned
    where: storage_bool_exp
  ): storage_aggregate!

  # fetch data from the table: "storage" using primary key columns
  storage_by_pk(id: Int!): storage

  # fetch data from the table: "tag"
  tag(
    # distinct select on columns
    distinct_on: [tag_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tag_order_by!]

    # filter the rows returned
    where: tag_bool_exp
  ): [tag!]!

  # fetch aggregated fields from the table: "tag"
  tag_aggregate(
    # distinct select on columns
    distinct_on: [tag_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tag_order_by!]

    # filter the rows returned
    where: tag_bool_exp
  ): tag_aggregate!

  # fetch data from the table: "tag" using primary key columns
  tag_by_pk(text: String!): tag

  # fetch data from the table: "vendor"
  vendor(
    # distinct select on columns
    distinct_on: [vendor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_order_by!]

    # filter the rows returned
    where: vendor_bool_exp
  ): [vendor!]!

  # fetch aggregated fields from the table: "vendor"
  vendor_aggregate(
    # distinct select on columns
    distinct_on: [vendor_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_order_by!]

    # filter the rows returned
    where: vendor_bool_exp
  ): vendor_aggregate!

  # fetch data from the table: "vendor" using primary key columns
  vendor_by_pk(id: Int!): vendor

  # fetch data from the table: "vendor_item"
  vendor_item(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): [vendor_item!]!

  # fetch aggregated fields from the table: "vendor_item"
  vendor_item_aggregate(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): vendor_item_aggregate!

  # fetch data from the table: "vendor_item" using primary key columns
  vendor_item_by_pk(id: Int!): vendor_item
}

# columns and relationships of "tag"
type tag {
  id: Int
  text: String!
}

# aggregated selection of "tag"
type tag_aggregate {
  aggregate: tag_aggregate_fields
  nodes: [tag!]!
}

# aggregate fields of "tag"
type tag_aggregate_fields {
  avg: tag_avg_fields
  count(columns: [tag_select_column!], distinct: Boolean): Int
  max: tag_max_fields
  min: tag_min_fields
  stddev: tag_stddev_fields
  stddev_pop: tag_stddev_pop_fields
  stddev_samp: tag_stddev_samp_fields
  sum: tag_sum_fields
  var_pop: tag_var_pop_fields
  var_samp: tag_var_samp_fields
  variance: tag_variance_fields
}

# order by aggregate values of table "tag"
input tag_aggregate_order_by {
  avg: tag_avg_order_by
  count: order_by
  max: tag_max_order_by
  min: tag_min_order_by
  stddev: tag_stddev_order_by
  stddev_pop: tag_stddev_pop_order_by
  stddev_samp: tag_stddev_samp_order_by
  sum: tag_sum_order_by
  var_pop: tag_var_pop_order_by
  var_samp: tag_var_samp_order_by
  variance: tag_variance_order_by
}

# input type for inserting array relation for remote table "tag"
input tag_arr_rel_insert_input {
  data: [tag_insert_input!]!
  on_conflict: tag_on_conflict
}

# aggregate avg on columns
type tag_avg_fields {
  id: Float
}

# order by avg() on columns of table "tag"
input tag_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "tag". All fields are combined with a logical 'AND'.
input tag_bool_exp {
  _and: [tag_bool_exp]
  _not: tag_bool_exp
  _or: [tag_bool_exp]
  id: Int_comparison_exp
  text: String_comparison_exp
}

# unique or primary key constraints on table "tag"
enum tag_constraint {
  # unique or primary key constraint
  tag_id_key

  # unique or primary key constraint
  tag_pkey
}

# input type for incrementing integer column in table "tag"
input tag_inc_input {
  id: Int
}

# input type for inserting data into table "tag"
input tag_insert_input {
  id: Int
  text: String
}

# aggregate max on columns
type tag_max_fields {
  id: Int
  text: String
}

# order by max() on columns of table "tag"
input tag_max_order_by {
  id: order_by
  text: order_by
}

# aggregate min on columns
type tag_min_fields {
  id: Int
  text: String
}

# order by min() on columns of table "tag"
input tag_min_order_by {
  id: order_by
  text: order_by
}

# response of any mutation on the table "tag"
type tag_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [tag!]!
}

# input type for inserting object relation for remote table "tag"
input tag_obj_rel_insert_input {
  data: tag_insert_input!
  on_conflict: tag_on_conflict
}

# on conflict condition type for table "tag"
input tag_on_conflict {
  constraint: tag_constraint!
  update_columns: [tag_update_column!]!
  where: tag_bool_exp
}

# ordering options when selecting data from "tag"
input tag_order_by {
  id: order_by
  text: order_by
}

# primary key columns input for table: "tag"
input tag_pk_columns_input {
  text: String!
}

# select columns of table "tag"
enum tag_select_column {
  # column name
  id

  # column name
  text
}

# input type for updating data in table "tag"
input tag_set_input {
  id: Int
  text: String
}

# aggregate stddev on columns
type tag_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "tag"
input tag_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type tag_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "tag"
input tag_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type tag_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "tag"
input tag_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type tag_sum_fields {
  id: Int
}

# order by sum() on columns of table "tag"
input tag_sum_order_by {
  id: order_by
}

# update columns of table "tag"
enum tag_update_column {
  # column name
  id

  # column name
  text
}

# aggregate var_pop on columns
type tag_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "tag"
input tag_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type tag_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "tag"
input tag_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type tag_variance_fields {
  id: Float
}

# order by variance() on columns of table "tag"
input tag_variance_order_by {
  id: order_by
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar tsvector

# expression to compare columns of type tsvector. All fields are combined with logical 'AND'.
input tsvector_comparison_exp {
  _eq: tsvector
  _gt: tsvector
  _gte: tsvector
  _in: [tsvector!]
  _is_null: Boolean
  _lt: tsvector
  _lte: tsvector
  _neq: tsvector
  _nin: [tsvector!]
}

# uint8 (unsigned int between 0 and 255) scalar type for Apollo GraphQL
scalar uint8

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

# columns and relationships of "vendor"
type vendor {
  account_id: String
  id: Int!

  # An array relationship
  manufacturer(
    # distinct select on columns
    distinct_on: [manufacturer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_order_by!]

    # filter the rows returned
    where: manufacturer_bool_exp
  ): [manufacturer!]!

  # An aggregated array relationship
  manufacturer_aggregate(
    # distinct select on columns
    distinct_on: [manufacturer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [manufacturer_order_by!]

    # filter the rows returned
    where: manufacturer_bool_exp
  ): manufacturer_aggregate!
  name: String!

  # An array relationship
  orders(
    # distinct select on columns
    distinct_on: [order_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_order_by!]

    # filter the rows returned
    where: order_bool_exp
  ): [order!]!

  # An aggregated array relationship
  orders_aggregate(
    # distinct select on columns
    distinct_on: [order_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_order_by!]

    # filter the rows returned
    where: order_bool_exp
  ): order_aggregate!
  url: String

  # An array relationship
  vendor_items(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): [vendor_item!]!

  # An aggregated array relationship
  vendor_items_aggregate(
    # distinct select on columns
    distinct_on: [vendor_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [vendor_item_order_by!]

    # filter the rows returned
    where: vendor_item_bool_exp
  ): vendor_item_aggregate!
}

# aggregated selection of "vendor"
type vendor_aggregate {
  aggregate: vendor_aggregate_fields
  nodes: [vendor!]!
}

# aggregate fields of "vendor"
type vendor_aggregate_fields {
  avg: vendor_avg_fields
  count(columns: [vendor_select_column!], distinct: Boolean): Int
  max: vendor_max_fields
  min: vendor_min_fields
  stddev: vendor_stddev_fields
  stddev_pop: vendor_stddev_pop_fields
  stddev_samp: vendor_stddev_samp_fields
  sum: vendor_sum_fields
  var_pop: vendor_var_pop_fields
  var_samp: vendor_var_samp_fields
  variance: vendor_variance_fields
}

# order by aggregate values of table "vendor"
input vendor_aggregate_order_by {
  avg: vendor_avg_order_by
  count: order_by
  max: vendor_max_order_by
  min: vendor_min_order_by
  stddev: vendor_stddev_order_by
  stddev_pop: vendor_stddev_pop_order_by
  stddev_samp: vendor_stddev_samp_order_by
  sum: vendor_sum_order_by
  var_pop: vendor_var_pop_order_by
  var_samp: vendor_var_samp_order_by
  variance: vendor_variance_order_by
}

# input type for inserting array relation for remote table "vendor"
input vendor_arr_rel_insert_input {
  data: [vendor_insert_input!]!
  on_conflict: vendor_on_conflict
}

# aggregate avg on columns
type vendor_avg_fields {
  id: Float
}

# order by avg() on columns of table "vendor"
input vendor_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "vendor". All fields are combined with a logical 'AND'.
input vendor_bool_exp {
  _and: [vendor_bool_exp]
  _not: vendor_bool_exp
  _or: [vendor_bool_exp]
  account_id: String_comparison_exp
  id: Int_comparison_exp
  manufacturer: manufacturer_bool_exp
  name: String_comparison_exp
  orders: order_bool_exp
  url: String_comparison_exp
  vendor_items: vendor_item_bool_exp
}

# unique or primary key constraints on table "vendor"
enum vendor_constraint {
  # unique or primary key constraint
  vendor_pkey
}

# input type for incrementing integer column in table "vendor"
input vendor_inc_input {
  id: Int
}

# input type for inserting data into table "vendor"
input vendor_insert_input {
  account_id: String
  id: Int
  manufacturer: manufacturer_arr_rel_insert_input
  name: String
  orders: order_arr_rel_insert_input
  url: String
  vendor_items: vendor_item_arr_rel_insert_input
}

# columns and relationships of "vendor_item"
type vendor_item {
  # this should track "variations" of the item_id.      For example the item might be cat6 550mhz      but the vendor item would be 1000ft of it.
  description: String
  id: Int!

  # An object relationship
  item: item!
  item_id: Int!

  # An array relationship
  orderItems(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): [order_item!]!

  # An aggregated array relationship
  orderItems_aggregate(
    # distinct select on columns
    distinct_on: [order_item_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [order_item_order_by!]

    # filter the rows returned
    where: order_item_bool_exp
  ): order_item_aggregate!

  # An object relationship
  vendor: vendor!
  vendor_id: Int!
  vendor_sku: String!
}

# aggregated selection of "vendor_item"
type vendor_item_aggregate {
  aggregate: vendor_item_aggregate_fields
  nodes: [vendor_item!]!
}

# aggregate fields of "vendor_item"
type vendor_item_aggregate_fields {
  avg: vendor_item_avg_fields
  count(columns: [vendor_item_select_column!], distinct: Boolean): Int
  max: vendor_item_max_fields
  min: vendor_item_min_fields
  stddev: vendor_item_stddev_fields
  stddev_pop: vendor_item_stddev_pop_fields
  stddev_samp: vendor_item_stddev_samp_fields
  sum: vendor_item_sum_fields
  var_pop: vendor_item_var_pop_fields
  var_samp: vendor_item_var_samp_fields
  variance: vendor_item_variance_fields
}

# order by aggregate values of table "vendor_item"
input vendor_item_aggregate_order_by {
  avg: vendor_item_avg_order_by
  count: order_by
  max: vendor_item_max_order_by
  min: vendor_item_min_order_by
  stddev: vendor_item_stddev_order_by
  stddev_pop: vendor_item_stddev_pop_order_by
  stddev_samp: vendor_item_stddev_samp_order_by
  sum: vendor_item_sum_order_by
  var_pop: vendor_item_var_pop_order_by
  var_samp: vendor_item_var_samp_order_by
  variance: vendor_item_variance_order_by
}

# input type for inserting array relation for remote table "vendor_item"
input vendor_item_arr_rel_insert_input {
  data: [vendor_item_insert_input!]!
  on_conflict: vendor_item_on_conflict
}

# aggregate avg on columns
type vendor_item_avg_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by avg() on columns of table "vendor_item"
input vendor_item_avg_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# Boolean expression to filter rows from the table "vendor_item". All fields are combined with a logical 'AND'.
input vendor_item_bool_exp {
  _and: [vendor_item_bool_exp]
  _not: vendor_item_bool_exp
  _or: [vendor_item_bool_exp]
  description: String_comparison_exp
  id: Int_comparison_exp
  item: item_bool_exp
  item_id: Int_comparison_exp
  orderItems: order_item_bool_exp
  vendor: vendor_bool_exp
  vendor_id: Int_comparison_exp
  vendor_sku: String_comparison_exp
}

# unique or primary key constraints on table "vendor_item"
enum vendor_item_constraint {
  # unique or primary key constraint
  vendor_item_id_item_id_key

  # unique or primary key constraint
  vendor_item_pkey
}

# input type for incrementing integer column in table "vendor_item"
input vendor_item_inc_input {
  id: Int
  item_id: Int
  vendor_id: Int
}

# input type for inserting data into table "vendor_item"
input vendor_item_insert_input {
  description: String
  id: Int
  item: item_obj_rel_insert_input
  item_id: Int
  orderItems: order_item_arr_rel_insert_input
  vendor: vendor_obj_rel_insert_input
  vendor_id: Int
  vendor_sku: String
}

# aggregate max on columns
type vendor_item_max_fields {
  description: String
  id: Int
  item_id: Int
  vendor_id: Int
  vendor_sku: String
}

# order by max() on columns of table "vendor_item"
input vendor_item_max_order_by {
  description: order_by
  id: order_by
  item_id: order_by
  vendor_id: order_by
  vendor_sku: order_by
}

# aggregate min on columns
type vendor_item_min_fields {
  description: String
  id: Int
  item_id: Int
  vendor_id: Int
  vendor_sku: String
}

# order by min() on columns of table "vendor_item"
input vendor_item_min_order_by {
  description: order_by
  id: order_by
  item_id: order_by
  vendor_id: order_by
  vendor_sku: order_by
}

# response of any mutation on the table "vendor_item"
type vendor_item_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [vendor_item!]!
}

# input type for inserting object relation for remote table "vendor_item"
input vendor_item_obj_rel_insert_input {
  data: vendor_item_insert_input!
  on_conflict: vendor_item_on_conflict
}

# on conflict condition type for table "vendor_item"
input vendor_item_on_conflict {
  constraint: vendor_item_constraint!
  update_columns: [vendor_item_update_column!]!
  where: vendor_item_bool_exp
}

# ordering options when selecting data from "vendor_item"
input vendor_item_order_by {
  description: order_by
  id: order_by
  item: item_order_by
  item_id: order_by
  orderItems_aggregate: order_item_aggregate_order_by
  vendor: vendor_order_by
  vendor_id: order_by
  vendor_sku: order_by
}

# primary key columns input for table: "vendor_item"
input vendor_item_pk_columns_input {
  id: Int!
}

# select columns of table "vendor_item"
enum vendor_item_select_column {
  # column name
  description

  # column name
  id

  # column name
  item_id

  # column name
  vendor_id

  # column name
  vendor_sku
}

# input type for updating data in table "vendor_item"
input vendor_item_set_input {
  description: String
  id: Int
  item_id: Int
  vendor_id: Int
  vendor_sku: String
}

# aggregate stddev on columns
type vendor_item_stddev_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by stddev() on columns of table "vendor_item"
input vendor_item_stddev_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# aggregate stddev_pop on columns
type vendor_item_stddev_pop_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by stddev_pop() on columns of table "vendor_item"
input vendor_item_stddev_pop_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# aggregate stddev_samp on columns
type vendor_item_stddev_samp_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by stddev_samp() on columns of table "vendor_item"
input vendor_item_stddev_samp_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# aggregate sum on columns
type vendor_item_sum_fields {
  id: Int
  item_id: Int
  vendor_id: Int
}

# order by sum() on columns of table "vendor_item"
input vendor_item_sum_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# update columns of table "vendor_item"
enum vendor_item_update_column {
  # column name
  description

  # column name
  id

  # column name
  item_id

  # column name
  vendor_id

  # column name
  vendor_sku
}

# aggregate var_pop on columns
type vendor_item_var_pop_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by var_pop() on columns of table "vendor_item"
input vendor_item_var_pop_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# aggregate var_samp on columns
type vendor_item_var_samp_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by var_samp() on columns of table "vendor_item"
input vendor_item_var_samp_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# aggregate variance on columns
type vendor_item_variance_fields {
  id: Float
  item_id: Float
  vendor_id: Float
}

# order by variance() on columns of table "vendor_item"
input vendor_item_variance_order_by {
  id: order_by
  item_id: order_by
  vendor_id: order_by
}

# aggregate max on columns
type vendor_max_fields {
  account_id: String
  id: Int
  name: String
  url: String
}

# order by max() on columns of table "vendor"
input vendor_max_order_by {
  account_id: order_by
  id: order_by
  name: order_by
  url: order_by
}

# aggregate min on columns
type vendor_min_fields {
  account_id: String
  id: Int
  name: String
  url: String
}

# order by min() on columns of table "vendor"
input vendor_min_order_by {
  account_id: order_by
  id: order_by
  name: order_by
  url: order_by
}

# response of any mutation on the table "vendor"
type vendor_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [vendor!]!
}

# input type for inserting object relation for remote table "vendor"
input vendor_obj_rel_insert_input {
  data: vendor_insert_input!
  on_conflict: vendor_on_conflict
}

# on conflict condition type for table "vendor"
input vendor_on_conflict {
  constraint: vendor_constraint!
  update_columns: [vendor_update_column!]!
  where: vendor_bool_exp
}

# ordering options when selecting data from "vendor"
input vendor_order_by {
  account_id: order_by
  id: order_by
  manufacturer_aggregate: manufacturer_aggregate_order_by
  name: order_by
  orders_aggregate: order_aggregate_order_by
  url: order_by
  vendor_items_aggregate: vendor_item_aggregate_order_by
}

# primary key columns input for table: "vendor"
input vendor_pk_columns_input {
  id: Int!
}

# select columns of table "vendor"
enum vendor_select_column {
  # column name
  account_id

  # column name
  id

  # column name
  name

  # column name
  url
}

# input type for updating data in table "vendor"
input vendor_set_input {
  account_id: String
  id: Int
  name: String
  url: String
}

# aggregate stddev on columns
type vendor_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "vendor"
input vendor_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type vendor_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "vendor"
input vendor_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type vendor_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "vendor"
input vendor_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type vendor_sum_fields {
  id: Int
}

# order by sum() on columns of table "vendor"
input vendor_sum_order_by {
  id: order_by
}

# update columns of table "vendor"
enum vendor_update_column {
  # column name
  account_id

  # column name
  id

  # column name
  name

  # column name
  url
}

# aggregate var_pop on columns
type vendor_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "vendor"
input vendor_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type vendor_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "vendor"
input vendor_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type vendor_variance_fields {
  id: Float
}

# order by variance() on columns of table "vendor"
input vendor_variance_order_by {
  id: order_by
}
